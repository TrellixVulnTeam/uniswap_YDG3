{"ast":null,"code":"import _regeneratorRuntime from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { log } from '../../util/log';\n/**\n * Provider for getting V3 pools, with functionality for caching the results.\n *\n * @export\n * @class CachingV3PoolProvider\n */\n\nexport var CachingV3PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of CachingV3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param poolProvider The provider to use to get the pools when not in the cache.\n   * @param cache Cache instance to hold cached pools.\n   */\n  function CachingV3PoolProvider(chainId, poolProvider, cache) {\n    _classCallCheck(this, CachingV3PoolProvider);\n\n    this.chainId = chainId;\n    this.poolProvider = poolProvider;\n    this.cache = cache;\n\n    this.POOL_KEY = function (chainId, address) {\n      return \"pool-\".concat(chainId, \"-\").concat(address);\n    };\n  }\n\n  _createClass(CachingV3PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n\n        var poolAddressSet, poolsToGetTokenPairs, poolsToGetAddresses, poolAddressToPool, _iterator, _step, _step$value, tokenA, tokenB, feeAmount, _this$getPoolAddress2, poolAddress, token0, token1, cachedPool, poolAccessor, _iterator2, _step2, address, pool;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                poolsToGetTokenPairs = [];\n                poolsToGetAddresses = [];\n                poolAddressToPool = {};\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 23;\n                  break;\n                }\n\n                _step$value = _slicedToArray(_step.value, 3), tokenA = _step$value[0], tokenB = _step$value[1], feeAmount = _step$value[2];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB, feeAmount), poolAddress = _this$getPoolAddress2.poolAddress, token0 = _this$getPoolAddress2.token0, token1 = _this$getPoolAddress2.token1;\n\n                if (!poolAddressSet.has(poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 21);\n\n              case 12:\n                poolAddressSet.add(poolAddress);\n                _context.next = 15;\n                return this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n\n              case 15:\n                cachedPool = _context.sent;\n\n                if (!cachedPool) {\n                  _context.next = 19;\n                  break;\n                }\n\n                poolAddressToPool[poolAddress] = cachedPool;\n                return _context.abrupt(\"continue\", 21);\n\n              case 19:\n                poolsToGetTokenPairs.push([token0, token1, feeAmount]);\n                poolsToGetAddresses.push(poolAddress);\n\n              case 21:\n                _context.next = 7;\n                break;\n\n              case 23:\n                _context.next = 28;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](5);\n\n                _iterator.e(_context.t0);\n\n              case 28:\n                _context.prev = 28;\n\n                _iterator.f();\n\n                return _context.finish(28);\n\n              case 31:\n                log.info(\"Found \".concat(Object.keys(poolAddressToPool).length, \" pools already in local cache. About to get liquidity and slot0s for \").concat(poolsToGetTokenPairs.length, \" pools.\"));\n\n                if (!(poolsToGetAddresses.length > 0)) {\n                  _context.next = 56;\n                  break;\n                }\n\n                _context.next = 35;\n                return this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n\n              case 35:\n                poolAccessor = _context.sent;\n                _iterator2 = _createForOfIteratorHelper(poolsToGetAddresses);\n                _context.prev = 37;\n\n                _iterator2.s();\n\n              case 39:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 48;\n                  break;\n                }\n\n                address = _step2.value;\n                pool = poolAccessor.getPoolByAddress(address);\n\n                if (!pool) {\n                  _context.next = 46;\n                  break;\n                }\n\n                poolAddressToPool[address] = pool;\n                _context.next = 46;\n                return this.cache.set(this.POOL_KEY(this.chainId, address), pool);\n\n              case 46:\n                _context.next = 39;\n                break;\n\n              case 48:\n                _context.next = 53;\n                break;\n\n              case 50:\n                _context.prev = 50;\n                _context.t1 = _context[\"catch\"](37);\n\n                _iterator2.e(_context.t1);\n\n              case 53:\n                _context.prev = 53;\n\n                _iterator2.f();\n\n                return _context.finish(53);\n\n              case 56:\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB, feeAmount) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB, feeAmount),\n                        poolAddress = _this$getPoolAddress.poolAddress;\n\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n\n              case 57:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 25, 28, 31], [37, 50, 53, 56]]);\n      }));\n\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB, feeAmount) {\n      return this.poolProvider.getPoolAddress(tokenA, tokenB, feeAmount);\n    }\n  }]);\n\n  return CachingV3PoolProvider;\n}();","map":{"version":3,"sources":["../../../../../src/providers/v3/caching-pool-provider.ts"],"names":[],"mappings":";;;;;;AAGA,SAAS,GAAT,QAAoB,gBAApB;AAKA;;;;;AAKG;;AACH,WAAa,qBAAb;AAIE;;;;;AAKG;AACH,iCACY,OADZ,EAEY,YAFZ,EAGU,KAHV,EAG6B;AAAA;;AAFjB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACF,SAAA,KAAA,GAAA,KAAA;;AAZF,SAAA,QAAA,GAAW,UAAC,OAAD,EAAmB,OAAnB;AAAA,4BACT,OADS,cACE,OADF;AAAA,KAAX;AAaJ;;AAdN;AAAA;AAAA;AAAA,+EAgBS,iBACL,UADK,EAEL,cAFK;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIC,gBAAA,cAJD,GAI+B,IAAI,GAAJ,EAJ/B;AAKC,gBAAA,oBALD,GAK0D,EAL1D;AAMC,gBAAA,mBAND,GAMiC,EANjC;AAOC,gBAAA,iBAPD,GAOsD,EAPtD;AAAA,uDASqC,UATrC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,8DASO,MATP,mBASe,MATf,mBASuB,SATvB;AAAA,wCAUqC,KAAK,cAAL,CACtC,MADsC,EAEtC,MAFsC,EAGtC,SAHsC,CAVrC,EAUK,WAVL,yBAUK,WAVL,EAUkB,MAVlB,yBAUkB,MAVlB,EAU0B,MAV1B,yBAU0B,MAV1B;;AAAA,qBAgBC,cAAc,CAAC,GAAf,CAAmB,WAAnB,CAhBD;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAoBH,gBAAA,cAAc,CAAC,GAAf,CAAmB,WAAnB;AApBG;AAAA,uBAsBsB,KAAK,KAAL,CAAW,GAAX,CACvB,KAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,WAA5B,CADuB,CAtBtB;;AAAA;AAsBG,gBAAA,UAtBH;;AAAA,qBAyBC,UAzBD;AAAA;AAAA;AAAA;;AA0BD,gBAAA,iBAAiB,CAAC,WAAD,CAAjB,GAAiC,UAAjC;AA1BC;;AAAA;AA8BH,gBAAA,oBAAoB,CAAC,IAArB,CAA0B,CAAC,MAAD,EAAS,MAAT,EAAiB,SAAjB,CAA1B;AACA,gBAAA,mBAAmB,CAAC,IAApB,CAAyB,WAAzB;;AA/BG;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAkCL,gBAAA,GAAG,CAAC,IAAJ,iBAEI,MAAM,CAAC,IAAP,CAAY,iBAAZ,EAA+B,MAFnC,kFAII,oBAAoB,CAAC,MAJzB;;AAlCK,sBA0CD,mBAAmB,CAAC,MAApB,GAA6B,CA1C5B;AAAA;AAAA;AAAA;;AAAA;AAAA,uBA2CwB,KAAK,YAAL,CAAkB,QAAlB,CACzB,oBADyB,EAEzB,cAFyB,CA3CxB;;AAAA;AA2CG,gBAAA,YA3CH;AAAA,wDA+CmB,mBA/CnB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+CQ,gBAAA,OA/CR;AAgDK,gBAAA,IAhDL,GAgDY,YAAY,CAAC,gBAAb,CAA8B,OAA9B,CAhDZ;;AAAA,qBAiDG,IAjDH;AAAA;AAAA;AAAA;;AAkDC,gBAAA,iBAAiB,CAAC,OAAD,CAAjB,GAA6B,IAA7B;AAlDD;AAAA,uBAmDO,KAAK,KAAL,CAAW,GAAX,CAAe,KAAK,QAAL,CAAc,KAAK,OAAnB,EAA4B,OAA5B,CAAf,EAAqD,IAArD,CAnDP;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,iDAwDE;AACL,kBAAA,OAAO,EAAE,iBACP,MADO,EAEP,MAFO,EAGP,SAHO,EAIa;AACpB,+CAAwB,KAAI,CAAC,cAAL,CAAoB,MAApB,EAA4B,MAA5B,EAAoC,SAApC,CAAxB;AAAA,wBAAQ,WAAR,wBAAQ,WAAR;;AACA,2BAAO,iBAAiB,CAAC,WAAD,CAAxB;AACD,mBARI;AASL,kBAAA,gBAAgB,EAAE,0BAAC,OAAD;AAAA,2BAChB,iBAAiB,CAAC,OAAD,CADD;AAAA,mBATb;AAWL,kBAAA,WAAW,EAAE;AAAA,2BAAc,MAAM,CAAC,MAAP,CAAc,iBAAd,CAAd;AAAA;AAXR,iBAxDF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAhBT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WAuFS,wBACL,MADK,EAEL,MAFK,EAGL,SAHK,EAGe;AAEpB,aAAO,KAAK,YAAL,CAAkB,cAAlB,CAAiC,MAAjC,EAAyC,MAAzC,EAAiD,SAAjD,CAAP;AACD;AA7FH;;AAAA;AAAA","sourceRoot":"","sourcesContent":["import { log } from '../../util/log';\n/**\n * Provider for getting V3 pools, with functionality for caching the results.\n *\n * @export\n * @class CachingV3PoolProvider\n */\nexport class CachingV3PoolProvider {\n    /**\n     * Creates an instance of CachingV3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param poolProvider The provider to use to get the pools when not in the cache.\n     * @param cache Cache instance to hold cached pools.\n     */\n    constructor(chainId, poolProvider, cache) {\n        this.chainId = chainId;\n        this.poolProvider = poolProvider;\n        this.cache = cache;\n        this.POOL_KEY = (chainId, address) => `pool-${chainId}-${address}`;\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const poolsToGetTokenPairs = [];\n        const poolsToGetAddresses = [];\n        const poolAddressToPool = {};\n        for (const [tokenA, tokenB, feeAmount] of tokenPairs) {\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            const cachedPool = await this.cache.get(this.POOL_KEY(this.chainId, poolAddress));\n            if (cachedPool) {\n                poolAddressToPool[poolAddress] = cachedPool;\n                continue;\n            }\n            poolsToGetTokenPairs.push([token0, token1, feeAmount]);\n            poolsToGetAddresses.push(poolAddress);\n        }\n        log.info(`Found ${Object.keys(poolAddressToPool).length} pools already in local cache. About to get liquidity and slot0s for ${poolsToGetTokenPairs.length} pools.`);\n        if (poolsToGetAddresses.length > 0) {\n            const poolAccessor = await this.poolProvider.getPools(poolsToGetTokenPairs, providerConfig);\n            for (const address of poolsToGetAddresses) {\n                const pool = poolAccessor.getPoolByAddress(address);\n                if (pool) {\n                    poolAddressToPool[address] = pool;\n                    await this.cache.set(this.POOL_KEY(this.chainId, address), pool);\n                }\n            }\n        }\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        return this.poolProvider.getPoolAddress(tokenA, tokenB, feeAmount);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGluZy1wb29sLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy92My9jYWNoaW5nLXBvb2wtcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBS3JDOzs7OztHQUtHO0FBQ0gsTUFBTSxPQUFPLHFCQUFxQjtJQUloQzs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsWUFBNkIsRUFDL0IsS0FBbUI7UUFGakIsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQUNoQixpQkFBWSxHQUFaLFlBQVksQ0FBaUI7UUFDL0IsVUFBSyxHQUFMLEtBQUssQ0FBYztRQVpyQixhQUFRLEdBQUcsQ0FBQyxPQUFnQixFQUFFLE9BQWUsRUFBRSxFQUFFLENBQ3ZELFFBQVEsT0FBTyxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBWTVCLENBQUM7SUFFRyxLQUFLLENBQUMsUUFBUSxDQUNuQixVQUF1QyxFQUN2QyxjQUErQjtRQUUvQixNQUFNLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUN0RCxNQUFNLG9CQUFvQixHQUFxQyxFQUFFLENBQUM7UUFDbEUsTUFBTSxtQkFBbUIsR0FBYSxFQUFFLENBQUM7UUFDekMsTUFBTSxpQkFBaUIsR0FBb0MsRUFBRSxDQUFDO1FBRTlELEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLElBQUksVUFBVSxFQUFFO1lBQ3BELE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQ3pELE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxDQUNWLENBQUM7WUFFRixJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ25DLFNBQVM7YUFDVjtZQUVELGNBQWMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFaEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUN6QyxDQUFDO1lBQ0YsSUFBSSxVQUFVLEVBQUU7Z0JBQ2QsaUJBQWlCLENBQUMsV0FBVyxDQUFDLEdBQUcsVUFBVSxDQUFDO2dCQUM1QyxTQUFTO2FBQ1Y7WUFFRCxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsR0FBRyxDQUFDLElBQUksQ0FDTixTQUNFLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxNQUNqQyx3RUFDRSxvQkFBb0IsQ0FBQyxNQUN2QixTQUFTLENBQ1YsQ0FBQztRQUVGLElBQUksbUJBQW1CLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNsQyxNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUNuRCxvQkFBb0IsRUFDcEIsY0FBYyxDQUNmLENBQUM7WUFDRixLQUFLLE1BQU0sT0FBTyxJQUFJLG1CQUFtQixFQUFFO2dCQUN6QyxNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3BELElBQUksSUFBSSxFQUFFO29CQUNSLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztvQkFDbEMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ2xFO2FBQ0Y7U0FDRjtRQUVELE9BQU87WUFDTCxPQUFPLEVBQUUsQ0FDUCxNQUFhLEVBQ2IsTUFBYSxFQUNiLFNBQW9CLEVBQ0YsRUFBRTtnQkFDcEIsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDdkUsT0FBTyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4QyxDQUFDO1lBQ0QsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFlLEVBQW9CLEVBQUUsQ0FDdEQsaUJBQWlCLENBQUMsT0FBTyxDQUFDO1lBQzVCLFdBQVcsRUFBRSxHQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDO1NBQzVELENBQUM7SUFDSixDQUFDO0lBRU0sY0FBYyxDQUNuQixNQUFhLEVBQ2IsTUFBYSxFQUNiLFNBQW9CO1FBRXBCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0NBQ0YifQ=="]},"metadata":{},"sourceType":"module"}