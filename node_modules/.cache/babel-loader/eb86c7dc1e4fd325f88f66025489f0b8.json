{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { MaxUint256 } from '@ethersproject/constants';\nimport { Protocol, Trade } from '@uniswap/router-sdk';\nimport { Pair, Route as V2Route, Trade as V2Trade } from '@uniswap/v2-sdk';\nimport { Pool, Route as V3Route, Trade as V3Trade } from '@uniswap/v3-sdk';\nimport { useCallback, useMemo } from 'react';\nimport { getTxOptimizedSwapRouter, SwapRouterVersion } from 'utils/getTxOptimizedSwapRouter';\nimport { SWAP_ROUTER_ADDRESSES, V2_ROUTER_ADDRESS, V3_ROUTER_ADDRESS } from '../constants/addresses';\nimport { TransactionType } from '../state/transactions/actions';\nimport { useHasPendingApproval, useTransactionAdder } from '../state/transactions/hooks';\nimport { calculateGasMargin } from '../utils/calculateGasMargin';\nimport { useTokenContract } from './useContract';\nimport { useTokenAllowance } from './useTokenAllowance';\nimport { useActiveWeb3React } from './web3';\nexport let ApprovalState;\n\n(function (ApprovalState) {\n  ApprovalState[\"UNKNOWN\"] = \"UNKNOWN\";\n  ApprovalState[\"NOT_APPROVED\"] = \"NOT_APPROVED\";\n  ApprovalState[\"PENDING\"] = \"PENDING\";\n  ApprovalState[\"APPROVED\"] = \"APPROVED\";\n})(ApprovalState || (ApprovalState = {}));\n\nexport function useApprovalState(amountToApprove, spender) {\n  _s();\n\n  var _amountToApprove$curr;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const token = (amountToApprove === null || amountToApprove === void 0 ? void 0 : (_amountToApprove$curr = amountToApprove.currency) === null || _amountToApprove$curr === void 0 ? void 0 : _amountToApprove$curr.isToken) ? amountToApprove.currency : undefined;\n  const currentAllowance = useTokenAllowance(token, account !== null && account !== void 0 ? account : undefined, spender);\n  const pendingApproval = useHasPendingApproval(token === null || token === void 0 ? void 0 : token.address, spender);\n  return useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN;\n    if (amountToApprove.currency.isNative) return ApprovalState.APPROVED; // we might not have enough data to know whether or not we need to approve\n\n    if (!currentAllowance) return ApprovalState.UNKNOWN; // amountToApprove will be defined if currentAllowance is\n\n    return currentAllowance.lessThan(amountToApprove) ? pendingApproval ? ApprovalState.PENDING : ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;\n  }, [amountToApprove, currentAllowance, pendingApproval, spender]);\n}\n/** Returns approval state for all known swap routers */\n\n_s(useApprovalState, \"2cfPUj0GLY67/r7Uwm85Gjul43U=\", false, function () {\n  return [useActiveWeb3React, useTokenAllowance, useHasPendingApproval];\n});\n\nexport function useAllApprovalStates(trade, allowedSlippage) {\n  _s2();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const amountToApprove = useMemo(() => trade && trade.inputAmount.currency.isToken ? trade.maximumAmountIn(allowedSlippage) : undefined, [trade, allowedSlippage]);\n  const v2ApprovalState = useApprovalState(amountToApprove, chainId ? V2_ROUTER_ADDRESS[chainId] : undefined);\n  const v3ApprovalState = useApprovalState(amountToApprove, chainId ? V3_ROUTER_ADDRESS[chainId] : undefined);\n  const v2V3ApprovalState = useApprovalState(amountToApprove, chainId ? SWAP_ROUTER_ADDRESSES[chainId] : undefined);\n  return useMemo(() => ({\n    v2: v2ApprovalState,\n    v3: v3ApprovalState,\n    v2V3: v2V3ApprovalState\n  }), [v2ApprovalState, v2V3ApprovalState, v3ApprovalState]);\n} // returns a variable indicating the state of the approval and a function which approves if necessary or early returns\n\n_s2(useAllApprovalStates, \"65QR4+S0PvBtIO5EthhSgvLfZ0o=\", false, function () {\n  return [useActiveWeb3React, useApprovalState, useApprovalState, useApprovalState];\n});\n\nexport function useApproveCallback(amountToApprove, spender) {\n  _s3();\n\n  var _amountToApprove$curr2;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const token = (amountToApprove === null || amountToApprove === void 0 ? void 0 : (_amountToApprove$curr2 = amountToApprove.currency) === null || _amountToApprove$curr2 === void 0 ? void 0 : _amountToApprove$curr2.isToken) ? amountToApprove.currency : undefined; // check the current approval status\n\n  const approvalState = useApprovalState(amountToApprove, spender);\n  const tokenContract = useTokenContract(token === null || token === void 0 ? void 0 : token.address);\n  const addTransaction = useTransactionAdder();\n  const approve = useCallback(async () => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n\n    if (!chainId) {\n      console.error('no chainId');\n      return;\n    }\n\n    if (!token) {\n      console.error('no token');\n      return;\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null');\n      return;\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve');\n      return;\n    }\n\n    if (!spender) {\n      console.error('no spender');\n      return;\n    }\n\n    let useExact = false;\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true;\n      return tokenContract.estimateGas.approve(spender, amountToApprove.quotient.toString());\n    });\n    return tokenContract.approve(spender, useExact ? amountToApprove.quotient.toString() : MaxUint256, {\n      gasLimit: calculateGasMargin(estimatedGas)\n    }).then(response => {\n      addTransaction(response, {\n        type: TransactionType.APPROVAL,\n        tokenAddress: token.address,\n        spender\n      });\n    }).catch(error => {\n      console.debug('Failed to approve token', error);\n      throw error;\n    });\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction, chainId]);\n  return [approvalState, approve];\n} // wraps useApproveCallback in the context of a swap\n\n_s3(useApproveCallback, \"ooCIFsvi/FYxfcAwq5l8gMNcDhc=\", false, function () {\n  return [useActiveWeb3React, useApprovalState, useTokenContract, useTransactionAdder];\n});\n\nexport function useApproveCallbackFromTrade(trade, allowedSlippage) {\n  _s4();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const amountToApprove = useMemo(() => trade && trade.inputAmount.currency.isToken ? trade.maximumAmountIn(allowedSlippage) : undefined, [trade, allowedSlippage]);\n  const approveCallback = useApproveCallback(amountToApprove, chainId ? trade instanceof V2Trade ? V2_ROUTER_ADDRESS[chainId] : trade instanceof V3Trade ? V3_ROUTER_ADDRESS[chainId] : SWAP_ROUTER_ADDRESSES[chainId] : undefined); // TODO: remove L162-168 after testing is done. This error will help detect mistakes in the logic.\n\n  if (Trade instanceof V2Trade && approveCallback[0] !== ApprovalState.APPROVED || trade instanceof V3Trade && approveCallback[0] !== ApprovalState.APPROVED) {\n    throw new Error('Trying to approve legacy router');\n  }\n\n  return approveCallback;\n}\n\n_s4(useApproveCallbackFromTrade, \"/Pdy9UaTN710XwfguIMqsl0mgDk=\", false, function () {\n  return [useActiveWeb3React, useApproveCallback];\n});\n\nexport function useApprovalOptimizedTrade(trade, allowedSlippage) {\n  _s5();\n\n  var _trade$routes$length;\n\n  const onlyV2Routes = trade === null || trade === void 0 ? void 0 : trade.routes.every(route => route.protocol === Protocol.V2);\n  const onlyV3Routes = trade === null || trade === void 0 ? void 0 : trade.routes.every(route => route.protocol === Protocol.V3);\n  const tradeHasSplits = ((_trade$routes$length = trade === null || trade === void 0 ? void 0 : trade.routes.length) !== null && _trade$routes$length !== void 0 ? _trade$routes$length : 0) > 1;\n  const approvalStates = useAllApprovalStates(trade, allowedSlippage);\n  const optimizedSwapRouter = useMemo(() => getTxOptimizedSwapRouter({\n    onlyV2Routes,\n    onlyV3Routes,\n    tradeHasSplits,\n    approvalStates\n  }), [approvalStates, tradeHasSplits, onlyV2Routes, onlyV3Routes]);\n  return useMemo(() => {\n    if (!trade) return undefined;\n\n    try {\n      switch (optimizedSwapRouter) {\n        case SwapRouterVersion.V2V3:\n          return trade;\n\n        case SwapRouterVersion.V2:\n          const pairs = trade.swaps[0].route.pools.filter(pool => pool instanceof Pair);\n          const v2Route = new V2Route(pairs, trade.inputAmount.currency, trade.outputAmount.currency);\n          return new V2Trade(v2Route, trade.inputAmount, trade.tradeType);\n\n        case SwapRouterVersion.V3:\n          return V3Trade.createUncheckedTradeWithMultipleRoutes({\n            routes: trade.swaps.map(({\n              route,\n              inputAmount,\n              outputAmount\n            }) => ({\n              route: new V3Route(route.pools.filter(p => p instanceof Pool), inputAmount.currency, outputAmount.currency),\n              inputAmount,\n              outputAmount\n            })),\n            tradeType: trade.tradeType\n          });\n\n        default:\n          return undefined;\n      }\n    } catch (e) {\n      // TODO(#2989): remove try-catch\n      console.debug(e);\n      return undefined;\n    }\n  }, [trade, optimizedSwapRouter]);\n}\n\n_s5(useApprovalOptimizedTrade, \"44y9Ba+xcuEWLEObe1yB3D9znPQ=\", false, function () {\n  return [useAllApprovalStates];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useApproveCallback.ts"],"names":["MaxUint256","Protocol","Trade","Pair","Route","V2Route","V2Trade","Pool","V3Route","V3Trade","useCallback","useMemo","getTxOptimizedSwapRouter","SwapRouterVersion","SWAP_ROUTER_ADDRESSES","V2_ROUTER_ADDRESS","V3_ROUTER_ADDRESS","TransactionType","useHasPendingApproval","useTransactionAdder","calculateGasMargin","useTokenContract","useTokenAllowance","useActiveWeb3React","ApprovalState","useApprovalState","amountToApprove","spender","account","token","currency","isToken","undefined","currentAllowance","pendingApproval","address","UNKNOWN","isNative","APPROVED","lessThan","PENDING","NOT_APPROVED","useAllApprovalStates","trade","allowedSlippage","chainId","inputAmount","maximumAmountIn","v2ApprovalState","v3ApprovalState","v2V3ApprovalState","v2","v3","v2V3","useApproveCallback","approvalState","tokenContract","addTransaction","approve","console","error","useExact","estimatedGas","estimateGas","catch","quotient","toString","gasLimit","then","response","type","APPROVAL","tokenAddress","debug","useApproveCallbackFromTrade","approveCallback","Error","useApprovalOptimizedTrade","onlyV2Routes","routes","every","route","protocol","V2","onlyV3Routes","V3","tradeHasSplits","length","approvalStates","optimizedSwapRouter","V2V3","pairs","swaps","pools","filter","pool","v2Route","outputAmount","tradeType","createUncheckedTradeWithMultipleRoutes","map","p","e"],"mappings":"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","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { Protocol, Trade } from '@uniswap/router-sdk'\nimport { Currency, CurrencyAmount, Percent, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2Route, Trade as V2Trade } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3Route, Trade as V3Trade } from '@uniswap/v3-sdk'\nimport { useCallback, useMemo } from 'react'\nimport { getTxOptimizedSwapRouter, SwapRouterVersion } from 'utils/getTxOptimizedSwapRouter'\n\nimport { SWAP_ROUTER_ADDRESSES, V2_ROUTER_ADDRESS, V3_ROUTER_ADDRESS } from '../constants/addresses'\nimport { TransactionType } from '../state/transactions/actions'\nimport { useHasPendingApproval, useTransactionAdder } from '../state/transactions/hooks'\nimport { calculateGasMargin } from '../utils/calculateGasMargin'\nimport { useTokenContract } from './useContract'\nimport { useTokenAllowance } from './useTokenAllowance'\nimport { useActiveWeb3React } from './web3'\n\nexport enum ApprovalState {\n  UNKNOWN = 'UNKNOWN',\n  NOT_APPROVED = 'NOT_APPROVED',\n  PENDING = 'PENDING',\n  APPROVED = 'APPROVED',\n}\n\nexport function useApprovalState(amountToApprove?: CurrencyAmount<Currency>, spender?: string) {\n  const { account } = useActiveWeb3React()\n  const token = amountToApprove?.currency?.isToken ? amountToApprove.currency : undefined\n\n  const currentAllowance = useTokenAllowance(token, account ?? undefined, spender)\n  const pendingApproval = useHasPendingApproval(token?.address, spender)\n\n  return useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN\n    if (amountToApprove.currency.isNative) return ApprovalState.APPROVED\n    // we might not have enough data to know whether or not we need to approve\n    if (!currentAllowance) return ApprovalState.UNKNOWN\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lessThan(amountToApprove)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED\n  }, [amountToApprove, currentAllowance, pendingApproval, spender])\n}\n\n/** Returns approval state for all known swap routers */\nexport function useAllApprovalStates(\n  trade: Trade<Currency, Currency, TradeType> | undefined,\n  allowedSlippage: Percent\n) {\n  const { chainId } = useActiveWeb3React()\n\n  const amountToApprove = useMemo(\n    () => (trade && trade.inputAmount.currency.isToken ? trade.maximumAmountIn(allowedSlippage) : undefined),\n    [trade, allowedSlippage]\n  )\n\n  const v2ApprovalState = useApprovalState(amountToApprove, chainId ? V2_ROUTER_ADDRESS[chainId] : undefined)\n  const v3ApprovalState = useApprovalState(amountToApprove, chainId ? V3_ROUTER_ADDRESS[chainId] : undefined)\n  const v2V3ApprovalState = useApprovalState(amountToApprove, chainId ? SWAP_ROUTER_ADDRESSES[chainId] : undefined)\n\n  return useMemo(\n    () => ({ v2: v2ApprovalState, v3: v3ApprovalState, v2V3: v2V3ApprovalState }),\n    [v2ApprovalState, v2V3ApprovalState, v3ApprovalState]\n  )\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nexport function useApproveCallback(\n  amountToApprove?: CurrencyAmount<Currency>,\n  spender?: string\n): [ApprovalState, () => Promise<void>] {\n  const { chainId } = useActiveWeb3React()\n  const token = amountToApprove?.currency?.isToken ? amountToApprove.currency : undefined\n\n  // check the current approval status\n  const approvalState = useApprovalState(amountToApprove, spender)\n\n  const tokenContract = useTokenContract(token?.address)\n  const addTransaction = useTransactionAdder()\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily')\n      return\n    }\n    if (!chainId) {\n      console.error('no chainId')\n      return\n    }\n\n    if (!token) {\n      console.error('no token')\n      return\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null')\n      return\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve')\n      return\n    }\n\n    if (!spender) {\n      console.error('no spender')\n      return\n    }\n\n    let useExact = false\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true\n      return tokenContract.estimateGas.approve(spender, amountToApprove.quotient.toString())\n    })\n\n    return tokenContract\n      .approve(spender, useExact ? amountToApprove.quotient.toString() : MaxUint256, {\n        gasLimit: calculateGasMargin(estimatedGas),\n      })\n      .then((response: TransactionResponse) => {\n        addTransaction(response, { type: TransactionType.APPROVAL, tokenAddress: token.address, spender })\n      })\n      .catch((error: Error) => {\n        console.debug('Failed to approve token', error)\n        throw error\n      })\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction, chainId])\n\n  return [approvalState, approve]\n}\n\n// wraps useApproveCallback in the context of a swap\nexport function useApproveCallbackFromTrade(\n  trade:\n    | V2Trade<Currency, Currency, TradeType>\n    | V3Trade<Currency, Currency, TradeType>\n    | Trade<Currency, Currency, TradeType>\n    | undefined,\n  allowedSlippage: Percent\n) {\n  const { chainId } = useActiveWeb3React()\n  const amountToApprove = useMemo(\n    () => (trade && trade.inputAmount.currency.isToken ? trade.maximumAmountIn(allowedSlippage) : undefined),\n    [trade, allowedSlippage]\n  )\n\n  const approveCallback = useApproveCallback(\n    amountToApprove,\n    chainId\n      ? trade instanceof V2Trade\n        ? V2_ROUTER_ADDRESS[chainId]\n        : trade instanceof V3Trade\n        ? V3_ROUTER_ADDRESS[chainId]\n        : SWAP_ROUTER_ADDRESSES[chainId]\n      : undefined\n  )\n\n  // TODO: remove L162-168 after testing is done. This error will help detect mistakes in the logic.\n  if (\n    (Trade instanceof V2Trade && approveCallback[0] !== ApprovalState.APPROVED) ||\n    (trade instanceof V3Trade && approveCallback[0] !== ApprovalState.APPROVED)\n  ) {\n    throw new Error('Trying to approve legacy router')\n  }\n\n  return approveCallback\n}\n\nexport function useApprovalOptimizedTrade(\n  trade: Trade<Currency, Currency, TradeType> | undefined,\n  allowedSlippage: Percent\n):\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | Trade<Currency, Currency, TradeType>\n  | undefined {\n  const onlyV2Routes = trade?.routes.every((route) => route.protocol === Protocol.V2)\n  const onlyV3Routes = trade?.routes.every((route) => route.protocol === Protocol.V3)\n  const tradeHasSplits = (trade?.routes.length ?? 0) > 1\n\n  const approvalStates = useAllApprovalStates(trade, allowedSlippage)\n\n  const optimizedSwapRouter = useMemo(\n    () => getTxOptimizedSwapRouter({ onlyV2Routes, onlyV3Routes, tradeHasSplits, approvalStates }),\n    [approvalStates, tradeHasSplits, onlyV2Routes, onlyV3Routes]\n  )\n\n  return useMemo(() => {\n    if (!trade) return undefined\n\n    try {\n      switch (optimizedSwapRouter) {\n        case SwapRouterVersion.V2V3:\n          return trade\n        case SwapRouterVersion.V2:\n          const pairs = trade.swaps[0].route.pools.filter((pool) => pool instanceof Pair) as Pair[]\n          const v2Route = new V2Route(pairs, trade.inputAmount.currency, trade.outputAmount.currency)\n          return new V2Trade(v2Route, trade.inputAmount, trade.tradeType)\n        case SwapRouterVersion.V3:\n          return V3Trade.createUncheckedTradeWithMultipleRoutes({\n            routes: trade.swaps.map(({ route, inputAmount, outputAmount }) => ({\n              route: new V3Route(\n                route.pools.filter((p) => p instanceof Pool) as Pool[],\n                inputAmount.currency,\n                outputAmount.currency\n              ),\n              inputAmount,\n              outputAmount,\n            })),\n            tradeType: trade.tradeType,\n          })\n        default:\n          return undefined\n      }\n    } catch (e) {\n      // TODO(#2989): remove try-catch\n      console.debug(e)\n      return undefined\n    }\n  }, [trade, optimizedSwapRouter])\n}\n"]},"metadata":{},"sourceType":"module"}