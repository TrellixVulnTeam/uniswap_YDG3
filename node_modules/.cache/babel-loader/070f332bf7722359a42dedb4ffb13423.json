{"ast":null,"code":"import { getAddress } from '@ethersproject/address';\nimport { AddressZero } from '@ethersproject/constants';\nimport { Contract } from '@ethersproject/contracts';\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value) {\n  try {\n    return getAddress(value);\n  } catch {\n    return false;\n  }\n} // shorten the checksummed version of the input address to have 0x + 4 characters at start and end\n\nexport function shortenAddress(address, chars = 4) {\n  const parsed = isAddress(address);\n\n  if (!parsed) {\n    throw Error(`Invalid 'address' parameter '${address}'.`);\n  }\n\n  return `${parsed.substring(0, chars + 2)}...${parsed.substring(42 - chars)}`;\n} // account is not optional\n\nfunction getSigner(library, account) {\n  return library.getSigner(account).connectUnchecked();\n} // account is optional\n\n\nfunction getProviderOrSigner(library, account) {\n  return account ? getSigner(library, account) : library;\n} // account is optional\n\n\nexport function getContract(address, ABI, library, account) {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`);\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account));\n}\nexport function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\nexport function isTokenOnList(tokenAddressMap, token) {\n  var _tokenAddressMap$toke;\n\n  return Boolean((token === null || token === void 0 ? void 0 : token.isToken) && ((_tokenAddressMap$toke = tokenAddressMap[token.chainId]) === null || _tokenAddressMap$toke === void 0 ? void 0 : _tokenAddressMap$toke[token.address]));\n}\nexport function formattedFeeAmount(feeAmount) {\n  return feeAmount / 10000;\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/utils/index.ts"],"names":["getAddress","AddressZero","Contract","isAddress","value","shortenAddress","address","chars","parsed","Error","substring","getSigner","library","account","connectUnchecked","getProviderOrSigner","getContract","ABI","escapeRegExp","string","replace","isTokenOnList","tokenAddressMap","token","Boolean","isToken","chainId","formattedFeeAmount","feeAmount"],"mappings":"AAAA,SAASA,UAAT,QAA2B,wBAA3B;AACA,SAASC,WAAT,QAA4B,0BAA5B;AACA,SAASC,QAAT,QAAyB,0BAAzB;AAOA;AACA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA+C;AACpD,MAAI;AACF,WAAOJ,UAAU,CAACI,KAAD,CAAjB;AACD,GAFD,CAEE,MAAM;AACN,WAAO,KAAP;AACD;AACF,C,CAED;;AACA,OAAO,SAASC,cAAT,CAAwBC,OAAxB,EAAyCC,KAAK,GAAG,CAAjD,EAA4D;AACjE,QAAMC,MAAM,GAAGL,SAAS,CAACG,OAAD,CAAxB;;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAMC,KAAK,CAAE,gCAA+BH,OAAQ,IAAzC,CAAX;AACD;;AACD,SAAQ,GAAEE,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBH,KAAK,GAAG,CAA5B,CAA+B,MAAKC,MAAM,CAACE,SAAP,CAAiB,KAAKH,KAAtB,CAA6B,EAA3E;AACD,C,CAED;;AACA,SAASI,SAAT,CAAmBC,OAAnB,EAA0CC,OAA1C,EAA0E;AACxE,SAAOD,OAAO,CAACD,SAAR,CAAkBE,OAAlB,EAA2BC,gBAA3B,EAAP;AACD,C,CAED;;;AACA,SAASC,mBAAT,CAA6BH,OAA7B,EAAoDC,OAApD,EAAoG;AAClG,SAAOA,OAAO,GAAGF,SAAS,CAACC,OAAD,EAAUC,OAAV,CAAZ,GAAiCD,OAA/C;AACD,C,CAED;;;AACA,OAAO,SAASI,WAAT,CAAqBV,OAArB,EAAsCW,GAAtC,EAAgDL,OAAhD,EAAuEC,OAAvE,EAAmG;AACxG,MAAI,CAACV,SAAS,CAACG,OAAD,CAAV,IAAuBA,OAAO,KAAKL,WAAvC,EAAoD;AAClD,UAAMQ,KAAK,CAAE,gCAA+BH,OAAQ,IAAzC,CAAX;AACD;;AAED,SAAO,IAAIJ,QAAJ,CAAaI,OAAb,EAAsBW,GAAtB,EAA2BF,mBAAmB,CAACH,OAAD,EAAUC,OAAV,CAA9C,CAAP;AACD;AAED,OAAO,SAASK,YAAT,CAAsBC,MAAtB,EAA8C;AACnD,SAAOA,MAAM,CAACC,OAAP,CAAe,qBAAf,EAAsC,MAAtC,CAAP,CADmD,CACE;AACtD;AAED,OAAO,SAASC,aAAT,CAAuBC,eAAvB,EAAyDC,KAAzD,EAAiF;AAAA;;AACtF,SAAOC,OAAO,CAAC,CAAAD,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEE,OAAP,+BAAkBH,eAAe,CAACC,KAAK,CAACG,OAAP,CAAjC,0DAAkB,sBAAiCH,KAAK,CAACjB,OAAvC,CAAlB,CAAD,CAAd;AACD;AAED,OAAO,SAASqB,kBAAT,CAA4BC,SAA5B,EAA0D;AAC/D,SAAOA,SAAS,GAAG,KAAnB;AACD","sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { AddressZero } from '@ethersproject/constants'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcSigner, Web3Provider } from '@ethersproject/providers'\nimport { Token } from '@uniswap/sdk-core'\nimport { FeeAmount } from '@uniswap/v3-sdk'\n\nimport { TokenAddressMap } from '../state/lists/hooks'\n\n// returns the checksummed address if the address is valid, otherwise returns false\nexport function isAddress(value: any): string | false {\n  try {\n    return getAddress(value)\n  } catch {\n    return false\n  }\n}\n\n// shorten the checksummed version of the input address to have 0x + 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  const parsed = isAddress(address)\n  if (!parsed) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n  return `${parsed.substring(0, chars + 2)}...${parsed.substring(42 - chars)}`\n}\n\n// account is not optional\nfunction getSigner(library: Web3Provider, account: string): JsonRpcSigner {\n  return library.getSigner(account).connectUnchecked()\n}\n\n// account is optional\nfunction getProviderOrSigner(library: Web3Provider, account?: string): Web3Provider | JsonRpcSigner {\n  return account ? getSigner(library, account) : library\n}\n\n// account is optional\nexport function getContract(address: string, ABI: any, library: Web3Provider, account?: string): Contract {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`)\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account) as any)\n}\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\n\nexport function isTokenOnList(tokenAddressMap: TokenAddressMap, token?: Token): boolean {\n  return Boolean(token?.isToken && tokenAddressMap[token.chainId]?.[token.address])\n}\n\nexport function formattedFeeAmount(feeAmount: FeeAmount): number {\n  return feeAmount / 10000\n}\n"]},"metadata":{},"sourceType":"module"}