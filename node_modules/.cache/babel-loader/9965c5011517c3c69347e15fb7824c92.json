{"ast":null,"code":"/**\n * Mnemonist Bitwise Helpers\n * ==========================\n *\n * Miscellaneous helpers helping with bitwise operations.\n */\n\n/**\n * Takes a 32 bits integer and returns its MSB using SWAR strategy.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\nfunction msb32(x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x & ~(x >> 1);\n}\n\nexports.msb32 = msb32;\n/**\n * Takes a byte and returns its MSB using SWAR strategy.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\n\nfunction msb8(x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  return x & ~(x >> 1);\n}\n\nexports.msb8 = msb8;\n/**\n * Takes a number and return bit at position.\n *\n * @param  {number} x   - Target number.\n * @param  {number} pos - Position.\n * @return {number}\n */\n\nexports.test = function (x, pos) {\n  return x >> pos & 1;\n};\n/**\n * Compare two bytes and return their critical bit.\n *\n * @param  {number} a - First byte.\n * @param  {number} b - Second byte.\n * @return {number}\n */\n\n\nexports.criticalBit8 = function (a, b) {\n  return msb8(a ^ b);\n};\n\nexports.criticalBit8Mask = function (a, b) {\n  return ~msb8(a ^ b) >>> 0 & 0xff;\n};\n\nexports.testCriticalBit8 = function (x, mask) {\n  return 1 + (x | mask) >> 8;\n};\n\nexports.criticalBit32Mask = function (a, b) {\n  return ~msb32(a ^ b) >>> 0 & 0xffffffff;\n};\n/**\n * Takes a 32 bits integer and returns its population count (number of 1 of\n * the binary representation).\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\n\n\nexports.popcount = function (x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n};\n/**\n * Slightly faster popcount function based on a precomputed table of 8bits\n * words.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\n\n\nvar TABLE8 = new Uint8Array(Math.pow(2, 8));\n\nfor (var i = 0, l = TABLE8.length; i < l; i++) {\n  TABLE8[i] = exports.popcount(i);\n}\n\nexports.table8Popcount = function (x) {\n  return TABLE8[x & 0xff] + TABLE8[x >> 8 & 0xff] + TABLE8[x >> 16 & 0xff] + TABLE8[x >> 24 & 0xff];\n};","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/utils/bitwise.js"],"names":["msb32","x","exports","msb8","test","pos","criticalBit8","a","b","criticalBit8Mask","testCriticalBit8","mask","criticalBit32Mask","popcount","TABLE8","Uint8Array","Math","pow","i","l","length","table8Popcount"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Bitwise Helpers\n * ==========================\n *\n * Miscellaneous helpers helping with bitwise operations.\n */\n\n/**\n * Takes a 32 bits integer and returns its MSB using SWAR strategy.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\nfunction msb32(x) {\n  x |= (x >> 1);\n  x |= (x >> 2);\n  x |= (x >> 4);\n  x |= (x >> 8);\n  x |= (x >> 16);\n\n  return (x & ~(x >> 1));\n}\nexports.msb32 = msb32;\n\n/**\n * Takes a byte and returns its MSB using SWAR strategy.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\nfunction msb8(x) {\n  x |= (x >> 1);\n  x |= (x >> 2);\n  x |= (x >> 4);\n\n  return (x & ~(x >> 1));\n}\nexports.msb8 = msb8;\n\n/**\n * Takes a number and return bit at position.\n *\n * @param  {number} x   - Target number.\n * @param  {number} pos - Position.\n * @return {number}\n */\nexports.test = function(x, pos) {\n  return (x >> pos) & 1;\n};\n\n/**\n * Compare two bytes and return their critical bit.\n *\n * @param  {number} a - First byte.\n * @param  {number} b - Second byte.\n * @return {number}\n */\nexports.criticalBit8 = function(a, b) {\n  return msb8(a ^ b);\n};\n\nexports.criticalBit8Mask = function(a, b) {\n  return (~msb8(a ^ b) >>> 0) & 0xff;\n};\n\nexports.testCriticalBit8 = function(x, mask) {\n  return (1 + (x | mask)) >> 8;\n};\n\nexports.criticalBit32Mask = function(a, b) {\n  return (~msb32(a ^ b) >>> 0) & 0xffffffff;\n};\n\n/**\n * Takes a 32 bits integer and returns its population count (number of 1 of\n * the binary representation).\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\nexports.popcount = function(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n};\n\n/**\n * Slightly faster popcount function based on a precomputed table of 8bits\n * words.\n *\n * @param  {number} x - Target number.\n * @return {number}\n */\nvar TABLE8 = new Uint8Array(Math.pow(2, 8));\n\nfor (var i = 0, l = TABLE8.length; i < l; i++)\n  TABLE8[i] = exports.popcount(i);\n\nexports.table8Popcount = function(x) {\n  return (\n    TABLE8[x & 0xff] +\n    TABLE8[(x >> 8) & 0xff] +\n    TABLE8[(x >> 16) & 0xff] +\n    TABLE8[(x >> 24) & 0xff]\n  );\n};\n"]},"metadata":{},"sourceType":"script"}