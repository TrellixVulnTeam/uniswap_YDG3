{"ast":null,"code":"/*\n * Mnemonist StaticIntervalTree\n * =============================\n *\n * JavaScript implementation of a static interval tree. This tree is static in\n * that you are required to know all its items beforehand and to built it\n * from an iterable.\n *\n * This implementation represents the interval tree as an augmented balanced\n * binary search tree. It works by sorting the intervals by startpoint first\n * then proceeds building the augmented balanced BST bottom-up from the\n * sorted list.\n *\n * Note that this implementation considers every given intervals as closed for\n * simplicity's sake.\n *\n * For more information: https://en.wikipedia.org/wiki/Interval_tree\n */\nvar iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js');\n\nvar FixedStack = require('./fixed-stack.js'); // TODO: pass index to getters\n// TODO: custom comparison\n// TODO: possibility to pass offset buffer\n// TODO: intervals() => Symbol.iterator\n// TODO: dfs()\n\n/**\n * Helpers.\n */\n\n/**\n * Recursive function building the BST from the sorted list of interval\n * indices.\n *\n * @param  {array}    intervals     - Array of intervals to index.\n * @param  {function} endGetter     - Getter function for end of intervals.\n * @param  {array}    sortedIndices - Sorted indices of the intervals.\n * @param  {array}    tree          - BST memory.\n * @param  {array}    augmentations - Array of node augmentations.\n * @param  {number}   i             - BST index of current node.\n * @param  {number}   low           - Dichotomy low index.\n * @param  {number}   high          - Dichotomy high index.\n * @return {number}                 - Created node augmentation value.\n */\n\n\nfunction buildBST(intervals, endGetter, sortedIndices, tree, augmentations, i, low, high) {\n  var mid = low + (high - low) / 2 | 0,\n      midMinusOne = ~-mid,\n      midPlusOne = -~mid;\n  var current = sortedIndices[mid];\n  tree[i] = current + 1;\n  var end = endGetter ? endGetter(intervals[current]) : intervals[current][1];\n  var left = i * 2 + 1,\n      right = i * 2 + 2;\n  var leftEnd = -Infinity,\n      rightEnd = -Infinity;\n\n  if (low <= midMinusOne) {\n    leftEnd = buildBST(intervals, endGetter, sortedIndices, tree, augmentations, left, low, midMinusOne);\n  }\n\n  if (midPlusOne <= high) {\n    rightEnd = buildBST(intervals, endGetter, sortedIndices, tree, augmentations, right, midPlusOne, high);\n  }\n\n  var augmentation = Math.max(end, leftEnd, rightEnd);\n  var augmentationPointer = current;\n  if (augmentation === leftEnd) augmentationPointer = augmentations[tree[left] - 1];else if (augmentation === rightEnd) augmentationPointer = augmentations[tree[right] - 1];\n  augmentations[current] = augmentationPointer;\n  return augmentation;\n}\n/**\n * StaticIntervalTree.\n *\n * @constructor\n * @param {array}           intervals - Array of intervals to index.\n * @param {array<function>} getters   - Optional getters.\n */\n\n\nfunction StaticIntervalTree(intervals, getters) {\n  // Properties\n  this.size = intervals.length;\n  this.intervals = intervals;\n  var startGetter = null,\n      endGetter = null;\n\n  if (Array.isArray(getters)) {\n    startGetter = getters[0];\n    endGetter = getters[1];\n  } // Building the indices array\n\n\n  var length = intervals.length;\n  var IndicesArray = typed.getPointerArray(length + 1);\n  var indices = new IndicesArray(length);\n  var i;\n\n  for (i = 1; i < length; i++) indices[i] = i; // Sorting indices array\n  // TODO: check if some version of radix sort can outperform this part\n\n\n  indices.sort(function (a, b) {\n    a = intervals[a];\n    b = intervals[b];\n\n    if (startGetter) {\n      a = startGetter(a);\n      b = startGetter(b);\n    } else {\n      a = a[0];\n      b = b[0];\n    }\n\n    if (a < b) return -1;\n    if (a > b) return 1; // TODO: use getters\n    // TODO: this ordering has the following invariant: if query interval\n    // contains [nodeStart, max], then whole right subtree can be collected\n    // a = a[1];\n    // b = b[1];\n    // if (a < b)\n    //   return 1;\n    // if (a > b)\n    //   return -1;\n\n    return 0;\n  }); // Building the binary tree\n\n  var height = Math.ceil(Math.log2(length + 1)),\n      treeSize = Math.pow(2, height) - 1;\n  var tree = new IndicesArray(treeSize);\n  var augmentations = new IndicesArray(length);\n  buildBST(intervals, endGetter, indices, tree, augmentations, 0, 0, length - 1); // Dropping indices\n\n  indices = null; // Storing necessary information\n\n  this.height = height;\n  this.tree = tree;\n  this.augmentations = augmentations;\n  this.startGetter = startGetter;\n  this.endGetter = endGetter; // Initializing DFS stack\n\n  this.stack = new FixedStack(IndicesArray, this.height);\n}\n/**\n * Method returning a list of intervals containing the given point.\n *\n * @param  {any}   point - Target point.\n * @return {array}\n */\n\n\nStaticIntervalTree.prototype.intervalsContainingPoint = function (point) {\n  var matches = [];\n  var stack = this.stack;\n  stack.clear();\n  stack.push(0);\n  var l = this.tree.length;\n  var bstIndex, intervalIndex, interval, maxInterval, start, end, max, left, right;\n\n  while (stack.size) {\n    bstIndex = stack.pop();\n    intervalIndex = this.tree[bstIndex] - 1;\n    interval = this.intervals[intervalIndex];\n    maxInterval = this.intervals[this.augmentations[intervalIndex]];\n    max = this.endGetter ? this.endGetter(maxInterval) : maxInterval[1]; // No possible match, point is farther right than the max end value\n\n    if (point > max) continue; // Searching left\n\n    left = bstIndex * 2 + 1;\n    if (left < l && this.tree[left] !== 0) stack.push(left);\n    start = this.startGetter ? this.startGetter(interval) : interval[0];\n    end = this.endGetter ? this.endGetter(interval) : interval[1]; // Checking current node\n\n    if (point >= start && point <= end) matches.push(interval); // If the point is to the left of the start of the current interval,\n    // then it cannot be in the right child\n\n    if (point < start) continue; // Searching right\n\n    right = bstIndex * 2 + 2;\n    if (right < l && this.tree[right] !== 0) stack.push(right);\n  }\n\n  return matches;\n};\n/**\n * Method returning a list of intervals overlapping the given interval.\n *\n * @param  {any}   interval - Target interval.\n * @return {array}\n */\n\n\nStaticIntervalTree.prototype.intervalsOverlappingInterval = function (interval) {\n  var intervalStart = this.startGetter ? this.startGetter(interval) : interval[0],\n      intervalEnd = this.endGetter ? this.endGetter(interval) : interval[1];\n  var matches = [];\n  var stack = this.stack;\n  stack.clear();\n  stack.push(0);\n  var l = this.tree.length;\n  var bstIndex, intervalIndex, currentInterval, maxInterval, start, end, max, left, right;\n\n  while (stack.size) {\n    bstIndex = stack.pop();\n    intervalIndex = this.tree[bstIndex] - 1;\n    currentInterval = this.intervals[intervalIndex];\n    maxInterval = this.intervals[this.augmentations[intervalIndex]];\n    max = this.endGetter ? this.endGetter(maxInterval) : maxInterval[1]; // No possible match, start is farther right than the max end value\n\n    if (intervalStart > max) continue; // Searching left\n\n    left = bstIndex * 2 + 1;\n    if (left < l && this.tree[left] !== 0) stack.push(left);\n    start = this.startGetter ? this.startGetter(currentInterval) : currentInterval[0];\n    end = this.endGetter ? this.endGetter(currentInterval) : currentInterval[1]; // Checking current node\n\n    if (intervalEnd >= start && intervalStart <= end) matches.push(currentInterval); // If the end is to the left of the start of the current interval,\n    // then it cannot be in the right child\n\n    if (intervalEnd < start) continue; // Searching right\n\n    right = bstIndex * 2 + 2;\n    if (right < l && this.tree[right] !== 0) stack.push(right);\n  }\n\n  return matches;\n};\n/**\n * Convenience known methods.\n */\n\n\nStaticIntervalTree.prototype.inspect = function () {\n  var proxy = this.intervals.slice(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: StaticIntervalTree,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') StaticIntervalTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = StaticIntervalTree.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {StaticIntervalTree}\n */\n\nStaticIntervalTree.from = function (iterable, getters) {\n  if (iterables.isArrayLike(iterable)) return new StaticIntervalTree(iterable, getters);\n  return new StaticIntervalTree(Array.from(iterable), getters);\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = StaticIntervalTree;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/static-interval-tree.js"],"names":["iterables","require","typed","FixedStack","buildBST","intervals","endGetter","sortedIndices","tree","augmentations","i","low","high","mid","midMinusOne","midPlusOne","current","end","left","right","leftEnd","Infinity","rightEnd","augmentation","Math","max","augmentationPointer","StaticIntervalTree","getters","size","length","startGetter","Array","isArray","IndicesArray","getPointerArray","indices","sort","a","b","height","ceil","log2","treeSize","pow","stack","prototype","intervalsContainingPoint","point","matches","clear","push","l","bstIndex","intervalIndex","interval","maxInterval","start","pop","intervalsOverlappingInterval","intervalStart","intervalEnd","currentInterval","inspect","proxy","slice","Object","defineProperty","value","enumerable","Symbol","for","from","iterable","isArrayLike","module","exports"],"mappings":"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","sourcesContent":["/*\n * Mnemonist StaticIntervalTree\n * =============================\n *\n * JavaScript implementation of a static interval tree. This tree is static in\n * that you are required to know all its items beforehand and to built it\n * from an iterable.\n *\n * This implementation represents the interval tree as an augmented balanced\n * binary search tree. It works by sorting the intervals by startpoint first\n * then proceeds building the augmented balanced BST bottom-up from the\n * sorted list.\n *\n * Note that this implementation considers every given intervals as closed for\n * simplicity's sake.\n *\n * For more information: https://en.wikipedia.org/wiki/Interval_tree\n */\nvar iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js');\n\nvar FixedStack = require('./fixed-stack.js');\n\n\n// TODO: pass index to getters\n// TODO: custom comparison\n// TODO: possibility to pass offset buffer\n\n// TODO: intervals() => Symbol.iterator\n// TODO: dfs()\n\n/**\n * Helpers.\n */\n\n/**\n * Recursive function building the BST from the sorted list of interval\n * indices.\n *\n * @param  {array}    intervals     - Array of intervals to index.\n * @param  {function} endGetter     - Getter function for end of intervals.\n * @param  {array}    sortedIndices - Sorted indices of the intervals.\n * @param  {array}    tree          - BST memory.\n * @param  {array}    augmentations - Array of node augmentations.\n * @param  {number}   i             - BST index of current node.\n * @param  {number}   low           - Dichotomy low index.\n * @param  {number}   high          - Dichotomy high index.\n * @return {number}                 - Created node augmentation value.\n */\nfunction buildBST(\n  intervals,\n  endGetter,\n  sortedIndices,\n  tree,\n  augmentations,\n  i,\n  low,\n  high\n) {\n  var mid = (low + (high - low) / 2) | 0,\n      midMinusOne = ~-mid,\n      midPlusOne = -~mid;\n\n  var current = sortedIndices[mid];\n  tree[i] = current + 1;\n\n  var end = endGetter ? endGetter(intervals[current]) : intervals[current][1];\n\n  var left = i * 2 + 1,\n      right = i * 2 + 2;\n\n  var leftEnd = -Infinity,\n      rightEnd = -Infinity;\n\n  if (low <= midMinusOne) {\n    leftEnd = buildBST(\n      intervals,\n      endGetter,\n      sortedIndices,\n      tree,\n      augmentations,\n      left,\n      low,\n      midMinusOne\n    );\n  }\n\n  if (midPlusOne <= high) {\n    rightEnd = buildBST(\n      intervals,\n      endGetter,\n      sortedIndices,\n      tree,\n      augmentations,\n      right,\n      midPlusOne,\n      high\n    );\n  }\n\n  var augmentation = Math.max(end, leftEnd, rightEnd);\n\n  var augmentationPointer = current;\n\n  if (augmentation === leftEnd)\n    augmentationPointer = augmentations[tree[left] - 1];\n  else if (augmentation === rightEnd)\n    augmentationPointer = augmentations[tree[right] - 1];\n\n  augmentations[current] = augmentationPointer;\n\n  return augmentation;\n}\n\n/**\n * StaticIntervalTree.\n *\n * @constructor\n * @param {array}           intervals - Array of intervals to index.\n * @param {array<function>} getters   - Optional getters.\n */\nfunction StaticIntervalTree(intervals, getters) {\n\n  // Properties\n  this.size = intervals.length;\n  this.intervals = intervals;\n\n  var startGetter = null,\n      endGetter = null;\n\n  if (Array.isArray(getters)) {\n    startGetter = getters[0];\n    endGetter = getters[1];\n  }\n\n  // Building the indices array\n  var length = intervals.length;\n\n  var IndicesArray = typed.getPointerArray(length + 1);\n\n  var indices = new IndicesArray(length);\n\n  var i;\n\n  for (i = 1; i < length; i++)\n    indices[i] = i;\n\n  // Sorting indices array\n  // TODO: check if some version of radix sort can outperform this part\n  indices.sort(function(a, b) {\n    a = intervals[a];\n    b = intervals[b];\n\n    if (startGetter) {\n      a = startGetter(a);\n      b = startGetter(b);\n    }\n    else {\n      a = a[0];\n      b = b[0];\n    }\n\n    if (a < b)\n      return -1;\n\n    if (a > b)\n      return 1;\n\n    // TODO: use getters\n    // TODO: this ordering has the following invariant: if query interval\n    // contains [nodeStart, max], then whole right subtree can be collected\n    // a = a[1];\n    // b = b[1];\n\n    // if (a < b)\n    //   return 1;\n\n    // if (a > b)\n    //   return -1;\n\n    return 0;\n  });\n\n  // Building the binary tree\n  var height = Math.ceil(Math.log2(length + 1)),\n      treeSize = Math.pow(2, height) - 1;\n\n  var tree = new IndicesArray(treeSize);\n\n  var augmentations = new IndicesArray(length);\n\n  buildBST(\n    intervals,\n    endGetter,\n    indices,\n    tree,\n    augmentations,\n    0,\n    0,\n    length - 1\n  );\n\n  // Dropping indices\n  indices = null;\n\n  // Storing necessary information\n  this.height = height;\n  this.tree = tree;\n  this.augmentations = augmentations;\n  this.startGetter = startGetter;\n  this.endGetter = endGetter;\n\n  // Initializing DFS stack\n  this.stack = new FixedStack(IndicesArray, this.height);\n}\n\n/**\n * Method returning a list of intervals containing the given point.\n *\n * @param  {any}   point - Target point.\n * @return {array}\n */\nStaticIntervalTree.prototype.intervalsContainingPoint = function(point) {\n  var matches = [];\n\n  var stack = this.stack;\n\n  stack.clear();\n  stack.push(0);\n\n  var l = this.tree.length;\n\n  var bstIndex,\n      intervalIndex,\n      interval,\n      maxInterval,\n      start,\n      end,\n      max,\n      left,\n      right;\n\n  while (stack.size) {\n    bstIndex = stack.pop();\n    intervalIndex = this.tree[bstIndex] - 1;\n    interval = this.intervals[intervalIndex];\n    maxInterval = this.intervals[this.augmentations[intervalIndex]];\n\n    max = this.endGetter ? this.endGetter(maxInterval) : maxInterval[1];\n\n    // No possible match, point is farther right than the max end value\n    if (point > max)\n      continue;\n\n    // Searching left\n    left = bstIndex * 2 + 1;\n\n    if (left < l && this.tree[left] !== 0)\n      stack.push(left);\n\n    start = this.startGetter ? this.startGetter(interval) : interval[0];\n    end = this.endGetter ? this.endGetter(interval) : interval[1];\n\n    // Checking current node\n    if (point >= start && point <= end)\n      matches.push(interval);\n\n    // If the point is to the left of the start of the current interval,\n    // then it cannot be in the right child\n    if (point < start)\n      continue;\n\n    // Searching right\n    right = bstIndex * 2 + 2;\n\n    if (right < l && this.tree[right] !== 0)\n      stack.push(right);\n  }\n\n  return matches;\n};\n\n/**\n * Method returning a list of intervals overlapping the given interval.\n *\n * @param  {any}   interval - Target interval.\n * @return {array}\n */\nStaticIntervalTree.prototype.intervalsOverlappingInterval = function(interval) {\n  var intervalStart = this.startGetter ? this.startGetter(interval) : interval[0],\n      intervalEnd = this.endGetter ? this.endGetter(interval) : interval[1];\n\n  var matches = [];\n\n  var stack = this.stack;\n\n  stack.clear();\n  stack.push(0);\n\n  var l = this.tree.length;\n\n  var bstIndex,\n      intervalIndex,\n      currentInterval,\n      maxInterval,\n      start,\n      end,\n      max,\n      left,\n      right;\n\n  while (stack.size) {\n    bstIndex = stack.pop();\n    intervalIndex = this.tree[bstIndex] - 1;\n    currentInterval = this.intervals[intervalIndex];\n    maxInterval = this.intervals[this.augmentations[intervalIndex]];\n\n    max = this.endGetter ? this.endGetter(maxInterval) : maxInterval[1];\n\n    // No possible match, start is farther right than the max end value\n    if (intervalStart > max)\n      continue;\n\n    // Searching left\n    left = bstIndex * 2 + 1;\n\n    if (left < l && this.tree[left] !== 0)\n      stack.push(left);\n\n    start = this.startGetter ? this.startGetter(currentInterval) : currentInterval[0];\n    end = this.endGetter ? this.endGetter(currentInterval) : currentInterval[1];\n\n    // Checking current node\n    if (intervalEnd >= start && intervalStart <= end)\n      matches.push(currentInterval);\n\n    // If the end is to the left of the start of the current interval,\n    // then it cannot be in the right child\n    if (intervalEnd < start)\n      continue;\n\n    // Searching right\n    right = bstIndex * 2 + 2;\n\n    if (right < l && this.tree[right] !== 0)\n      stack.push(right);\n  }\n\n  return matches;\n};\n\n/**\n * Convenience known methods.\n */\nStaticIntervalTree.prototype.inspect = function() {\n  var proxy = this.intervals.slice();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: StaticIntervalTree,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  StaticIntervalTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = StaticIntervalTree.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {StaticIntervalTree}\n */\nStaticIntervalTree.from = function(iterable, getters) {\n  if (iterables.isArrayLike(iterable))\n    return new StaticIntervalTree(iterable, getters);\n\n  return new StaticIntervalTree(Array.from(iterable), getters);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = StaticIntervalTree;\n"]},"metadata":{},"sourceType":"script"}