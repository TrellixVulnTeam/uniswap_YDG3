{"ast":null,"code":"/**\n * Mnemonist Vector\n * =================\n *\n * Abstract implementation of a growing array that can be used with JavaScript\n * typed arrays and other array-like structures.\n *\n * Note: should try and use ArrayBuffer.transfer when it will be available.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js');\n/**\n * Defaults.\n */\n\n\nvar DEFAULT_GROWING_POLICY = function DEFAULT_GROWING_POLICY(currentCapacity) {\n  return Math.max(1, Math.ceil(currentCapacity * 1.5));\n};\n\nvar pointerArrayFactory = function pointerArrayFactory(capacity) {\n  var PointerArray = typed.getPointerArray(capacity);\n  return new PointerArray(capacity);\n};\n/**\n * Vector.\n *\n * @constructor\n * @param {function}      ArrayClass             - An array constructor.\n * @param {number|object} initialCapacityOrOptions - Self-explanatory:\n * @param {number}        initialCapacity          - Initial capacity.\n * @param {number}        initialLength            - Initial length.\n * @param {function}      policy                   - Allocation policy.\n */\n\n\nfunction Vector(ArrayClass, initialCapacityOrOptions) {\n  if (arguments.length < 1) throw new Error('mnemonist/vector: expecting at least a byte array constructor.');\n  var initialCapacity = initialCapacityOrOptions || 0,\n      policy = DEFAULT_GROWING_POLICY,\n      initialLength = 0,\n      factory = false;\n\n  if (typeof initialCapacityOrOptions === 'object') {\n    initialCapacity = initialCapacityOrOptions.initialCapacity || 0;\n    initialLength = initialCapacityOrOptions.initialLength || 0;\n    policy = initialCapacityOrOptions.policy || policy;\n    factory = initialCapacityOrOptions.factory === true;\n  }\n\n  this.factory = factory ? ArrayClass : null;\n  this.ArrayClass = ArrayClass;\n  this.length = initialLength;\n  this.capacity = Math.max(initialLength, initialCapacity);\n  this.policy = policy;\n  this.array = new ArrayClass(this.capacity);\n}\n/**\n * Method used to set a value.\n *\n * @param  {number} index - Index to edit.\n * @param  {any}    value - Value.\n * @return {Vector}\n */\n\n\nVector.prototype.set = function (index, value) {\n  // Out of bounds?\n  if (this.length < index) throw new Error('Vector(' + this.ArrayClass.name + ').set: index out of bounds.'); // Updating value\n\n  this.array[index] = value;\n  return this;\n};\n/**\n * Method used to get a value.\n *\n * @param  {number} index - Index to retrieve.\n * @return {any}\n */\n\n\nVector.prototype.get = function (index) {\n  if (this.length < index) return undefined;\n  return this.array[index];\n};\n/**\n * Method used to apply the growing policy.\n *\n * @param  {number} [override] - Override capacity.\n * @return {number}\n */\n\n\nVector.prototype.applyPolicy = function (override) {\n  var newCapacity = this.policy(override || this.capacity);\n  if (typeof newCapacity !== 'number' || newCapacity < 0) throw new Error('mnemonist/vector.applyPolicy: policy returned an invalid value (expecting a positive integer).');\n  if (newCapacity <= this.capacity) throw new Error('mnemonist/vector.applyPolicy: policy returned a less or equal capacity to allocate.'); // TODO: we should probably check that the returned number is an integer\n\n  return newCapacity;\n};\n/**\n * Method used to reallocate the underlying array.\n *\n * @param  {number}       capacity - Target capacity.\n * @return {Vector}\n */\n\n\nVector.prototype.reallocate = function (capacity) {\n  if (capacity === this.capacity) return this;\n  var oldArray = this.array;\n  if (capacity < this.length) this.length = capacity;\n\n  if (capacity > this.capacity) {\n    if (this.factory === null) this.array = new this.ArrayClass(capacity);else this.array = this.factory(capacity);\n\n    if (typed.isTypedArray(this.array)) {\n      this.array.set(oldArray, 0);\n    } else {\n      for (var i = 0, l = this.length; i < l; i++) {\n        this.array[i] = oldArray[i];\n      }\n    }\n  } else {\n    this.array = oldArray.slice(0, capacity);\n  }\n\n  this.capacity = capacity;\n  return this;\n};\n/**\n * Method used to grow the array.\n *\n * @param  {number}       [capacity] - Optional capacity to match.\n * @return {Vector}\n */\n\n\nVector.prototype.grow = function (capacity) {\n  var newCapacity;\n\n  if (typeof capacity === 'number') {\n    if (this.capacity >= capacity) return this; // We need to match the given capacity\n\n    newCapacity = this.capacity;\n\n    while (newCapacity < capacity) {\n      newCapacity = this.applyPolicy(newCapacity);\n    }\n\n    this.reallocate(newCapacity);\n    return this;\n  } // We need to run the policy once\n\n\n  newCapacity = this.applyPolicy();\n  this.reallocate(newCapacity);\n  return this;\n};\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {Vector}\n */\n\n\nVector.prototype.resize = function (length) {\n  if (length === this.length) return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.reallocate(length);\n  return this;\n};\n/**\n * Method used to push a value into the array.\n *\n * @param  {any}    value - Value to push.\n * @return {number}       - Length of the array.\n */\n\n\nVector.prototype.push = function (value) {\n  if (this.capacity === this.length) this.grow();\n  this.array[this.length++] = value;\n  return this.length;\n};\n/**\n * Method used to pop the last value of the array.\n *\n * @return {number} - The popped value.\n */\n\n\nVector.prototype.pop = function () {\n  if (this.length === 0) return;\n  return this.array[--this.length];\n};\n/**\n * Method used to create an iterator over a vector's values.\n *\n * @return {Iterator}\n */\n\n\nVector.prototype.values = function () {\n  var items = this.array,\n      l = this.length,\n      i = 0;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var value = items[i];\n    i++;\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n/**\n * Method used to create an iterator over a vector's entries.\n *\n * @return {Iterator}\n */\n\n\nVector.prototype.entries = function () {\n  var items = this.array,\n      l = this.length,\n      i = 0;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var value = items[i];\n    return {\n      value: [i++, value],\n      done: false\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') Vector.prototype[Symbol.iterator] = Vector.prototype.values;\n/**\n * Convenience known methods.\n */\n\nVector.prototype.inspect = function () {\n  var proxy = this.array.slice(0, this.length);\n  proxy.type = this.array.constructor.name;\n  proxy.items = this.length;\n  proxy.capacity = this.capacity; // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: Vector,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') Vector.prototype[Symbol.for('nodejs.util.inspect.custom')] = Vector.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a vector.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Byte array class.\n * @param  {number}   capacity   - Desired capacity.\n * @return {Vector}\n */\n\nVector.from = function (iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    // Attempting to guess the needed capacity\n    capacity = iterables.guessLength(iterable);\n    if (typeof capacity !== 'number') throw new Error('mnemonist/vector.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var vector = new Vector(ArrayClass, capacity);\n  forEach(iterable, function (value) {\n    vector.push(value);\n  });\n  return vector;\n};\n/**\n * Exporting.\n */\n\n\nfunction subClass(ArrayClass) {\n  var SubClass = function SubClass(initialCapacityOrOptions) {\n    Vector.call(this, ArrayClass, initialCapacityOrOptions);\n  };\n\n  for (var k in Vector.prototype) {\n    if (Vector.prototype.hasOwnProperty(k)) SubClass.prototype[k] = Vector.prototype[k];\n  }\n\n  SubClass.from = function (iterable, capacity) {\n    return Vector.from(iterable, ArrayClass, capacity);\n  };\n\n  if (typeof Symbol !== 'undefined') SubClass.prototype[Symbol.iterator] = SubClass.prototype.values;\n  return SubClass;\n}\n\nVector.Int8Vector = subClass(Int8Array);\nVector.Uint8Vector = subClass(Uint8Array);\nVector.Uint8ClampedVector = subClass(Uint8ClampedArray);\nVector.Int16Vector = subClass(Int16Array);\nVector.Uint16Vector = subClass(Uint16Array);\nVector.Int32Vector = subClass(Int32Array);\nVector.Uint32Vector = subClass(Uint32Array);\nVector.Float32Vector = subClass(Float32Array);\nVector.Float64Vector = subClass(Float64Array);\nVector.PointerVector = subClass(pointerArrayFactory);\nmodule.exports = Vector;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/vector.js"],"names":["Iterator","require","forEach","iterables","typed","DEFAULT_GROWING_POLICY","currentCapacity","Math","max","ceil","pointerArrayFactory","capacity","PointerArray","getPointerArray","Vector","ArrayClass","initialCapacityOrOptions","arguments","length","Error","initialCapacity","policy","initialLength","factory","array","prototype","set","index","value","name","get","undefined","applyPolicy","override","newCapacity","reallocate","oldArray","isTypedArray","i","l","slice","grow","resize","push","pop","values","items","done","entries","Symbol","iterator","inspect","proxy","type","constructor","Object","defineProperty","enumerable","for","from","iterable","guessLength","vector","subClass","SubClass","call","k","hasOwnProperty","Int8Vector","Int8Array","Uint8Vector","Uint8Array","Uint8ClampedVector","Uint8ClampedArray","Int16Vector","Int16Array","Uint16Vector","Uint16Array","Int32Vector","Int32Array","Uint32Vector","Uint32Array","Float32Vector","Float32Array","Float64Vector","Float64Array","PointerVector","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Vector\n * =================\n *\n * Abstract implementation of a growing array that can be used with JavaScript\n * typed arrays and other array-like structures.\n *\n * Note: should try and use ArrayBuffer.transfer when it will be available.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js');\n\n/**\n * Defaults.\n */\nvar DEFAULT_GROWING_POLICY = function(currentCapacity) {\n  return Math.max(1, Math.ceil(currentCapacity * 1.5));\n};\n\nvar pointerArrayFactory = function(capacity) {\n  var PointerArray = typed.getPointerArray(capacity);\n\n  return new PointerArray(capacity);\n};\n\n/**\n * Vector.\n *\n * @constructor\n * @param {function}      ArrayClass             - An array constructor.\n * @param {number|object} initialCapacityOrOptions - Self-explanatory:\n * @param {number}        initialCapacity          - Initial capacity.\n * @param {number}        initialLength            - Initial length.\n * @param {function}      policy                   - Allocation policy.\n */\nfunction Vector(ArrayClass, initialCapacityOrOptions) {\n  if (arguments.length < 1)\n    throw new Error('mnemonist/vector: expecting at least a byte array constructor.');\n\n  var initialCapacity = initialCapacityOrOptions || 0,\n      policy = DEFAULT_GROWING_POLICY,\n      initialLength = 0,\n      factory = false;\n\n  if (typeof initialCapacityOrOptions === 'object') {\n    initialCapacity = initialCapacityOrOptions.initialCapacity || 0;\n    initialLength = initialCapacityOrOptions.initialLength || 0;\n    policy = initialCapacityOrOptions.policy || policy;\n    factory = initialCapacityOrOptions.factory === true;\n  }\n\n  this.factory = factory ? ArrayClass : null;\n  this.ArrayClass = ArrayClass;\n  this.length = initialLength;\n  this.capacity = Math.max(initialLength, initialCapacity);\n  this.policy = policy;\n  this.array = new ArrayClass(this.capacity);\n}\n\n/**\n * Method used to set a value.\n *\n * @param  {number} index - Index to edit.\n * @param  {any}    value - Value.\n * @return {Vector}\n */\nVector.prototype.set = function(index, value) {\n\n  // Out of bounds?\n  if (this.length < index)\n    throw new Error('Vector(' + this.ArrayClass.name + ').set: index out of bounds.');\n\n  // Updating value\n  this.array[index] = value;\n\n  return this;\n};\n\n/**\n * Method used to get a value.\n *\n * @param  {number} index - Index to retrieve.\n * @return {any}\n */\nVector.prototype.get = function(index) {\n  if (this.length < index)\n    return undefined;\n\n  return this.array[index];\n};\n\n/**\n * Method used to apply the growing policy.\n *\n * @param  {number} [override] - Override capacity.\n * @return {number}\n */\nVector.prototype.applyPolicy = function(override) {\n  var newCapacity = this.policy(override || this.capacity);\n\n  if (typeof newCapacity !== 'number' || newCapacity < 0)\n    throw new Error('mnemonist/vector.applyPolicy: policy returned an invalid value (expecting a positive integer).');\n\n  if (newCapacity <= this.capacity)\n    throw new Error('mnemonist/vector.applyPolicy: policy returned a less or equal capacity to allocate.');\n\n  // TODO: we should probably check that the returned number is an integer\n  return newCapacity;\n};\n\n/**\n * Method used to reallocate the underlying array.\n *\n * @param  {number}       capacity - Target capacity.\n * @return {Vector}\n */\nVector.prototype.reallocate = function(capacity) {\n  if (capacity === this.capacity)\n    return this;\n\n  var oldArray = this.array;\n\n  if (capacity < this.length)\n    this.length = capacity;\n\n  if (capacity > this.capacity) {\n    if (this.factory === null)\n      this.array = new this.ArrayClass(capacity);\n    else\n      this.array = this.factory(capacity);\n\n    if (typed.isTypedArray(this.array)) {\n      this.array.set(oldArray, 0);\n    }\n    else {\n      for (var i = 0, l = this.length; i < l; i++)\n        this.array[i] = oldArray[i];\n    }\n  }\n  else {\n    this.array = oldArray.slice(0, capacity);\n  }\n\n  this.capacity = capacity;\n\n  return this;\n};\n\n/**\n * Method used to grow the array.\n *\n * @param  {number}       [capacity] - Optional capacity to match.\n * @return {Vector}\n */\nVector.prototype.grow = function(capacity) {\n  var newCapacity;\n\n  if (typeof capacity === 'number') {\n\n    if (this.capacity >= capacity)\n      return this;\n\n    // We need to match the given capacity\n    newCapacity = this.capacity;\n\n    while (newCapacity < capacity)\n      newCapacity = this.applyPolicy(newCapacity);\n\n    this.reallocate(newCapacity);\n\n    return this;\n  }\n\n  // We need to run the policy once\n  newCapacity = this.applyPolicy();\n  this.reallocate(newCapacity);\n\n  return this;\n};\n\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {Vector}\n */\nVector.prototype.resize = function(length) {\n  if (length === this.length)\n    return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.reallocate(length);\n\n  return this;\n};\n\n/**\n * Method used to push a value into the array.\n *\n * @param  {any}    value - Value to push.\n * @return {number}       - Length of the array.\n */\nVector.prototype.push = function(value) {\n  if (this.capacity === this.length)\n    this.grow();\n\n  this.array[this.length++] = value;\n\n  return this.length;\n};\n\n/**\n * Method used to pop the last value of the array.\n *\n * @return {number} - The popped value.\n */\nVector.prototype.pop = function() {\n  if (this.length === 0)\n    return;\n\n  return this.array[--this.length];\n};\n\n/**\n * Method used to create an iterator over a vector's values.\n *\n * @return {Iterator}\n */\nVector.prototype.values = function() {\n  var items = this.array,\n      l = this.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n    i++;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a vector's entries.\n *\n * @return {Iterator}\n */\nVector.prototype.entries = function() {\n  var items = this.array,\n      l = this.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n\n    return {\n      value: [i++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  Vector.prototype[Symbol.iterator] = Vector.prototype.values;\n\n/**\n * Convenience known methods.\n */\nVector.prototype.inspect = function() {\n  var proxy = this.array.slice(0, this.length);\n\n  proxy.type = this.array.constructor.name;\n  proxy.items = this.length;\n  proxy.capacity = this.capacity;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Vector,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Vector.prototype[Symbol.for('nodejs.util.inspect.custom')] = Vector.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a vector.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Byte array class.\n * @param  {number}   capacity   - Desired capacity.\n * @return {Vector}\n */\nVector.from = function(iterable, ArrayClass, capacity) {\n\n  if (arguments.length < 3) {\n\n    // Attempting to guess the needed capacity\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/vector.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var vector = new Vector(ArrayClass, capacity);\n\n  forEach(iterable, function(value) {\n    vector.push(value);\n  });\n\n  return vector;\n};\n\n/**\n * Exporting.\n */\nfunction subClass(ArrayClass) {\n  var SubClass = function(initialCapacityOrOptions) {\n    Vector.call(this, ArrayClass, initialCapacityOrOptions);\n  };\n\n  for (var k in Vector.prototype) {\n    if (Vector.prototype.hasOwnProperty(k))\n      SubClass.prototype[k] = Vector.prototype[k];\n  }\n\n  SubClass.from = function(iterable, capacity) {\n    return Vector.from(iterable, ArrayClass, capacity);\n  };\n\n  if (typeof Symbol !== 'undefined')\n    SubClass.prototype[Symbol.iterator] = SubClass.prototype.values;\n\n  return SubClass;\n}\n\nVector.Int8Vector = subClass(Int8Array);\nVector.Uint8Vector = subClass(Uint8Array);\nVector.Uint8ClampedVector = subClass(Uint8ClampedArray);\nVector.Int16Vector = subClass(Int16Array);\nVector.Uint16Vector = subClass(Uint16Array);\nVector.Int32Vector = subClass(Int32Array);\nVector.Uint32Vector = subClass(Uint32Array);\nVector.Float32Vector = subClass(Float32Array);\nVector.Float64Vector = subClass(Float64Array);\nVector.PointerVector = subClass(pointerArrayFactory);\n\nmodule.exports = Vector;\n"]},"metadata":{},"sourceType":"script"}