{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { DEFAULT_TXN_DISMISS_MS, L2_TXN_DISMISS_MS } from 'constants/misc';\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { L2_CHAIN_IDS, SupportedChainId } from '../../constants/chains';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { retry, RetryableError } from '../../utils/retry';\nimport { useAddPopup, useBlockNumber } from '../application/hooks';\nimport { updateBlockNumber } from '../application/reducer';\nimport { checkedTransaction, finalizeTransaction } from './actions';\nexport function shouldCheck(lastBlockNumber, tx) {\n  if (tx.receipt) return false;\n  if (!tx.lastCheckedBlockNumber) return true;\n  const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber;\n  if (blocksSinceCheck < 1) return false;\n  const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60;\n\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9;\n  } else if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2;\n  } else {\n    // otherwise every block\n    return true;\n  }\n}\nconst RETRY_OPTIONS_BY_CHAIN_ID = {\n  [SupportedChainId.ARBITRUM_ONE]: {\n    n: 10,\n    minWait: 250,\n    maxWait: 1000\n  },\n  [SupportedChainId.ARBITRUM_RINKEBY]: {\n    n: 10,\n    minWait: 250,\n    maxWait: 1000\n  },\n  [SupportedChainId.OPTIMISTIC_KOVAN]: {\n    n: 10,\n    minWait: 250,\n    maxWait: 1000\n  },\n  [SupportedChainId.OPTIMISM]: {\n    n: 10,\n    minWait: 250,\n    maxWait: 1000\n  }\n};\nconst DEFAULT_RETRY_OPTIONS = {\n  n: 1,\n  minWait: 0,\n  maxWait: 0\n};\nexport default function Updater() {\n  _s();\n\n  const {\n    chainId,\n    library\n  } = useActiveWeb3React();\n  const lastBlockNumber = useBlockNumber();\n  const dispatch = useAppDispatch();\n  const state = useAppSelector(state => state.transactions);\n  const transactions = useMemo(() => {\n    var _state$chainId;\n\n    return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n  }, [chainId, state]); // show popup on confirm\n\n  const addPopup = useAddPopup(); // speed up popup dismisall time if on L2\n\n  const isL2 = Boolean(chainId && L2_CHAIN_IDS.includes(chainId));\n  const getReceipt = useCallback(hash => {\n    var _RETRY_OPTIONS_BY_CHA;\n\n    if (!library || !chainId) throw new Error('No library or chainId');\n    const retryOptions = (_RETRY_OPTIONS_BY_CHA = RETRY_OPTIONS_BY_CHAIN_ID[chainId]) !== null && _RETRY_OPTIONS_BY_CHA !== void 0 ? _RETRY_OPTIONS_BY_CHA : DEFAULT_RETRY_OPTIONS;\n    return retry(() => library.getTransactionReceipt(hash).then(receipt => {\n      if (receipt === null) {\n        console.debug('Retrying for hash', hash);\n        throw new RetryableError();\n      }\n\n      return receipt;\n    }), retryOptions);\n  }, [chainId, library]);\n  useEffect(() => {\n    if (!chainId || !library || !lastBlockNumber) return;\n    const cancels = Object.keys(transactions).filter(hash => shouldCheck(lastBlockNumber, transactions[hash])).map(hash => {\n      const {\n        promise,\n        cancel\n      } = getReceipt(hash);\n      promise.then(receipt => {\n        if (receipt) {\n          dispatch(finalizeTransaction({\n            chainId,\n            hash,\n            receipt: {\n              blockHash: receipt.blockHash,\n              blockNumber: receipt.blockNumber,\n              contractAddress: receipt.contractAddress,\n              from: receipt.from,\n              status: receipt.status,\n              to: receipt.to,\n              transactionHash: receipt.transactionHash,\n              transactionIndex: receipt.transactionIndex\n            }\n          }));\n          addPopup({\n            txn: {\n              hash\n            }\n          }, hash, isL2 ? L2_TXN_DISMISS_MS : DEFAULT_TXN_DISMISS_MS); // the receipt was fetched before the block, fast forward to that block to trigger balance updates\n\n          if (receipt.blockNumber > lastBlockNumber) {\n            dispatch(updateBlockNumber({\n              chainId,\n              blockNumber: receipt.blockNumber\n            }));\n          }\n        } else {\n          dispatch(checkedTransaction({\n            chainId,\n            hash,\n            blockNumber: lastBlockNumber\n          }));\n        }\n      }).catch(error => {\n        if (!error.isCancelledError) {\n          console.error(`Failed to check transaction hash: ${hash}`, error);\n        }\n      });\n      return cancel;\n    });\n    return () => {\n      cancels.forEach(cancel => cancel());\n    };\n  }, [chainId, library, transactions, lastBlockNumber, dispatch, addPopup, getReceipt, isL2]);\n  return null;\n}\n\n_s(Updater, \"vP6gNsfkFsb0bvbIUSbkwbiDzFc=\", false, function () {\n  return [useActiveWeb3React, useBlockNumber, useAppDispatch, useAppSelector, useAddPopup];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/transactions/updater.tsx"],"names":["DEFAULT_TXN_DISMISS_MS","L2_TXN_DISMISS_MS","useCallback","useEffect","useMemo","useAppDispatch","useAppSelector","L2_CHAIN_IDS","SupportedChainId","useActiveWeb3React","retry","RetryableError","useAddPopup","useBlockNumber","updateBlockNumber","checkedTransaction","finalizeTransaction","shouldCheck","lastBlockNumber","tx","receipt","lastCheckedBlockNumber","blocksSinceCheck","minutesPending","Date","getTime","addedTime","RETRY_OPTIONS_BY_CHAIN_ID","ARBITRUM_ONE","n","minWait","maxWait","ARBITRUM_RINKEBY","OPTIMISTIC_KOVAN","OPTIMISM","DEFAULT_RETRY_OPTIONS","Updater","chainId","library","dispatch","state","transactions","addPopup","isL2","Boolean","includes","getReceipt","hash","Error","retryOptions","getTransactionReceipt","then","console","debug","cancels","Object","keys","filter","map","promise","cancel","blockHash","blockNumber","contractAddress","from","status","to","transactionHash","transactionIndex","txn","catch","error","isCancelledError","forEach"],"mappings":";;AAAA,SAASA,sBAAT,EAAiCC,iBAAjC,QAA0D,gBAA1D;AACA,SAASC,WAAT,EAAsBC,SAAtB,EAAiCC,OAAjC,QAAgD,OAAhD;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,aAA/C;AAEA,SAASC,YAAT,EAAuBC,gBAAvB,QAA+C,wBAA/C;AACA,SAASC,kBAAT,QAAmC,kBAAnC;AACA,SAASC,KAAT,EAAgBC,cAAhB,QAAoD,mBAApD;AACA,SAASC,WAAT,EAAsBC,cAAtB,QAA4C,sBAA5C;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,SAASC,kBAAT,EAA6BC,mBAA7B,QAAwD,WAAxD;AAQA,OAAO,SAASC,WAAT,CAAqBC,eAArB,EAA8CC,EAA9C,EAAwE;AAC7E,MAAIA,EAAE,CAACC,OAAP,EAAgB,OAAO,KAAP;AAChB,MAAI,CAACD,EAAE,CAACE,sBAAR,EAAgC,OAAO,IAAP;AAChC,QAAMC,gBAAgB,GAAGJ,eAAe,GAAGC,EAAE,CAACE,sBAA9C;AACA,MAAIC,gBAAgB,GAAG,CAAvB,EAA0B,OAAO,KAAP;AAC1B,QAAMC,cAAc,GAAG,CAAC,IAAIC,IAAJ,GAAWC,OAAX,KAAuBN,EAAE,CAACO,SAA3B,IAAwC,IAAxC,GAA+C,EAAtE;;AACA,MAAIH,cAAc,GAAG,EAArB,EAAyB;AACvB;AACA,WAAOD,gBAAgB,GAAG,CAA1B;AACD,GAHD,MAGO,IAAIC,cAAc,GAAG,CAArB,EAAwB;AAC7B;AACA,WAAOD,gBAAgB,GAAG,CAA1B;AACD,GAHM,MAGA;AACL;AACA,WAAO,IAAP;AACD;AACF;AAED,MAAMK,yBAA8D,GAAG;AACrE,GAACnB,gBAAgB,CAACoB,YAAlB,GAAiC;AAAEC,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,OAAO,EAAE,GAAlB;AAAuBC,IAAAA,OAAO,EAAE;AAAhC,GADoC;AAErE,GAACvB,gBAAgB,CAACwB,gBAAlB,GAAqC;AAAEH,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,OAAO,EAAE,GAAlB;AAAuBC,IAAAA,OAAO,EAAE;AAAhC,GAFgC;AAGrE,GAACvB,gBAAgB,CAACyB,gBAAlB,GAAqC;AAAEJ,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,OAAO,EAAE,GAAlB;AAAuBC,IAAAA,OAAO,EAAE;AAAhC,GAHgC;AAIrE,GAACvB,gBAAgB,CAAC0B,QAAlB,GAA6B;AAAEL,IAAAA,CAAC,EAAE,EAAL;AAASC,IAAAA,OAAO,EAAE,GAAlB;AAAuBC,IAAAA,OAAO,EAAE;AAAhC;AAJwC,CAAvE;AAMA,MAAMI,qBAAmC,GAAG;AAAEN,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,OAAO,EAAE,CAAjB;AAAoBC,EAAAA,OAAO,EAAE;AAA7B,CAA5C;AAEA,eAAe,SAASK,OAAT,GAAyB;AAAA;;AACtC,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuB7B,kBAAkB,EAA/C;AAEA,QAAMS,eAAe,GAAGL,cAAc,EAAtC;AAEA,QAAM0B,QAAQ,GAAGlC,cAAc,EAA/B;AACA,QAAMmC,KAAK,GAAGlC,cAAc,CAAEkC,KAAD,IAAWA,KAAK,CAACC,YAAlB,CAA5B;AAEA,QAAMA,YAAY,GAAGrC,OAAO,CAAC;AAAA;;AAAA,WAAOiC,OAAO,qBAAGG,KAAK,CAACH,OAAD,CAAR,2DAAqB,EAArB,GAA0B,EAAxC;AAAA,GAAD,EAA8C,CAACA,OAAD,EAAUG,KAAV,CAA9C,CAA5B,CARsC,CAUtC;;AACA,QAAME,QAAQ,GAAG9B,WAAW,EAA5B,CAXsC,CAatC;;AACA,QAAM+B,IAAI,GAAGC,OAAO,CAACP,OAAO,IAAI9B,YAAY,CAACsC,QAAb,CAAsBR,OAAtB,CAAZ,CAApB;AAEA,QAAMS,UAAU,GAAG5C,WAAW,CAC3B6C,IAAD,IAAkB;AAAA;;AAChB,QAAI,CAACT,OAAD,IAAY,CAACD,OAAjB,EAA0B,MAAM,IAAIW,KAAJ,CAAU,uBAAV,CAAN;AAC1B,UAAMC,YAAY,4BAAGtB,yBAAyB,CAACU,OAAD,CAA5B,yEAAyCF,qBAA3D;AACA,WAAOzB,KAAK,CACV,MACE4B,OAAO,CAACY,qBAAR,CAA8BH,IAA9B,EAAoCI,IAApC,CAA0C/B,OAAD,IAAa;AACpD,UAAIA,OAAO,KAAK,IAAhB,EAAsB;AACpBgC,QAAAA,OAAO,CAACC,KAAR,CAAc,mBAAd,EAAmCN,IAAnC;AACA,cAAM,IAAIpC,cAAJ,EAAN;AACD;;AACD,aAAOS,OAAP;AACD,KAND,CAFQ,EASV6B,YATU,CAAZ;AAWD,GAf2B,EAgB5B,CAACZ,OAAD,EAAUC,OAAV,CAhB4B,CAA9B;AAmBAnC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACkC,OAAD,IAAY,CAACC,OAAb,IAAwB,CAACpB,eAA7B,EAA8C;AAE9C,UAAMoC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYf,YAAZ,EACbgB,MADa,CACLV,IAAD,IAAU9B,WAAW,CAACC,eAAD,EAAkBuB,YAAY,CAACM,IAAD,CAA9B,CADf,EAEbW,GAFa,CAERX,IAAD,IAAU;AACb,YAAM;AAAEY,QAAAA,OAAF;AAAWC,QAAAA;AAAX,UAAsBd,UAAU,CAACC,IAAD,CAAtC;AACAY,MAAAA,OAAO,CACJR,IADH,CACS/B,OAAD,IAAa;AACjB,YAAIA,OAAJ,EAAa;AACXmB,UAAAA,QAAQ,CACNvB,mBAAmB,CAAC;AAClBqB,YAAAA,OADkB;AAElBU,YAAAA,IAFkB;AAGlB3B,YAAAA,OAAO,EAAE;AACPyC,cAAAA,SAAS,EAAEzC,OAAO,CAACyC,SADZ;AAEPC,cAAAA,WAAW,EAAE1C,OAAO,CAAC0C,WAFd;AAGPC,cAAAA,eAAe,EAAE3C,OAAO,CAAC2C,eAHlB;AAIPC,cAAAA,IAAI,EAAE5C,OAAO,CAAC4C,IAJP;AAKPC,cAAAA,MAAM,EAAE7C,OAAO,CAAC6C,MALT;AAMPC,cAAAA,EAAE,EAAE9C,OAAO,CAAC8C,EANL;AAOPC,cAAAA,eAAe,EAAE/C,OAAO,CAAC+C,eAPlB;AAQPC,cAAAA,gBAAgB,EAAEhD,OAAO,CAACgD;AARnB;AAHS,WAAD,CADb,CAAR;AAiBA1B,UAAAA,QAAQ,CACN;AACE2B,YAAAA,GAAG,EAAE;AACHtB,cAAAA;AADG;AADP,WADM,EAMNA,IANM,EAONJ,IAAI,GAAG1C,iBAAH,GAAuBD,sBAPrB,CAAR,CAlBW,CA4BX;;AACA,cAAIoB,OAAO,CAAC0C,WAAR,GAAsB5C,eAA1B,EAA2C;AACzCqB,YAAAA,QAAQ,CAACzB,iBAAiB,CAAC;AAAEuB,cAAAA,OAAF;AAAWyB,cAAAA,WAAW,EAAE1C,OAAO,CAAC0C;AAAhC,aAAD,CAAlB,CAAR;AACD;AACF,SAhCD,MAgCO;AACLvB,UAAAA,QAAQ,CAACxB,kBAAkB,CAAC;AAAEsB,YAAAA,OAAF;AAAWU,YAAAA,IAAX;AAAiBe,YAAAA,WAAW,EAAE5C;AAA9B,WAAD,CAAnB,CAAR;AACD;AACF,OArCH,EAsCGoD,KAtCH,CAsCUC,KAAD,IAAW;AAChB,YAAI,CAACA,KAAK,CAACC,gBAAX,EAA6B;AAC3BpB,UAAAA,OAAO,CAACmB,KAAR,CAAe,qCAAoCxB,IAAK,EAAxD,EAA2DwB,KAA3D;AACD;AACF,OA1CH;AA2CA,aAAOX,MAAP;AACD,KAhDa,CAAhB;AAkDA,WAAO,MAAM;AACXN,MAAAA,OAAO,CAACmB,OAAR,CAAiBb,MAAD,IAAYA,MAAM,EAAlC;AACD,KAFD;AAGD,GAxDQ,EAwDN,CAACvB,OAAD,EAAUC,OAAV,EAAmBG,YAAnB,EAAiCvB,eAAjC,EAAkDqB,QAAlD,EAA4DG,QAA5D,EAAsEI,UAAtE,EAAkFH,IAAlF,CAxDM,CAAT;AA0DA,SAAO,IAAP;AACD;;GA9FuBP,O;UACO3B,kB,EAELI,c,EAEPR,c,EACHC,c,EAKGM,W;;;KAXKwB,O","sourcesContent":["import { DEFAULT_TXN_DISMISS_MS, L2_TXN_DISMISS_MS } from 'constants/misc'\nimport { useCallback, useEffect, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\n\nimport { L2_CHAIN_IDS, SupportedChainId } from '../../constants/chains'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { retry, RetryableError, RetryOptions } from '../../utils/retry'\nimport { useAddPopup, useBlockNumber } from '../application/hooks'\nimport { updateBlockNumber } from '../application/reducer'\nimport { checkedTransaction, finalizeTransaction } from './actions'\n\ninterface TxInterface {\n  addedTime: number\n  receipt?: Record<string, any>\n  lastCheckedBlockNumber?: number\n}\n\nexport function shouldCheck(lastBlockNumber: number, tx: TxInterface): boolean {\n  if (tx.receipt) return false\n  if (!tx.lastCheckedBlockNumber) return true\n  const blocksSinceCheck = lastBlockNumber - tx.lastCheckedBlockNumber\n  if (blocksSinceCheck < 1) return false\n  const minutesPending = (new Date().getTime() - tx.addedTime) / 1000 / 60\n  if (minutesPending > 60) {\n    // every 10 blocks if pending for longer than an hour\n    return blocksSinceCheck > 9\n  } else if (minutesPending > 5) {\n    // every 3 blocks if pending more than 5 minutes\n    return blocksSinceCheck > 2\n  } else {\n    // otherwise every block\n    return true\n  }\n}\n\nconst RETRY_OPTIONS_BY_CHAIN_ID: { [chainId: number]: RetryOptions } = {\n  [SupportedChainId.ARBITRUM_ONE]: { n: 10, minWait: 250, maxWait: 1000 },\n  [SupportedChainId.ARBITRUM_RINKEBY]: { n: 10, minWait: 250, maxWait: 1000 },\n  [SupportedChainId.OPTIMISTIC_KOVAN]: { n: 10, minWait: 250, maxWait: 1000 },\n  [SupportedChainId.OPTIMISM]: { n: 10, minWait: 250, maxWait: 1000 },\n}\nconst DEFAULT_RETRY_OPTIONS: RetryOptions = { n: 1, minWait: 0, maxWait: 0 }\n\nexport default function Updater(): null {\n  const { chainId, library } = useActiveWeb3React()\n\n  const lastBlockNumber = useBlockNumber()\n\n  const dispatch = useAppDispatch()\n  const state = useAppSelector((state) => state.transactions)\n\n  const transactions = useMemo(() => (chainId ? state[chainId] ?? {} : {}), [chainId, state])\n\n  // show popup on confirm\n  const addPopup = useAddPopup()\n\n  // speed up popup dismisall time if on L2\n  const isL2 = Boolean(chainId && L2_CHAIN_IDS.includes(chainId))\n\n  const getReceipt = useCallback(\n    (hash: string) => {\n      if (!library || !chainId) throw new Error('No library or chainId')\n      const retryOptions = RETRY_OPTIONS_BY_CHAIN_ID[chainId] ?? DEFAULT_RETRY_OPTIONS\n      return retry(\n        () =>\n          library.getTransactionReceipt(hash).then((receipt) => {\n            if (receipt === null) {\n              console.debug('Retrying for hash', hash)\n              throw new RetryableError()\n            }\n            return receipt\n          }),\n        retryOptions\n      )\n    },\n    [chainId, library]\n  )\n\n  useEffect(() => {\n    if (!chainId || !library || !lastBlockNumber) return\n\n    const cancels = Object.keys(transactions)\n      .filter((hash) => shouldCheck(lastBlockNumber, transactions[hash]))\n      .map((hash) => {\n        const { promise, cancel } = getReceipt(hash)\n        promise\n          .then((receipt) => {\n            if (receipt) {\n              dispatch(\n                finalizeTransaction({\n                  chainId,\n                  hash,\n                  receipt: {\n                    blockHash: receipt.blockHash,\n                    blockNumber: receipt.blockNumber,\n                    contractAddress: receipt.contractAddress,\n                    from: receipt.from,\n                    status: receipt.status,\n                    to: receipt.to,\n                    transactionHash: receipt.transactionHash,\n                    transactionIndex: receipt.transactionIndex,\n                  },\n                })\n              )\n\n              addPopup(\n                {\n                  txn: {\n                    hash,\n                  },\n                },\n                hash,\n                isL2 ? L2_TXN_DISMISS_MS : DEFAULT_TXN_DISMISS_MS\n              )\n\n              // the receipt was fetched before the block, fast forward to that block to trigger balance updates\n              if (receipt.blockNumber > lastBlockNumber) {\n                dispatch(updateBlockNumber({ chainId, blockNumber: receipt.blockNumber }))\n              }\n            } else {\n              dispatch(checkedTransaction({ chainId, hash, blockNumber: lastBlockNumber }))\n            }\n          })\n          .catch((error) => {\n            if (!error.isCancelledError) {\n              console.error(`Failed to check transaction hash: ${hash}`, error)\n            }\n          })\n        return cancel\n      })\n\n    return () => {\n      cancels.forEach((cancel) => cancel())\n    }\n  }, [chainId, library, transactions, lastBlockNumber, dispatch, addPopup, getReceipt, isL2])\n\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}