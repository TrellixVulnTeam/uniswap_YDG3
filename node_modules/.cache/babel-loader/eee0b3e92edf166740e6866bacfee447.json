{"ast":null,"code":"/**\n * Mnemonist PassjoinIndex\n * ========================\n *\n * The PassjoinIndex is an index leveraging the \"passjoin\" algorithm as a mean\n * to index strings for Levenshtein distance queries. It features a complexity\n * related to the Levenshtein query threshold k rather than the number of\n * strings to test (roughly O(k^3)).\n *\n * [References]:\n * Jiang, Yu, Dong Deng, Jiannan Wang, Guoliang Li, et Jianhua Feng.\n * « Efficient Parallel Partition-Based Algorithms for Similarity Search and Join\n * with Edit Distance Constraints ». In Proceedings of the Joint EDBT/ICDT 2013\n * Workshops on - EDBT ’13, 341. Genoa, Italy: ACM Press, 2013.\n * https://doi.org/10.1145/2457317.2457382.\n *\n * Li, Guoliang, Dong Deng, et Jianhua Feng. « A Partition-Based Method for\n * String Similarity Joins with Edit-Distance Constraints ». ACM Transactions on\n * Database Systems 38, no 2 (1 juin 2013): 1‑33.\n * https://doi.org/10.1145/2487259.2487261.\n *\n * [Urls]:\n * http://people.csail.mit.edu/dongdeng/projects/passjoin/index.html\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'); // TODO: leveraging BagDistance as an upper bound of Levenshtein\n// TODO: leverage n-grams recursive indexing\n// TODO: try the MultiArray as a memory backend\n// TODO: what about damerau levenshtein\n\n/**\n * Helpers.\n */\n\n/**\n * Function returning the number of substrings that will be selected by the\n * multi-match-aware selection scheme for theshold `k`, for a string of length\n * `s` to match strings of length `l`.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @param   {number} l - Length of strings to match.\n * @returns {number}   - The number of selected substrings.\n */\n\n\nfunction countSubstringsL(k, s, l) {\n  return ((Math.pow(k, 2) - Math.pow(Math.abs(s - l), 2)) / 2 | 0) + k + 1;\n}\n/**\n * Function returning the minimum number of substrings that will be selected by\n * the multi-match-aware selection scheme for theshold `k`, for a string of\n * length `s` to match any string of relevant length.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @returns {number}   - The number of selected substrings.\n */\n\n\nfunction countKeys(k, s) {\n  var c = 0;\n\n  for (var l = 0, m = s + 1; l < m; l++) c += countSubstringsL(k, s, l);\n\n  return c;\n}\n/**\n * Function used to compare two keys in order to sort them first by decreasing\n * length and then alphabetically as per the \"4.2 Effective Indexing Strategy\"\n * point of the paper.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @returns {number}   - The number of selected substrings.\n */\n\n\nfunction comparator(a, b) {\n  if (a.length > b.length) return -1;\n  if (a.length < b.length) return 1;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n}\n/**\n * Function partitioning a string into k + 1 uneven segments, the shorter\n * ones, then the longer ones.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} l - Length of the string.\n * @returns {Array}    - The partition tuples (start, length).\n */\n\n\nfunction partition(k, l) {\n  var m = k + 1,\n      a = l / m | 0,\n      b = a + 1,\n      i,\n      j;\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n  var tuples = new Array(k + 1);\n\n  for (i = 0; i < smallSegments; i++) tuples[i] = [i * a, a];\n\n  var offset = (i - 1) * a + a;\n\n  for (j = 0; j < largeSegments; j++) tuples[i + j] = [offset + j * b, b];\n\n  return tuples;\n}\n/**\n * Function yielding a string's k + 1 passjoin segments to index.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {string} string - Target string.\n * @returns {Array}         - The string's segments.\n */\n\n\nfunction segments(k, string) {\n  var l = string.length,\n      m = k + 1,\n      a = l / m | 0,\n      b = a + 1,\n      o,\n      i,\n      j;\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n  var S = new Array(k + 1);\n\n  for (i = 0; i < smallSegments; i++) {\n    o = i * a;\n    S[i] = string.slice(o, o + a);\n  }\n\n  var offset = (i - 1) * a + a;\n\n  for (j = 0; j < largeSegments; j++) {\n    o = offset + j * b;\n    S[i + j] = string.slice(o, o + b);\n  }\n\n  return S;\n} // TODO: jsdocs\n\n\nfunction segmentPos(k, i, string) {\n  if (i === 0) return 0;\n  var l = string.length;\n  var m = k + 1,\n      a = l / m | 0,\n      b = a + 1;\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n  if (i <= smallSegments - 1) return i * a;\n  var offset = i - smallSegments;\n  return smallSegments * a + offset * b;\n}\n/**\n * Function returning the interval of relevant substrings to lookup using the\n * multi-match-aware substring selection scheme described in the paper.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {number} delta  - Signed length difference between both considered strings.\n * @param   {number} i      - k + 1 segment index.\n * @param   {number} s      - String's length.\n * @param   {number} pi     - k + 1 segment position in target string.\n * @param   {number} li     - k + 1 segment length.\n * @returns {Array}         - The interval (start, stop).\n */\n\n\nfunction multiMatchAwareInterval(k, delta, i, s, pi, li) {\n  var start1 = pi - i,\n      end1 = pi + i;\n  var o = k - i;\n  var start2 = pi + delta - o,\n      end2 = pi + delta + o;\n  var end3 = s - li;\n  return [Math.max(0, start1, start2), Math.min(end1, end2, end3)];\n}\n/**\n * Function yielding relevant substrings to lookup using the multi-match-aware\n * substring selection scheme described in the paper.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {string} string  - Target string.\n * @param   {number} l      - Length of strings to match.\n * @param   {number} i      - k + 1 segment index.\n * @param   {number} pi     - k + 1 segment position in target string.\n * @param   {number} li     - k + 1 segment length.\n * @returns {Array}         - The contiguous substrings.\n */\n\n\nfunction multiMatchAwareSubstrings(k, string, l, i, pi, li) {\n  var s = string.length; // Note that we need to keep the non-absolute delta for this function\n  // to work in both directions, up & down\n\n  var delta = s - l;\n  var interval = multiMatchAwareInterval(k, delta, i, s, pi, li);\n  var start = interval[0],\n      stop = interval[1];\n  var currentSubstring = '';\n  var substrings = [];\n  var substring, j, m;\n\n  for (j = start, m = stop + 1; j < m; j++) {\n    substring = string.slice(j, j + li); // We skip identical consecutive substrings (to avoid repetition in case\n    // of contiguous letter duplication)\n\n    if (substring === currentSubstring) continue;\n    substrings.push(substring);\n    currentSubstring = substring;\n  }\n\n  return substrings;\n}\n/**\n * PassjoinIndex.\n *\n * @note I tried to apply the paper's optimizations regarding Levenshtein\n * distance computations but it did not provide a performance boost, quite\n * the contrary. This is because since we are mostly using the index for small k\n * here, most of the strings we work on are quite small and the bookkeeping\n * induced by Ukkonen's method and the paper's one are slowing us down more than\n * they actually help us go faster.\n *\n * @note This implementation does not try to ensure that you add the same string\n * more than once.\n *\n * @constructor\n * @param {function} levenshtein - Levenshtein distance function.\n * @param {number}   k           - Levenshtein distance threshold.\n */\n\n\nfunction PassjoinIndex(levenshtein, k) {\n  if (typeof levenshtein !== 'function') throw new Error('mnemonist/passjoin-index: `levenshtein` should be a function returning edit distance between two strings.');\n  if (typeof k !== 'number' || k < 1) throw new Error('mnemonist/passjoin-index: `k` should be a number > 0');\n  this.levenshtein = levenshtein;\n  this.k = k;\n  this.clear();\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nPassjoinIndex.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n  this.strings = [];\n  this.invertedIndices = {};\n};\n/**\n * Method used to add a new value to the index.\n *\n * @param  {string|Array} value - Value to add.\n * @return {PassjoinIndex}\n */\n\n\nPassjoinIndex.prototype.add = function (value) {\n  var l = value.length;\n  var stringIndex = this.size;\n  this.strings.push(value);\n  this.size++;\n  var S = segments(this.k, value);\n  var Ll = this.invertedIndices[l];\n\n  if (typeof Ll === 'undefined') {\n    Ll = {};\n    this.invertedIndices[l] = Ll;\n  }\n\n  var segment, matches, key, i, m;\n\n  for (i = 0, m = S.length; i < m; i++) {\n    segment = S[i];\n    key = segment + i;\n    matches = Ll[key];\n\n    if (typeof matches === 'undefined') {\n      matches = [stringIndex];\n      Ll[key] = matches;\n    } else {\n      matches.push(stringIndex);\n    }\n  }\n\n  return this;\n};\n/**\n * Method used to search for string matching the given query.\n *\n * @param  {string|Array} query - Query string.\n * @return {Array}\n */\n\n\nPassjoinIndex.prototype.search = function (query) {\n  var s = query.length,\n      k = this.k;\n  var M = new Set();\n  var candidates, candidate, queryPos, querySegmentLength, key, S, P, l, m, i, n1, j, n2, y, n3;\n\n  for (l = Math.max(0, s - k), m = s + k + 1; l < m; l++) {\n    var Ll = this.invertedIndices[l];\n    if (typeof Ll === 'undefined') continue;\n    P = partition(k, l);\n\n    for (i = 0, n1 = P.length; i < n1; i++) {\n      queryPos = P[i][0];\n      querySegmentLength = P[i][1];\n      S = multiMatchAwareSubstrings(k, query, l, i, queryPos, querySegmentLength); // Empty string edge case\n\n      if (!S.length) S = [''];\n\n      for (j = 0, n2 = S.length; j < n2; j++) {\n        key = S[j] + i;\n        candidates = Ll[key];\n        if (typeof candidates === 'undefined') continue;\n\n        for (y = 0, n3 = candidates.length; y < n3; y++) {\n          candidate = this.strings[candidates[y]]; // NOTE: first condition is here not to compute Levenshtein\n          // distance for tiny strings\n          // NOTE: maintaining a Set of rejected candidate is not really useful\n          // because it consumes more memory and because non-matches are\n          // less likely to be candidates agains\n\n          if (s <= k && l <= k || !M.has(candidate) && this.levenshtein(query, candidate) <= k) M.add(candidate);\n        }\n      }\n    }\n  }\n\n  return M;\n};\n/**\n * Method used to iterate over the index.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nPassjoinIndex.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0, l = this.strings.length; i < l; i++) callback.call(scope, this.strings[i], i, this);\n};\n/**\n * Method used to create an iterator over a index's values.\n *\n * @return {Iterator}\n */\n\n\nPassjoinIndex.prototype.values = function () {\n  var strings = this.strings,\n      l = strings.length,\n      i = 0;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var value = strings[i];\n    i++;\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') PassjoinIndex.prototype[Symbol.iterator] = PassjoinIndex.prototype.values;\n/**\n * Convenience known methods.\n */\n\nPassjoinIndex.prototype.inspect = function () {\n  var array = this.strings.slice(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(array, 'constructor', {\n    value: PassjoinIndex,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') PassjoinIndex.prototype[Symbol.for('nodejs.util.inspect.custom')] = PassjoinIndex.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {PassjoinIndex}\n */\n\nPassjoinIndex.from = function (iterable, levenshtein, k) {\n  var index = new PassjoinIndex(levenshtein, k);\n  forEach(iterable, function (string) {\n    index.add(string);\n  });\n  return index;\n};\n/**\n * Exporting.\n */\n\n\nPassjoinIndex.countKeys = countKeys;\nPassjoinIndex.comparator = comparator;\nPassjoinIndex.partition = partition;\nPassjoinIndex.segments = segments;\nPassjoinIndex.segmentPos = segmentPos;\nPassjoinIndex.multiMatchAwareInterval = multiMatchAwareInterval;\nPassjoinIndex.multiMatchAwareSubstrings = multiMatchAwareSubstrings;\nmodule.exports = PassjoinIndex;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/passjoin-index.js"],"names":["Iterator","require","forEach","countSubstringsL","k","s","l","Math","pow","abs","countKeys","c","m","comparator","a","b","length","partition","i","j","largeSegments","smallSegments","tuples","Array","offset","segments","string","o","S","slice","segmentPos","multiMatchAwareInterval","delta","pi","li","start1","end1","start2","end2","end3","max","min","multiMatchAwareSubstrings","interval","start","stop","currentSubstring","substrings","substring","push","PassjoinIndex","levenshtein","Error","clear","prototype","size","strings","invertedIndices","add","value","stringIndex","Ll","segment","matches","key","search","query","M","Set","candidates","candidate","queryPos","querySegmentLength","P","n1","n2","y","n3","has","callback","scope","arguments","call","values","done","Symbol","iterator","inspect","array","Object","defineProperty","enumerable","for","from","iterable","index","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist PassjoinIndex\n * ========================\n *\n * The PassjoinIndex is an index leveraging the \"passjoin\" algorithm as a mean\n * to index strings for Levenshtein distance queries. It features a complexity\n * related to the Levenshtein query threshold k rather than the number of\n * strings to test (roughly O(k^3)).\n *\n * [References]:\n * Jiang, Yu, Dong Deng, Jiannan Wang, Guoliang Li, et Jianhua Feng.\n * « Efficient Parallel Partition-Based Algorithms for Similarity Search and Join\n * with Edit Distance Constraints ». In Proceedings of the Joint EDBT/ICDT 2013\n * Workshops on - EDBT ’13, 341. Genoa, Italy: ACM Press, 2013.\n * https://doi.org/10.1145/2457317.2457382.\n *\n * Li, Guoliang, Dong Deng, et Jianhua Feng. « A Partition-Based Method for\n * String Similarity Joins with Edit-Distance Constraints ». ACM Transactions on\n * Database Systems 38, no 2 (1 juin 2013): 1‑33.\n * https://doi.org/10.1145/2487259.2487261.\n *\n * [Urls]:\n * http://people.csail.mit.edu/dongdeng/projects/passjoin/index.html\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach');\n\n// TODO: leveraging BagDistance as an upper bound of Levenshtein\n// TODO: leverage n-grams recursive indexing\n// TODO: try the MultiArray as a memory backend\n// TODO: what about damerau levenshtein\n\n/**\n * Helpers.\n */\n\n/**\n * Function returning the number of substrings that will be selected by the\n * multi-match-aware selection scheme for theshold `k`, for a string of length\n * `s` to match strings of length `l`.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @param   {number} l - Length of strings to match.\n * @returns {number}   - The number of selected substrings.\n */\nfunction countSubstringsL(k, s, l) {\n  return (((Math.pow(k, 2) - Math.pow(Math.abs(s - l), 2)) / 2) | 0) + k + 1;\n}\n\n/**\n * Function returning the minimum number of substrings that will be selected by\n * the multi-match-aware selection scheme for theshold `k`, for a string of\n * length `s` to match any string of relevant length.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @returns {number}   - The number of selected substrings.\n */\nfunction countKeys(k, s) {\n  var c = 0;\n\n  for (var l = 0, m = s + 1; l < m; l++)\n    c += countSubstringsL(k, s, l);\n\n  return c;\n}\n\n/**\n * Function used to compare two keys in order to sort them first by decreasing\n * length and then alphabetically as per the \"4.2 Effective Indexing Strategy\"\n * point of the paper.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} s - Length of target strings.\n * @returns {number}   - The number of selected substrings.\n */\nfunction comparator(a, b) {\n  if (a.length > b.length)\n    return -1;\n  if (a.length < b.length)\n    return 1;\n\n  if (a < b)\n    return -1;\n  if (a > b)\n    return 1;\n\n  return 0;\n}\n\n/**\n * Function partitioning a string into k + 1 uneven segments, the shorter\n * ones, then the longer ones.\n *\n * @param   {number} k - Levenshtein distance threshold.\n * @param   {number} l - Length of the string.\n * @returns {Array}    - The partition tuples (start, length).\n */\nfunction partition(k, l) {\n  var m = k + 1,\n      a = (l / m) | 0,\n      b = a + 1,\n      i,\n      j;\n\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n\n  var tuples = new Array(k + 1);\n\n  for (i = 0; i < smallSegments; i++)\n    tuples[i] = [i * a, a];\n\n  var offset = (i - 1) * a + a;\n\n  for (j = 0; j < largeSegments; j++)\n    tuples[i + j] = [offset + j * b, b];\n\n  return tuples;\n}\n\n/**\n * Function yielding a string's k + 1 passjoin segments to index.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {string} string - Target string.\n * @returns {Array}         - The string's segments.\n */\nfunction segments(k, string) {\n  var l = string.length,\n      m = k + 1,\n      a = (l / m) | 0,\n      b = a + 1,\n      o,\n      i,\n      j;\n\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n\n  var S = new Array(k + 1);\n\n  for (i = 0; i < smallSegments; i++) {\n    o = i * a;\n    S[i] = string.slice(o, o + a);\n  }\n\n  var offset = (i - 1) * a + a;\n\n  for (j = 0; j < largeSegments; j++) {\n    o = offset + j * b;\n    S[i + j] = string.slice(o, o + b);\n  }\n\n  return S;\n}\n\n// TODO: jsdocs\nfunction segmentPos(k, i, string) {\n  if (i === 0)\n    return 0;\n\n  var l = string.length;\n\n  var m = k + 1,\n      a = (l / m) | 0,\n      b = a + 1;\n\n  var largeSegments = l - a * m,\n      smallSegments = m - largeSegments;\n\n  if (i <= smallSegments - 1)\n    return i * a;\n\n  var offset = i - smallSegments;\n\n  return smallSegments * a + offset * b;\n}\n\n/**\n * Function returning the interval of relevant substrings to lookup using the\n * multi-match-aware substring selection scheme described in the paper.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {number} delta  - Signed length difference between both considered strings.\n * @param   {number} i      - k + 1 segment index.\n * @param   {number} s      - String's length.\n * @param   {number} pi     - k + 1 segment position in target string.\n * @param   {number} li     - k + 1 segment length.\n * @returns {Array}         - The interval (start, stop).\n */\nfunction multiMatchAwareInterval(k, delta, i, s, pi, li) {\n  var start1 = pi - i,\n      end1 = pi + i;\n\n  var o = k - i;\n\n  var start2 = pi + delta - o,\n      end2 = pi + delta + o;\n\n  var end3 = s - li;\n\n  return [Math.max(0, start1, start2), Math.min(end1, end2, end3)];\n}\n\n/**\n * Function yielding relevant substrings to lookup using the multi-match-aware\n * substring selection scheme described in the paper.\n *\n * @param   {number} k      - Levenshtein distance threshold.\n * @param   {string} string  - Target string.\n * @param   {number} l      - Length of strings to match.\n * @param   {number} i      - k + 1 segment index.\n * @param   {number} pi     - k + 1 segment position in target string.\n * @param   {number} li     - k + 1 segment length.\n * @returns {Array}         - The contiguous substrings.\n */\nfunction multiMatchAwareSubstrings(k, string, l, i, pi, li) {\n  var s = string.length;\n\n  // Note that we need to keep the non-absolute delta for this function\n  // to work in both directions, up & down\n  var delta = s - l;\n\n  var interval = multiMatchAwareInterval(k, delta, i, s, pi, li);\n\n  var start = interval[0],\n      stop = interval[1];\n\n  var currentSubstring = '';\n\n  var substrings = [];\n\n  var substring, j, m;\n\n  for (j = start, m = stop + 1; j < m; j++) {\n    substring = string.slice(j, j + li);\n\n    // We skip identical consecutive substrings (to avoid repetition in case\n    // of contiguous letter duplication)\n    if (substring === currentSubstring)\n      continue;\n\n    substrings.push(substring);\n\n    currentSubstring = substring;\n  }\n\n  return substrings;\n}\n\n/**\n * PassjoinIndex.\n *\n * @note I tried to apply the paper's optimizations regarding Levenshtein\n * distance computations but it did not provide a performance boost, quite\n * the contrary. This is because since we are mostly using the index for small k\n * here, most of the strings we work on are quite small and the bookkeeping\n * induced by Ukkonen's method and the paper's one are slowing us down more than\n * they actually help us go faster.\n *\n * @note This implementation does not try to ensure that you add the same string\n * more than once.\n *\n * @constructor\n * @param {function} levenshtein - Levenshtein distance function.\n * @param {number}   k           - Levenshtein distance threshold.\n */\nfunction PassjoinIndex(levenshtein, k) {\n  if (typeof levenshtein !== 'function')\n    throw new Error('mnemonist/passjoin-index: `levenshtein` should be a function returning edit distance between two strings.');\n\n  if (typeof k !== 'number' || k < 1)\n    throw new Error('mnemonist/passjoin-index: `k` should be a number > 0');\n\n  this.levenshtein = levenshtein;\n  this.k = k;\n  this.clear();\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nPassjoinIndex.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n  this.strings = [];\n  this.invertedIndices = {};\n};\n\n/**\n * Method used to add a new value to the index.\n *\n * @param  {string|Array} value - Value to add.\n * @return {PassjoinIndex}\n */\nPassjoinIndex.prototype.add = function(value) {\n  var l = value.length;\n\n  var stringIndex = this.size;\n\n  this.strings.push(value);\n  this.size++;\n\n  var S = segments(this.k, value);\n\n  var Ll = this.invertedIndices[l];\n\n  if (typeof Ll === 'undefined') {\n    Ll = {};\n    this.invertedIndices[l] = Ll;\n  }\n\n  var segment,\n      matches,\n      key,\n      i,\n      m;\n\n  for (i = 0, m = S.length; i < m; i++) {\n    segment = S[i];\n    key = segment + i;\n    matches = Ll[key];\n\n    if (typeof matches === 'undefined') {\n      matches = [stringIndex];\n      Ll[key] = matches;\n    }\n    else {\n      matches.push(stringIndex);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Method used to search for string matching the given query.\n *\n * @param  {string|Array} query - Query string.\n * @return {Array}\n */\nPassjoinIndex.prototype.search = function(query) {\n  var s = query.length,\n      k = this.k;\n\n  var M = new Set();\n\n  var candidates,\n      candidate,\n      queryPos,\n      querySegmentLength,\n      key,\n      S,\n      P,\n      l,\n      m,\n      i,\n      n1,\n      j,\n      n2,\n      y,\n      n3;\n\n  for (l = Math.max(0, s - k), m = s + k + 1; l < m; l++) {\n    var Ll = this.invertedIndices[l];\n\n    if (typeof Ll === 'undefined')\n      continue;\n\n    P = partition(k, l);\n\n    for (i = 0, n1 = P.length; i < n1; i++) {\n      queryPos = P[i][0];\n      querySegmentLength = P[i][1];\n\n      S = multiMatchAwareSubstrings(\n        k,\n        query,\n        l,\n        i,\n        queryPos,\n        querySegmentLength\n      );\n\n      // Empty string edge case\n      if (!S.length)\n        S = [''];\n\n      for (j = 0, n2 = S.length; j < n2; j++) {\n        key = S[j] + i;\n        candidates = Ll[key];\n\n        if (typeof candidates === 'undefined')\n          continue;\n\n        for (y = 0, n3 = candidates.length; y < n3; y++) {\n          candidate = this.strings[candidates[y]];\n\n          // NOTE: first condition is here not to compute Levenshtein\n          // distance for tiny strings\n\n          // NOTE: maintaining a Set of rejected candidate is not really useful\n          // because it consumes more memory and because non-matches are\n          // less likely to be candidates agains\n          if (\n            s <= k && l <= k ||\n            (\n              !M.has(candidate) &&\n              this.levenshtein(query, candidate) <= k\n            )\n          )\n            M.add(candidate);\n        }\n      }\n    }\n  }\n\n  return M;\n};\n\n/**\n * Method used to iterate over the index.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nPassjoinIndex.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0, l = this.strings.length; i < l; i++)\n    callback.call(scope, this.strings[i], i, this);\n};\n\n/**\n * Method used to create an iterator over a index's values.\n *\n * @return {Iterator}\n */\nPassjoinIndex.prototype.values = function() {\n  var strings = this.strings,\n      l = strings.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n    var value = strings[i];\n    i++;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  PassjoinIndex.prototype[Symbol.iterator] = PassjoinIndex.prototype.values;\n\n/**\n * Convenience known methods.\n */\nPassjoinIndex.prototype.inspect = function() {\n  var array = this.strings.slice();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: PassjoinIndex,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  PassjoinIndex.prototype[Symbol.for('nodejs.util.inspect.custom')] = PassjoinIndex.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {PassjoinIndex}\n */\nPassjoinIndex.from = function(iterable, levenshtein, k) {\n  var index = new PassjoinIndex(levenshtein, k);\n\n  forEach(iterable, function(string) {\n    index.add(string);\n  });\n\n  return index;\n};\n\n/**\n * Exporting.\n */\nPassjoinIndex.countKeys = countKeys;\nPassjoinIndex.comparator = comparator;\nPassjoinIndex.partition = partition;\nPassjoinIndex.segments = segments;\nPassjoinIndex.segmentPos = segmentPos;\nPassjoinIndex.multiMatchAwareInterval = multiMatchAwareInterval;\nPassjoinIndex.multiMatchAwareSubstrings = multiMatchAwareSubstrings;\n\nmodule.exports = PassjoinIndex;\n"]},"metadata":{},"sourceType":"script"}