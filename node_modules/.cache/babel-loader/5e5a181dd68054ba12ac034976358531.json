{"ast":null,"code":"import _regeneratorRuntime from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Pair } from '@uniswap/v2-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport var V2PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of V2PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  function V2PoolProvider(chainId, multicall2Provider) {\n    var retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n\n    _classCallCheck(this, V2PoolProvider);\n\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions; // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n\n    this.POOL_ADDRESS_CACHE = {};\n  }\n\n  _createClass(V2PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n\n        var poolAddressSet, sortedTokenPairs, sortedPoolAddresses, _iterator, _step, tokenPair, _tokenPair, tokenA, tokenB, _this$getPoolAddress2, _poolAddress, _token3, _token4, reservesResults, poolAddressToPool, invalidPools, i, reservesResult, _sortedTokenPairs$i, _token, _token2, _sortedTokenPairs$i2, token0, token1, _reservesResult$resul, reserve0, reserve1, pool, poolAddress, poolStrs;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                sortedTokenPairs = [];\n                sortedPoolAddresses = [];\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 4;\n\n                _iterator.s();\n\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 17;\n                  break;\n                }\n\n                tokenPair = _step.value;\n                _tokenPair = _slicedToArray(tokenPair, 2), tokenA = _tokenPair[0], tokenB = _tokenPair[1];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB), _poolAddress = _this$getPoolAddress2.poolAddress, _token3 = _this$getPoolAddress2.token0, _token4 = _this$getPoolAddress2.token1;\n\n                if (!poolAddressSet.has(_poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 15);\n\n              case 12:\n                poolAddressSet.add(_poolAddress);\n                sortedTokenPairs.push([_token3, _token4]);\n                sortedPoolAddresses.push(_poolAddress);\n\n              case 15:\n                _context.next = 6;\n                break;\n\n              case 17:\n                _context.next = 22;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](4);\n\n                _iterator.e(_context.t0);\n\n              case 22:\n                _context.prev = 22;\n\n                _iterator.f();\n\n                return _context.finish(22);\n\n              case 25:\n                log.debug(\"getPools called with \".concat(tokenPairs.length, \" token pairs. Deduped down to \").concat(poolAddressSet.size));\n                _context.next = 28;\n                return this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n\n              case 28:\n                reservesResults = _context.sent;\n                _context.t1 = log;\n                _context.t2 = \"Got reserves for \".concat(poolAddressSet.size, \" pools \");\n\n                if (!(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)) {\n                  _context.next = 39;\n                  break;\n                }\n\n                _context.t4 = \"as of block: \";\n                _context.next = 35;\n                return providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber;\n\n              case 35:\n                _context.t5 = _context.sent;\n                _context.t3 = _context.t4.concat.call(_context.t4, _context.t5, \".\");\n                _context.next = 40;\n                break;\n\n              case 39:\n                _context.t3 = \"\";\n\n              case 40:\n                _context.t6 = _context.t3;\n                _context.t7 = _context.t2.concat.call(_context.t2, _context.t6);\n\n                _context.t1.info.call(_context.t1, _context.t7);\n\n                poolAddressToPool = {};\n                invalidPools = [];\n                i = 0;\n\n              case 46:\n                if (!(i < sortedPoolAddresses.length)) {\n                  _context.next = 60;\n                  break;\n                }\n\n                reservesResult = reservesResults[i];\n\n                if (reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success) {\n                  _context.next = 52;\n                  break;\n                }\n\n                _sortedTokenPairs$i = _slicedToArray(sortedTokenPairs[i], 2), _token = _sortedTokenPairs$i[0], _token2 = _sortedTokenPairs$i[1];\n                invalidPools.push([_token, _token2]);\n                return _context.abrupt(\"continue\", 57);\n\n              case 52:\n                _sortedTokenPairs$i2 = _slicedToArray(sortedTokenPairs[i], 2), token0 = _sortedTokenPairs$i2[0], token1 = _sortedTokenPairs$i2[1];\n                _reservesResult$resul = reservesResult.result, reserve0 = _reservesResult$resul.reserve0, reserve1 = _reservesResult$resul.reserve1;\n                pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n                poolAddress = sortedPoolAddresses[i];\n                poolAddressToPool[poolAddress] = pool;\n\n              case 57:\n                i++;\n                _context.next = 46;\n                break;\n\n              case 60:\n                if (invalidPools.length > 0) {\n                  log.info({\n                    invalidPools: _.map(invalidPools, function (_ref) {\n                      var _ref2 = _slicedToArray(_ref, 2),\n                          token0 = _ref2[0],\n                          token1 = _ref2[1];\n\n                      return \"\".concat(token0.symbol, \"/\").concat(token1.symbol);\n                    })\n                  }, \"\".concat(invalidPools.length, \" pools invalid after checking their slot0 and liquidity results. Dropping.\"));\n                }\n\n                poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n                log.debug({\n                  poolStrs: poolStrs\n                }, \"Found \".concat(poolStrs.length, \" valid pools\"));\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB),\n                        poolAddress = _this$getPoolAddress.poolAddress;\n\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n\n              case 64:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 19, 22, 25]]);\n      }));\n\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB) {\n      var _ref3 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n          _ref4 = _slicedToArray(_ref3, 2),\n          token0 = _ref4[0],\n          token1 = _ref4[1];\n\n      var cacheKey = \"\".concat(this.chainId, \"/\").concat(token0.address, \"/\").concat(token1.address);\n      var cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n\n      if (cachedAddress) {\n        return {\n          poolAddress: cachedAddress,\n          token0: token0,\n          token1: token1\n        };\n      }\n\n      var poolAddress = Pair.getAddress(token0, token1);\n      this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n      return {\n        poolAddress: poolAddress,\n        token0: token0,\n        token1: token1\n      };\n    }\n  }, {\n    key: \"getPoolsData\",\n    value: function () {\n      var _getPoolsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(poolAddresses, functionName, providerConfig) {\n        var _this2 = this;\n\n        var _yield$retry, results, blockNumber;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return retry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          return _context2.abrupt(\"return\", _this2.multicall2Provider.callSameFunctionOnMultipleContracts({\n                            addresses: poolAddresses,\n                            contractInterface: IUniswapV2Pair__factory.createInterface(),\n                            functionName: functionName,\n                            providerConfig: providerConfig\n                          }));\n\n                        case 1:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })), this.retryOptions);\n\n              case 2:\n                _yield$retry = _context3.sent;\n                results = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                log.debug(\"Pool data fetched as of block \".concat(blockNumber));\n                return _context3.abrupt(\"return\", results);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getPoolsData(_x3, _x4, _x5) {\n        return _getPoolsData.apply(this, arguments);\n      }\n\n      return getPoolsData;\n    }()\n  }]);\n\n  return V2PoolProvider;\n}();","map":{"version":3,"sources":["../../../../../src/providers/v2/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Pair } from '@uniswap/v2-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n    /**\n     * Creates an instance of V2PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (let tokenPair of tokenPairs) {\n            const [tokenA, tokenB] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n        log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const reservesResult = reservesResults[i];\n            if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n                const [token0, token1] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1]);\n                continue;\n            }\n            const [token0, token1] = sortedTokenPairs[i];\n            const { reserve0, reserve1 } = reservesResult.result;\n            const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = Pair.getAddress(token0, token1);\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV2Pair__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjIvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUF5QixPQUFPLElBQUksS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXRFLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RCxPQUFPLEVBQVcsY0FBYyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFrRGpELE1BQU0sT0FBTyxjQUFjO0lBS3pCOzs7OztPQUtHO0lBQ0gsWUFDWSxPQUFnQixFQUNoQixrQkFBc0MsRUFDdEMsZUFBbUM7UUFDM0MsT0FBTyxFQUFFLENBQUM7UUFDVixVQUFVLEVBQUUsRUFBRTtRQUNkLFVBQVUsRUFBRSxHQUFHO0tBQ2hCO1FBTlMsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQUNoQix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO1FBQ3RDLGlCQUFZLEdBQVosWUFBWSxDQUlyQjtRQWpCSCx5RUFBeUU7UUFDekUsa0RBQWtEO1FBQzFDLHVCQUFrQixHQUE4QixFQUFFLENBQUM7SUFnQnhELENBQUM7SUFFRyxLQUFLLENBQUMsUUFBUSxDQUNuQixVQUE0QixFQUM1QixjQUErQjtRQUUvQixNQUFNLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUN0RCxNQUFNLGdCQUFnQixHQUEwQixFQUFFLENBQUM7UUFDbkQsTUFBTSxtQkFBbUIsR0FBYSxFQUFFLENBQUM7UUFFekMsS0FBSyxJ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"]},"metadata":{},"sourceType":"module"}