{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$();\n\nimport { useMemo } from 'react';\nimport { useAppSelector } from 'state/hooks';\nimport sortByListPriority from 'utils/listSort';\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json';\nimport UNSUPPORTED_TOKEN_LIST from '../../constants/tokenLists/unsupported.tokenlist.json';\nimport { UNSUPPORTED_LIST_URLS } from './../../constants/lists';\nimport { WrappedTokenInfo } from './wrappedTokenInfo';\nconst listCache = typeof WeakMap !== 'undefined' ? new WeakMap() : null;\n\nfunction listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    var _tokenMap$token$chain;\n\n    const token = new WrappedTokenInfo(tokenInfo, list);\n\n    if (((_tokenMap$token$chain = tokenMap[token.chainId]) === null || _tokenMap$token$chain === void 0 ? void 0 : _tokenMap$token$chain[token.address]) !== undefined) {\n      console.error(`Duplicate token! ${token.address}`);\n      return tokenMap;\n    }\n\n    if (!tokenMap[token.chainId]) tokenMap[token.chainId] = {};\n    tokenMap[token.chainId][token.address] = {\n      token,\n      list\n    };\n    return tokenMap;\n  }, {});\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\n\nexport function useAllLists() {\n  _s();\n\n  return useAppSelector(state => state.lists.byUrl);\n}\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\n\n_s(useAllLists, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function combineMaps(map1, map2) {\n  const chainIds = Object.keys(Object.keys(map1).concat(Object.keys(map2)).reduce((memo, value) => {\n    memo[value] = true;\n    return memo;\n  }, {})).map(id => parseInt(id));\n  return chainIds.reduce((memo, chainId) => {\n    memo[chainId] = { ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId]\n    };\n    return memo;\n  }, {});\n} // merge tokens contained within lists from urls\n\nfunction useCombinedTokenMapFromUrls(urls) {\n  _s2();\n\n  const lists = useAllLists();\n  return useMemo(() => {\n    if (!urls) return {};\n    return urls.slice() // sort by priority so top priority goes last\n    .sort(sortByListPriority).reduce((allTokens, currentUrl) => {\n      var _lists$currentUrl;\n\n      const current = (_lists$currentUrl = lists[currentUrl]) === null || _lists$currentUrl === void 0 ? void 0 : _lists$currentUrl.current;\n      if (!current) return allTokens;\n\n      try {\n        return combineMaps(allTokens, listToTokenMap(current));\n      } catch (error) {\n        console.error('Could not show token list due to error', error);\n        return allTokens;\n      }\n    }, {});\n  }, [lists, urls]);\n} // filter out unsupported lists\n\n\n_s2(useCombinedTokenMapFromUrls, \"dehXRrnFU9pff84Mq4UWf/sQUEg=\", false, function () {\n  return [useAllLists];\n});\n\nexport function useActiveListUrls() {\n  _s3();\n\n  const activeListUrls = useAppSelector(state => state.lists.activeListUrls);\n  return useMemo(() => activeListUrls === null || activeListUrls === void 0 ? void 0 : activeListUrls.filter(url => !UNSUPPORTED_LIST_URLS.includes(url)), [activeListUrls]);\n}\n\n_s3(useActiveListUrls, \"h0afKHMCE7LzZ5wU6T20BowXwYI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function useInactiveListUrls() {\n  _s4();\n\n  const lists = useAllLists();\n  const allActiveListUrls = useActiveListUrls();\n  return useMemo(() => Object.keys(lists).filter(url => !(allActiveListUrls === null || allActiveListUrls === void 0 ? void 0 : allActiveListUrls.includes(url)) && !UNSUPPORTED_LIST_URLS.includes(url)), [lists, allActiveListUrls]);\n} // get all the tokens from active lists, combine with local default tokens\n\n_s4(useInactiveListUrls, \"8FfcjEWymS1xtmXbE2at+a+kB0o=\", false, function () {\n  return [useAllLists, useActiveListUrls];\n});\n\nexport function useCombinedActiveList() {\n  _s5();\n\n  const activeListUrls = useActiveListUrls();\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls);\n  return activeTokens;\n} // list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\n\n_s5(useCombinedActiveList, \"QZotrOQv4eqlrVbyAJUYHF4JEV4=\", false, function () {\n  return [useActiveListUrls, useCombinedTokenMapFromUrls];\n});\n\nexport function useUnsupportedTokenList() {\n  _s6();\n\n  // get hard-coded broken tokens\n  const brokenListMap = useMemo(() => listToTokenMap(BROKEN_LIST), []); // get hard-coded list of unsupported tokens\n\n  const localUnsupportedListMap = useMemo(() => listToTokenMap(UNSUPPORTED_TOKEN_LIST), []); // get dynamic list of unsupported tokens\n\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS); // format into one token address map\n\n  return useMemo(() => combineMaps(brokenListMap, combineMaps(localUnsupportedListMap, loadedUnsupportedListMap)), [brokenListMap, localUnsupportedListMap, loadedUnsupportedListMap]);\n}\n\n_s6(useUnsupportedTokenList, \"uF5V0jlg2XjJoCVOhQgRxti8dgI=\", false, function () {\n  return [useCombinedTokenMapFromUrls];\n});\n\nexport function useIsListActive(url) {\n  _s7();\n\n  const activeListUrls = useActiveListUrls();\n  return Boolean(activeListUrls === null || activeListUrls === void 0 ? void 0 : activeListUrls.includes(url));\n}\n\n_s7(useIsListActive, \"OzLukTCRH8SDpmsIh1vZXvu7OrM=\", false, function () {\n  return [useActiveListUrls];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/lists/hooks.ts"],"names":["useMemo","useAppSelector","sortByListPriority","BROKEN_LIST","UNSUPPORTED_TOKEN_LIST","UNSUPPORTED_LIST_URLS","WrappedTokenInfo","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tokenInfo","token","chainId","address","undefined","console","error","set","useAllLists","state","lists","byUrl","combineMaps","map1","map2","chainIds","Object","keys","concat","memo","value","id","parseInt","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","useActiveListUrls","activeListUrls","filter","url","includes","useInactiveListUrls","allActiveListUrls","useCombinedActiveList","activeTokens","useUnsupportedTokenList","brokenListMap","localUnsupportedListMap","loadedUnsupportedListMap","useIsListActive","Boolean"],"mappings":"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","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport { useMemo } from 'react'\nimport { useAppSelector } from 'state/hooks'\nimport sortByListPriority from 'utils/listSort'\n\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json'\nimport UNSUPPORTED_TOKEN_LIST from '../../constants/tokenLists/unsupported.tokenlist.json'\nimport { AppState } from '../index'\nimport { UNSUPPORTED_LIST_URLS } from './../../constants/lists'\nimport { WrappedTokenInfo } from './wrappedTokenInfo'\n\nexport type TokenAddressMap = Readonly<{\n  [chainId: number]: Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list: TokenList } }>\n}>\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: Mutable<T[P]>\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nfunction listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n  if (result) return result\n\n  const map = list.tokens.reduce<Mutable<TokenAddressMap>>((tokenMap, tokenInfo) => {\n    const token = new WrappedTokenInfo(tokenInfo, list)\n    if (tokenMap[token.chainId]?.[token.address] !== undefined) {\n      console.error(`Duplicate token! ${token.address}`)\n      return tokenMap\n    }\n    if (!tokenMap[token.chainId]) tokenMap[token.chainId] = {}\n    tokenMap[token.chainId][token.address] = {\n      token,\n      list,\n    }\n    return tokenMap\n  }, {}) as TokenAddressMap\n  listCache?.set(list, map)\n  return map\n}\n\nexport function useAllLists(): AppState['lists']['byUrl'] {\n  return useAppSelector((state) => state.lists.byUrl)\n}\n\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\nexport function combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\n  const chainIds = Object.keys(\n    Object.keys(map1)\n      .concat(Object.keys(map2))\n      .reduce<{ [chainId: string]: true }>((memo, value) => {\n        memo[value] = true\n        return memo\n      }, {})\n  ).map((id) => parseInt(id))\n\n  return chainIds.reduce<Mutable<TokenAddressMap>>((memo, chainId) => {\n    memo[chainId] = {\n      ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId],\n    }\n    return memo\n  }, {}) as TokenAddressMap\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\n  const lists = useAllLists()\n  return useMemo(() => {\n    if (!urls) return {}\n    return (\n      urls\n        .slice()\n        // sort by priority so top priority goes last\n        .sort(sortByListPriority)\n        .reduce((allTokens, currentUrl) => {\n          const current = lists[currentUrl]?.current\n          if (!current) return allTokens\n          try {\n            return combineMaps(allTokens, listToTokenMap(current))\n          } catch (error) {\n            console.error('Could not show token list due to error', error)\n            return allTokens\n          }\n        }, {})\n    )\n  }, [lists, urls])\n}\n\n// filter out unsupported lists\nexport function useActiveListUrls(): string[] | undefined {\n  const activeListUrls = useAppSelector((state) => state.lists.activeListUrls)\n  return useMemo(() => activeListUrls?.filter((url) => !UNSUPPORTED_LIST_URLS.includes(url)), [activeListUrls])\n}\n\nexport function useInactiveListUrls(): string[] {\n  const lists = useAllLists()\n  const allActiveListUrls = useActiveListUrls()\n  return useMemo(\n    () => Object.keys(lists).filter((url) => !allActiveListUrls?.includes(url) && !UNSUPPORTED_LIST_URLS.includes(url)),\n    [lists, allActiveListUrls]\n  )\n}\n\n// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(): TokenAddressMap {\n  const activeListUrls = useActiveListUrls()\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls)\n  return activeTokens\n}\n\n// list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(): TokenAddressMap {\n  // get hard-coded broken tokens\n  const brokenListMap = useMemo(() => listToTokenMap(BROKEN_LIST), [])\n\n  // get hard-coded list of unsupported tokens\n  const localUnsupportedListMap = useMemo(() => listToTokenMap(UNSUPPORTED_TOKEN_LIST), [])\n\n  // get dynamic list of unsupported tokens\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS)\n\n  // format into one token address map\n  return useMemo(\n    () => combineMaps(brokenListMap, combineMaps(localUnsupportedListMap, loadedUnsupportedListMap)),\n    [brokenListMap, localUnsupportedListMap, loadedUnsupportedListMap]\n  )\n}\nexport function useIsListActive(url: string): boolean {\n  const activeListUrls = useActiveListUrls()\n  return Boolean(activeListUrls?.includes(url))\n}\n"]},"metadata":{},"sourceType":"module"}