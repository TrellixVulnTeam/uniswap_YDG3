{"ast":null,"code":"function wait(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction waitRandom(min, max) {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)));\n}\n/**\n * This error is thrown if the function is cancelled before completing\n */\n\n\nclass CancelledError extends Error {\n  constructor() {\n    super('Cancelled');\n    this.isCancelledError = true;\n  }\n\n}\n/**\n * Throw this error if the function should retry\n */\n\n\nexport class RetryableError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.isRetryableError = true;\n  }\n\n}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry(fn, {\n  n,\n  minWait,\n  maxWait\n}) {\n  let completed = false;\n  let rejectCancelled;\n  const promise = new Promise(async (resolve, reject) => {\n    rejectCancelled = reject;\n\n    while (true) {\n      let result;\n\n      try {\n        result = await fn();\n\n        if (!completed) {\n          resolve(result);\n          completed = true;\n        }\n\n        break;\n      } catch (error) {\n        if (completed) {\n          break;\n        }\n\n        if (n <= 0 || !error.isRetryableError) {\n          reject(error);\n          completed = true;\n          break;\n        }\n\n        n--;\n      }\n\n      await waitRandom(minWait, maxWait);\n    }\n  });\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return;\n      completed = true;\n      rejectCancelled(new CancelledError());\n    }\n  };\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/utils/retry.ts"],"names":["wait","ms","Promise","resolve","setTimeout","waitRandom","min","max","Math","round","random","CancelledError","Error","constructor","isCancelledError","RetryableError","isRetryableError","retry","fn","n","minWait","maxWait","completed","rejectCancelled","promise","reject","result","error","cancel"],"mappings":"AAAA,SAASA,IAAT,CAAcC,EAAd,EAAyC;AACvC,SAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAaC,UAAU,CAACD,OAAD,EAAUF,EAAV,CAAnC,CAAP;AACD;;AAED,SAASI,UAAT,CAAoBC,GAApB,EAAiCC,GAAjC,EAA6D;AAC3D,SAAOP,IAAI,CAACM,GAAG,GAAGE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBF,IAAI,CAACD,GAAL,CAAS,CAAT,EAAYA,GAAG,GAAGD,GAAlB,CAA3B,CAAP,CAAX;AACD;AAED;AACA;AACA;;;AACA,MAAMK,cAAN,SAA6BC,KAA7B,CAAmC;AAEjCC,EAAAA,WAAW,GAAG;AACZ,UAAM,WAAN;AADY,SADPC,gBACO,GADkB,IAClB;AAEb;;AAJgC;AAOnC;AACA;AACA;;;AACA,OAAO,MAAMC,cAAN,SAA6BH,KAA7B,CAAmC;AAAA;AAAA;AAAA,SACjCI,gBADiC,GACR,IADQ;AAAA;;AAAA;;AAU1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,KAAT,CACLC,EADK,EAEL;AAAEC,EAAAA,CAAF;AAAKC,EAAAA,OAAL;AAAcC,EAAAA;AAAd,CAFK,EAGwC;AAC7C,MAAIC,SAAS,GAAG,KAAhB;AACA,MAAIC,eAAJ;AACA,QAAMC,OAAO,GAAG,IAAItB,OAAJ,CAAe,OAAOC,OAAP,EAAgBsB,MAAhB,KAA2B;AACxDF,IAAAA,eAAe,GAAGE,MAAlB;;AACA,WAAO,IAAP,EAAa;AACX,UAAIC,MAAJ;;AACA,UAAI;AACFA,QAAAA,MAAM,GAAG,MAAMR,EAAE,EAAjB;;AACA,YAAI,CAACI,SAAL,EAAgB;AACdnB,UAAAA,OAAO,CAACuB,MAAD,CAAP;AACAJ,UAAAA,SAAS,GAAG,IAAZ;AACD;;AACD;AACD,OAPD,CAOE,OAAOK,KAAP,EAAc;AACd,YAAIL,SAAJ,EAAe;AACb;AACD;;AACD,YAAIH,CAAC,IAAI,CAAL,IAAU,CAACQ,KAAK,CAACX,gBAArB,EAAuC;AACrCS,UAAAA,MAAM,CAACE,KAAD,CAAN;AACAL,UAAAA,SAAS,GAAG,IAAZ;AACA;AACD;;AACDH,QAAAA,CAAC;AACF;;AACD,YAAMd,UAAU,CAACe,OAAD,EAAUC,OAAV,CAAhB;AACD;AACF,GAxBe,CAAhB;AAyBA,SAAO;AACLG,IAAAA,OADK;AAELI,IAAAA,MAAM,EAAE,MAAM;AACZ,UAAIN,SAAJ,EAAe;AACfA,MAAAA,SAAS,GAAG,IAAZ;AACAC,MAAAA,eAAe,CAAC,IAAIZ,cAAJ,EAAD,CAAf;AACD;AANI,GAAP;AAQD","sourcesContent":["function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction waitRandom(min: number, max: number): Promise<void> {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nclass CancelledError extends Error {\n  public isCancelledError: true = true\n  constructor() {\n    super('Cancelled')\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {\n  public isRetryableError: true = true\n}\n\nexport interface RetryOptions {\n  n: number\n  minWait: number\n  maxWait: number\n}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry<T>(\n  fn: () => Promise<T>,\n  { n, minWait, maxWait }: RetryOptions\n): { promise: Promise<T>; cancel: () => void } {\n  let completed = false\n  let rejectCancelled: (error: Error) => void\n  const promise = new Promise<T>(async (resolve, reject) => {\n    rejectCancelled = reject\n    while (true) {\n      let result: T\n      try {\n        result = await fn()\n        if (!completed) {\n          resolve(result)\n          completed = true\n        }\n        break\n      } catch (error) {\n        if (completed) {\n          break\n        }\n        if (n <= 0 || !error.isRetryableError) {\n          reject(error)\n          completed = true\n          break\n        }\n        n--\n      }\n      await waitRandom(minWait, maxWait)\n    }\n  })\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return\n      completed = true\n      rejectCancelled(new CancelledError())\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}