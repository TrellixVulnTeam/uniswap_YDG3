{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$();\n\nimport { arrayify } from '@ethersproject/bytes';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { Token } from '@uniswap/sdk-core';\nimport { CHAIN_INFO, L2_CHAIN_IDS, SupportedChainId } from 'constants/chains';\nimport { useMemo } from 'react';\nimport { createTokenFilterFunction } from '../components/SearchModal/filtering';\nimport { nativeOnChain } from '../constants/tokens';\nimport { useAllLists, useCombinedActiveList, useInactiveListUrls } from '../state/lists/hooks';\nimport { WrappedTokenInfo } from '../state/lists/wrappedTokenInfo';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useUnsupportedTokenList } from './../state/lists/hooks';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { useActiveWeb3React } from './web3'; // reduce token map into standard address <-> Token mapping, optionally include user added tokens\n\nfunction useTokensFromMap(tokenMap, includeUserAdded) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  return useMemo(() => {\n    var _tokenMap$chainId;\n\n    if (!chainId) return {}; // reduce to just tokens\n\n    const mapWithoutUrls = Object.keys((_tokenMap$chainId = tokenMap[chainId]) !== null && _tokenMap$chainId !== void 0 ? _tokenMap$chainId : {}).reduce((newMap, address) => {\n      newMap[address] = tokenMap[chainId][address].token;\n      return newMap;\n    }, {});\n\n    if (includeUserAdded) {\n      return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n      .reduce((tokenMap, token) => {\n        tokenMap[token.address] = token;\n        return tokenMap;\n      }, // must make a copy because reduce modifies the map, and we do not\n      // want to make a copy in every iteration\n      { ...mapWithoutUrls\n      });\n    }\n\n    return mapWithoutUrls;\n  }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n}\n\n_s(useTokensFromMap, \"o7LgZeIx6jncN8Lb8S6zeK0wZEQ=\", false, function () {\n  return [useActiveWeb3React, useUserAddedTokens];\n});\n\nexport function useAllTokens() {\n  _s2();\n\n  const allTokens = useCombinedActiveList();\n  return useTokensFromMap(allTokens, true);\n}\n\n_s2(useAllTokens, \"jCGW4tI4Rs1UGm9shzKA8VnDJ0A=\", false, function () {\n  return [useCombinedActiveList, useTokensFromMap];\n});\n\nexport function useUnsupportedTokens() {\n  _s3();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const listsByUrl = useAllLists();\n  const unsupportedTokensMap = useUnsupportedTokenList();\n  const unsupportedTokens = useTokensFromMap(unsupportedTokensMap, false); // checks the default L2 lists to see if `bridgeInfo` has an L1 address value that is unsupported\n\n  const l2InferredBlockedTokens = useMemo(() => {\n    if (!chainId || !L2_CHAIN_IDS.includes(chainId)) {\n      return {};\n    }\n\n    if (!listsByUrl) {\n      return {};\n    }\n\n    const listUrl = CHAIN_INFO[chainId].defaultListUrl;\n    const {\n      current: list\n    } = listsByUrl[listUrl];\n\n    if (!list) {\n      return {};\n    }\n\n    const unsupportedSet = new Set(Object.keys(unsupportedTokens));\n    return list.tokens.reduce((acc, tokenInfo) => {\n      var _tokenInfo$extensions;\n\n      const bridgeInfo = (_tokenInfo$extensions = tokenInfo.extensions) === null || _tokenInfo$extensions === void 0 ? void 0 : _tokenInfo$extensions.bridgeInfo;\n\n      if (bridgeInfo && bridgeInfo[SupportedChainId.MAINNET] && bridgeInfo[SupportedChainId.MAINNET].tokenAddress && unsupportedSet.has(bridgeInfo[SupportedChainId.MAINNET].tokenAddress)) {\n        const address = bridgeInfo[SupportedChainId.MAINNET].tokenAddress; // don't rely on decimals--it's possible that a token could be bridged w/ different decimals on the L2\n\n        return { ...acc,\n          [address]: new Token(SupportedChainId.MAINNET, address, tokenInfo.decimals)\n        };\n      }\n\n      return acc;\n    }, {});\n  }, [chainId, listsByUrl, unsupportedTokens]);\n  return { ...unsupportedTokens,\n    ...l2InferredBlockedTokens\n  };\n}\n\n_s3(useUnsupportedTokens, \"LUe1Xpbhi0s5FvkFWDc9pjBABEU=\", false, function () {\n  return [useActiveWeb3React, useAllLists, useUnsupportedTokenList, useTokensFromMap];\n});\n\nexport function useSearchInactiveTokenLists(search, minResults = 10) {\n  _s4();\n\n  const lists = useAllLists();\n  const inactiveUrls = useInactiveListUrls();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const activeTokens = useAllTokens();\n  return useMemo(() => {\n    if (!search || search.trim().length === 0) return [];\n    const tokenFilter = createTokenFilterFunction(search);\n    const result = [];\n    const addressSet = {};\n\n    for (const url of inactiveUrls) {\n      const list = lists[url].current;\n      if (!list) continue;\n\n      for (const tokenInfo of list.tokens) {\n        if (tokenInfo.chainId === chainId && tokenFilter(tokenInfo)) {\n          const wrapped = new WrappedTokenInfo(tokenInfo, list);\n\n          if (!(wrapped.address in activeTokens) && !addressSet[wrapped.address]) {\n            addressSet[wrapped.address] = true;\n            result.push(wrapped);\n            if (result.length >= minResults) return result;\n          }\n        }\n      }\n    }\n\n    return result;\n  }, [activeTokens, chainId, inactiveUrls, lists, minResults, search]);\n}\n\n_s4(useSearchInactiveTokenLists, \"YfWHRStdPhHZ60JonRn51FodrT8=\", false, function () {\n  return [useAllLists, useInactiveListUrls, useActiveWeb3React, useAllTokens];\n});\n\nexport function useIsTokenActive(token) {\n  _s5();\n\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n} // Check if currency is included in custom list from user storage\n\n_s5(useIsTokenActive, \"/DZnqUeqi963rU8m84lshLFLG1g=\", false, function () {\n  return [useAllTokens];\n});\n\nexport function useIsUserAddedToken(currency) {\n  _s6();\n\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find(token => currency.equals(token));\n} // parse a name or symbol from a token response\n\n_s6(useIsUserAddedToken, \"/J12HuilTfT8HPlUWn/aslQP0JY=\", false, function () {\n  return [useUserAddedTokens];\n});\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading or null was passed\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  _s7();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (tokenAddress === null) return null;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenAddress, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\n\n_s7(useToken, \"eKyRyOw1MkhB0rg/op393nwat5k=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenContract, useBytes32TokenContract, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult, useSingleCallResult];\n});\n\nexport function useNativeCurrency() {\n  _s8();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  return useMemo(() => chainId ? nativeOnChain(chainId) : // display mainnet when not connected\n  nativeOnChain(SupportedChainId.MAINNET), [chainId]);\n}\n\n_s8(useNativeCurrency, \"MZB4M8cyCV+h94y3JGwcy21BfBk=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useCurrency(currencyId) {\n  _s9();\n\n  var _wrappedNative$addres;\n\n  const nativeCurrency = useNativeCurrency();\n  const isNative = Boolean(nativeCurrency && (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'ETH');\n  const token = useToken(isNative ? undefined : currencyId);\n  if (currencyId === null || currencyId === undefined) return currencyId; // this case so we use our builtin wrapped token instead of wrapped tokens on token lists\n\n  const wrappedNative = nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.wrapped;\n  if ((wrappedNative === null || wrappedNative === void 0 ? void 0 : (_wrappedNative$addres = wrappedNative.address) === null || _wrappedNative$addres === void 0 ? void 0 : _wrappedNative$addres.toUpperCase()) === (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase())) return wrappedNative;\n  return isNative ? nativeCurrency : token;\n}\n\n_s9(useCurrency, \"Nc5kbq9NZ95FKPbw47arzANUC1s=\", false, function () {\n  return [useNativeCurrency, useToken];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/Tokens.ts"],"names":["arrayify","parseBytes32String","Token","CHAIN_INFO","L2_CHAIN_IDS","SupportedChainId","useMemo","createTokenFilterFunction","nativeOnChain","useAllLists","useCombinedActiveList","useInactiveListUrls","WrappedTokenInfo","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useUnsupportedTokenList","useBytes32TokenContract","useTokenContract","useActiveWeb3React","useTokensFromMap","tokenMap","includeUserAdded","chainId","userAddedTokens","mapWithoutUrls","Object","keys","reduce","newMap","address","token","useAllTokens","allTokens","useUnsupportedTokens","listsByUrl","unsupportedTokensMap","unsupportedTokens","l2InferredBlockedTokens","includes","listUrl","defaultListUrl","current","list","unsupportedSet","Set","tokens","acc","tokenInfo","bridgeInfo","extensions","MAINNET","tokenAddress","has","decimals","useSearchInactiveTokenLists","search","minResults","lists","inactiveUrls","activeTokens","trim","length","tokenFilter","result","addressSet","url","wrapped","push","useIsTokenActive","useIsUserAddedToken","currency","find","equals","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","test","useToken","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","loading","useNativeCurrency","useCurrency","currencyId","nativeCurrency","isNative","Boolean","toUpperCase","wrappedNative"],"mappings":"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","sourcesContent":["import { arrayify } from '@ethersproject/bytes'\nimport { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { CHAIN_INFO, L2_CHAIN_IDS, SupportedChainId, SupportedL2ChainId } from 'constants/chains'\nimport { useMemo } from 'react'\n\nimport { createTokenFilterFunction } from '../components/SearchModal/filtering'\nimport { nativeOnChain } from '../constants/tokens'\nimport { useAllLists, useCombinedActiveList, useInactiveListUrls } from '../state/lists/hooks'\nimport { WrappedTokenInfo } from '../state/lists/wrappedTokenInfo'\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\nimport { useUserAddedTokens } from '../state/user/hooks'\nimport { isAddress } from '../utils'\nimport { TokenAddressMap, useUnsupportedTokenList } from './../state/lists/hooks'\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\nimport { useActiveWeb3React } from './web3'\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap: TokenAddressMap, includeUserAdded: boolean): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n\n    // reduce to just tokens\n    const mapWithoutUrls = Object.keys(tokenMap[chainId] ?? {}).reduce<{ [address: string]: Token }>(\n      (newMap, address) => {\n        newMap[address] = tokenMap[chainId][address].token\n        return newMap\n      },\n      {}\n    )\n\n    if (includeUserAdded) {\n      return (\n        userAddedTokens\n          // reduce into all ALL_TOKENS filtered by the current chain\n          .reduce<{ [address: string]: Token }>(\n            (tokenMap, token) => {\n              tokenMap[token.address] = token\n              return tokenMap\n            },\n            // must make a copy because reduce modifies the map, and we do not\n            // want to make a copy in every iteration\n            { ...mapWithoutUrls }\n          )\n      )\n    }\n\n    return mapWithoutUrls\n  }, [chainId, userAddedTokens, tokenMap, includeUserAdded])\n}\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const allTokens = useCombinedActiveList()\n  return useTokensFromMap(allTokens, true)\n}\n\ntype BridgeInfo = Record<\n  SupportedChainId,\n  {\n    tokenAddress: string\n    originBridgeAddress: string\n    destBridgeAddress: string\n  }\n>\n\nexport function useUnsupportedTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const listsByUrl = useAllLists()\n  const unsupportedTokensMap = useUnsupportedTokenList()\n  const unsupportedTokens = useTokensFromMap(unsupportedTokensMap, false)\n\n  // checks the default L2 lists to see if `bridgeInfo` has an L1 address value that is unsupported\n  const l2InferredBlockedTokens: typeof unsupportedTokens = useMemo(() => {\n    if (!chainId || !L2_CHAIN_IDS.includes(chainId)) {\n      return {}\n    }\n\n    if (!listsByUrl) {\n      return {}\n    }\n\n    const listUrl = CHAIN_INFO[chainId as SupportedL2ChainId].defaultListUrl\n    const { current: list } = listsByUrl[listUrl]\n    if (!list) {\n      return {}\n    }\n\n    const unsupportedSet = new Set(Object.keys(unsupportedTokens))\n\n    return list.tokens.reduce((acc, tokenInfo) => {\n      const bridgeInfo = tokenInfo.extensions?.bridgeInfo as unknown as BridgeInfo\n      if (\n        bridgeInfo &&\n        bridgeInfo[SupportedChainId.MAINNET] &&\n        bridgeInfo[SupportedChainId.MAINNET].tokenAddress &&\n        unsupportedSet.has(bridgeInfo[SupportedChainId.MAINNET].tokenAddress)\n      ) {\n        const address = bridgeInfo[SupportedChainId.MAINNET].tokenAddress\n        // don't rely on decimals--it's possible that a token could be bridged w/ different decimals on the L2\n        return { ...acc, [address]: new Token(SupportedChainId.MAINNET, address, tokenInfo.decimals) }\n      }\n      return acc\n    }, {})\n  }, [chainId, listsByUrl, unsupportedTokens])\n\n  return { ...unsupportedTokens, ...l2InferredBlockedTokens }\n}\n\nexport function useSearchInactiveTokenLists(search: string | undefined, minResults = 10): WrappedTokenInfo[] {\n  const lists = useAllLists()\n  const inactiveUrls = useInactiveListUrls()\n  const { chainId } = useActiveWeb3React()\n  const activeTokens = useAllTokens()\n  return useMemo(() => {\n    if (!search || search.trim().length === 0) return []\n    const tokenFilter = createTokenFilterFunction(search)\n    const result: WrappedTokenInfo[] = []\n    const addressSet: { [address: string]: true } = {}\n    for (const url of inactiveUrls) {\n      const list = lists[url].current\n      if (!list) continue\n      for (const tokenInfo of list.tokens) {\n        if (tokenInfo.chainId === chainId && tokenFilter(tokenInfo)) {\n          const wrapped: WrappedTokenInfo = new WrappedTokenInfo(tokenInfo, list)\n          if (!(wrapped.address in activeTokens) && !addressSet[wrapped.address]) {\n            addressSet[wrapped.address] = true\n            result.push(wrapped)\n            if (result.length >= minResults) return result\n          }\n        }\n      }\n    }\n    return result\n  }, [activeTokens, chainId, inactiveUrls, lists, minResults, search])\n}\n\nexport function useIsTokenActive(token: Token | undefined | null): boolean {\n  const activeTokens = useAllTokens()\n\n  if (!activeTokens || !token) {\n    return false\n  }\n\n  return !!activeTokens[token.address]\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency | undefined | null): boolean {\n  const userAddedTokens = useUserAddedTokens()\n\n  if (!currency) {\n    return false\n  }\n\n  return !!userAddedTokens.find((token) => currency.equals(token))\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\n\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\n// undefined if invalid or does not exist\n// null if loading or null was passed\n// otherwise returns the token\nexport function useToken(tokenAddress?: string | null): Token | undefined | null {\n  const { chainId } = useActiveWeb3React()\n  const tokens = useAllTokens()\n\n  const address = isAddress(tokenAddress)\n\n  const tokenContract = useTokenContract(address ? address : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false)\n  const token: Token | undefined = address ? tokens[address] : undefined\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (token) return token\n    if (tokenAddress === null) return null\n    if (!chainId || !address) return undefined\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      )\n    }\n    return undefined\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenAddress,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result,\n  ])\n}\n\nexport function useNativeCurrency(): Currency {\n  const { chainId } = useActiveWeb3React()\n  return useMemo(\n    () =>\n      chainId\n        ? nativeOnChain(chainId)\n        : // display mainnet when not connected\n          nativeOnChain(SupportedChainId.MAINNET),\n    [chainId]\n  )\n}\n\nexport function useCurrency(currencyId: string | null | undefined): Currency | null | undefined {\n  const nativeCurrency = useNativeCurrency()\n  const isNative = Boolean(nativeCurrency && currencyId?.toUpperCase() === 'ETH')\n  const token = useToken(isNative ? undefined : currencyId)\n\n  if (currencyId === null || currencyId === undefined) return currencyId\n\n  // this case so we use our builtin wrapped token instead of wrapped tokens on token lists\n  const wrappedNative = nativeCurrency?.wrapped\n  if (wrappedNative?.address?.toUpperCase() === currencyId?.toUpperCase()) return wrappedNative\n\n  return isNative ? nativeCurrency : token\n}\n"]},"metadata":{},"sourceType":"module"}