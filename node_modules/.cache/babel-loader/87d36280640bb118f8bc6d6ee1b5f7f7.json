{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { useMemo } from 'react';\nimport { WRAPPED_NATIVE_CURRENCY } from '../constants/tokens';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { TransactionType } from '../state/transactions/actions';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useNativeCurrency } from './Tokens';\nimport { useWETHContract } from './useContract';\nimport { useActiveWeb3React } from './web3';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\nvar WrapInputError;\n\n(function (WrapInputError) {\n  WrapInputError[WrapInputError[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n  WrapInputError[WrapInputError[\"ENTER_NATIVE_AMOUNT\"] = 1] = \"ENTER_NATIVE_AMOUNT\";\n  WrapInputError[WrapInputError[\"ENTER_WRAPPED_AMOUNT\"] = 2] = \"ENTER_WRAPPED_AMOUNT\";\n  WrapInputError[WrapInputError[\"INSUFFICIENT_NATIVE_BALANCE\"] = 3] = \"INSUFFICIENT_NATIVE_BALANCE\";\n  WrapInputError[WrapInputError[\"INSUFFICIENT_WRAPPED_BALANCE\"] = 4] = \"INSUFFICIENT_WRAPPED_BALANCE\";\n})(WrapInputError || (WrapInputError = {}));\n\nexport function WrapErrorText({\n  wrapInputError\n}) {\n  _s();\n\n  const native = useNativeCurrency();\n  const wrapped = native === null || native === void 0 ? void 0 : native.wrapped;\n\n  switch (wrapInputError) {\n    case WrapInputError.NO_ERROR:\n      return null;\n\n    case WrapInputError.ENTER_NATIVE_AMOUNT:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter {0} amount\",\n        values: {\n          0: native === null || native === void 0 ? void 0 : native.symbol\n        }\n      }, void 0, false, void 0, this);\n\n    case WrapInputError.ENTER_WRAPPED_AMOUNT:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Enter {0} amount\",\n        values: {\n          0: wrapped === null || wrapped === void 0 ? void 0 : wrapped.symbol\n        }\n      }, void 0, false, void 0, this);\n\n    case WrapInputError.INSUFFICIENT_NATIVE_BALANCE:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Insufficient {0} balance\",\n        values: {\n          0: native === null || native === void 0 ? void 0 : native.symbol\n        }\n      }, void 0, false, void 0, this);\n\n    case WrapInputError.INSUFFICIENT_WRAPPED_BALANCE:\n      return /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Insufficient {0} balance\",\n        values: {\n          0: wrapped === null || wrapped === void 0 ? void 0 : wrapped.symbol\n        }\n      }, void 0, false, void 0, this);\n  }\n}\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\n\n_s(WrapErrorText, \"QsWYL7Ih8CW8sWAfMsAE0MB2Juk=\", false, function () {\n  return [useNativeCurrency];\n});\n\n_c = WrapErrorText;\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  _s2();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const wethContract = useWETHContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n    if (!weth) return NOT_APPLICABLE;\n    const hasInputAmount = Boolean(inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.greaterThan('0'));\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (inputCurrency.isNative && weth.equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.quotient.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              type: TransactionType.WRAP,\n              unwrapped: false,\n              currencyAmountRaw: inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.quotient.toString(),\n              chainId\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : hasInputAmount ? WrapInputError.INSUFFICIENT_NATIVE_BALANCE : WrapInputError.ENTER_NATIVE_AMOUNT\n      };\n    } else if (weth.equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.quotient.toString(16)}`);\n            addTransaction(txReceipt, {\n              type: TransactionType.WRAP,\n              unwrapped: true,\n              currencyAmountRaw: inputAmount === null || inputAmount === void 0 ? void 0 : inputAmount.quotient.toString(),\n              chainId\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : hasInputAmount ? WrapInputError.INSUFFICIENT_WRAPPED_BALANCE : WrapInputError.ENTER_WRAPPED_AMOUNT\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}\n\n_s2(useWrapCallback, \"vntrhns1+yhOf5a8SvIDHA0AeGc=\", false, function () {\n  return [useActiveWeb3React, useWETHContract, useCurrencyBalance, useTransactionAdder];\n});\n\nvar _c;\n\n$RefreshReg$(_c, \"WrapErrorText\");","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useWrapCallback.tsx"],"names":["useMemo","WRAPPED_NATIVE_CURRENCY","tryParseAmount","TransactionType","useTransactionAdder","useCurrencyBalance","useNativeCurrency","useWETHContract","useActiveWeb3React","WrapType","NOT_APPLICABLE","wrapType","WrapInputError","WrapErrorText","wrapInputError","native","wrapped","NO_ERROR","ENTER_NATIVE_AMOUNT","symbol","ENTER_WRAPPED_AMOUNT","INSUFFICIENT_NATIVE_BALANCE","INSUFFICIENT_WRAPPED_BALANCE","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","weth","hasInputAmount","Boolean","greaterThan","sufficientBalance","lessThan","isNative","equals","WRAP","execute","txReceipt","deposit","value","quotient","toString","type","unwrapped","currencyAmountRaw","error","console","inputError","UNWRAP","withdraw"],"mappings":";;;;AAEA,SAASA,OAAT,QAAwB,OAAxB;AAEA,SAASC,uBAAT,QAAwC,qBAAxC;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SAASC,eAAT,QAAgC,+BAAhC;AACA,SAASC,mBAAT,QAAoC,6BAApC;AACA,SAASC,kBAAT,QAAmC,uBAAnC;AACA,SAASC,iBAAT,QAAkC,UAAlC;AACA,SAASC,eAAT,QAAgC,eAAhC;AACA,SAASC,kBAAT,QAAmC,QAAnC;;AAEA,WAAYC,QAAZ;;WAAYA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;GAAAA,Q,KAAAA,Q;;AAMZ,MAAMC,cAAc,GAAG;AAAEC,EAAAA,QAAQ,EAAEF,QAAQ,CAACC;AAArB,CAAvB;IAEKE,c;;WAAAA,c;AAAAA,EAAAA,c,CAAAA,c;AAAAA,EAAAA,c,CAAAA,c;AAAAA,EAAAA,c,CAAAA,c;AAAAA,EAAAA,c,CAAAA,c;AAAAA,EAAAA,c,CAAAA,c;GAAAA,c,KAAAA,c;;AAQL,OAAO,SAASC,aAAT,CAAuB;AAAEC,EAAAA;AAAF,CAAvB,EAA+E;AAAA;;AACpF,QAAMC,MAAM,GAAGT,iBAAiB,EAAhC;AACA,QAAMU,OAAO,GAAGD,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEC,OAAxB;;AAEA,UAAQF,cAAR;AACE,SAAKF,cAAc,CAACK,QAApB;AACE,aAAO,IAAP;;AACF,SAAKL,cAAc,CAACM,mBAApB;AACE,0BAAO;AAAA;AAAA;AAAA,aAAcH,MAAd,aAAcA,MAAd,uBAAcA,MAAM,CAAEI;AAAtB;AAAA,qCAAP;;AACF,SAAKP,cAAc,CAACQ,oBAApB;AACE,0BAAO;AAAA;AAAA;AAAA,aAAcJ,OAAd,aAAcA,OAAd,uBAAcA,OAAO,CAAEG;AAAvB;AAAA,qCAAP;;AAEF,SAAKP,cAAc,CAACS,2BAApB;AACE,0BAAO;AAAA;AAAA;AAAA,aAAqBN,MAArB,aAAqBA,MAArB,uBAAqBA,MAAM,CAAEI;AAA7B;AAAA,qCAAP;;AACF,SAAKP,cAAc,CAACU,4BAApB;AACE,0BAAO;AAAA;AAAA;AAAA,aAAqBN,OAArB,aAAqBA,OAArB,uBAAqBA,OAAO,CAAEG;AAA9B;AAAA,qCAAP;AAXJ;AAaD;AAED;AACA;AACA;AACA;AACA;AACA;;GAxBgBN,a;UACCP,iB;;;KADDO,a;AAyBhB,eAAe,SAASU,eAAT,CACbC,aADa,EAEbC,cAFa,EAGbC,UAHa,EAIqF;AAAA;;AAClG,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBpB,kBAAkB,EAA/C;AACA,QAAMqB,YAAY,GAAGtB,eAAe,EAApC;AACA,QAAMuB,OAAO,GAAGzB,kBAAkB,CAACuB,OAAD,aAACA,OAAD,cAACA,OAAD,GAAYG,SAAZ,EAAuBP,aAAvB,aAAuBA,aAAvB,cAAuBA,aAAvB,GAAwCO,SAAxC,CAAlC,CAHkG,CAIlG;;AACA,QAAMC,WAAW,GAAGhC,OAAO,CAAC,MAAME,cAAc,CAACwB,UAAD,EAAaF,aAAb,aAAaA,aAAb,cAAaA,aAAb,GAA8BO,SAA9B,CAArB,EAA+D,CAACP,aAAD,EAAgBE,UAAhB,CAA/D,CAA3B;AACA,QAAMO,cAAc,GAAG7B,mBAAmB,EAA1C;AAEA,SAAOJ,OAAO,CAAC,MAAM;AACnB,QAAI,CAAC6B,YAAD,IAAiB,CAACF,OAAlB,IAA6B,CAACH,aAA9B,IAA+C,CAACC,cAApD,EAAoE,OAAOf,cAAP;AACpE,UAAMwB,IAAI,GAAGjC,uBAAuB,CAAC0B,OAAD,CAApC;AACA,QAAI,CAACO,IAAL,EAAW,OAAOxB,cAAP;AAEX,UAAMyB,cAAc,GAAGC,OAAO,CAACJ,WAAD,aAACA,WAAD,uBAACA,WAAW,CAAEK,WAAb,CAAyB,GAAzB,CAAD,CAA9B;AACA,UAAMC,iBAAiB,GAAGN,WAAW,IAAIF,OAAf,IAA0B,CAACA,OAAO,CAACS,QAAR,CAAiBP,WAAjB,CAArD;;AAEA,QAAIR,aAAa,CAACgB,QAAd,IAA0BN,IAAI,CAACO,MAAL,CAAYhB,cAAZ,CAA9B,EAA2D;AACzD,aAAO;AACLd,QAAAA,QAAQ,EAAEF,QAAQ,CAACiC,IADd;AAELC,QAAAA,OAAO,EACLL,iBAAiB,IAAIN,WAArB,GACI,YAAY;AACV,cAAI;AACF,kBAAMY,SAAS,GAAG,MAAMf,YAAY,CAACgB,OAAb,CAAqB;AAAEC,cAAAA,KAAK,EAAG,KAAId,WAAW,CAACe,QAAZ,CAAqBC,QAArB,CAA8B,EAA9B,CAAkC;AAAhD,aAArB,CAAxB;AACAf,YAAAA,cAAc,CAACW,SAAD,EAAY;AACxBK,cAAAA,IAAI,EAAE9C,eAAe,CAACuC,IADE;AAExBQ,cAAAA,SAAS,EAAE,KAFa;AAGxBC,cAAAA,iBAAiB,EAAEnB,WAAF,aAAEA,WAAF,uBAAEA,WAAW,CAAEe,QAAb,CAAsBC,QAAtB,EAHK;AAIxBrB,cAAAA;AAJwB,aAAZ,CAAd;AAMD,WARD,CAQE,OAAOyB,KAAP,EAAc;AACdC,YAAAA,OAAO,CAACD,KAAR,CAAc,mBAAd,EAAmCA,KAAnC;AACD;AACF,SAbL,GAcIrB,SAjBD;AAkBLuB,QAAAA,UAAU,EAAEhB,iBAAiB,GACzBP,SADyB,GAEzBI,cAAc,GACdvB,cAAc,CAACS,2BADD,GAEdT,cAAc,CAACM;AAtBd,OAAP;AAwBD,KAzBD,MAyBO,IAAIgB,IAAI,CAACO,MAAL,CAAYjB,aAAZ,KAA8BC,cAAc,CAACe,QAAjD,EAA2D;AAChE,aAAO;AACL7B,QAAAA,QAAQ,EAAEF,QAAQ,CAAC8C,MADd;AAELZ,QAAAA,OAAO,EACLL,iBAAiB,IAAIN,WAArB,GACI,YAAY;AACV,cAAI;AACF,kBAAMY,SAAS,GAAG,MAAMf,YAAY,CAAC2B,QAAb,CAAuB,KAAIxB,WAAW,CAACe,QAAZ,CAAqBC,QAArB,CAA8B,EAA9B,CAAkC,EAA7D,CAAxB;AACAf,YAAAA,cAAc,CAACW,SAAD,EAAY;AACxBK,cAAAA,IAAI,EAAE9C,eAAe,CAACuC,IADE;AAExBQ,cAAAA,SAAS,EAAE,IAFa;AAGxBC,cAAAA,iBAAiB,EAAEnB,WAAF,aAAEA,WAAF,uBAAEA,WAAW,CAAEe,QAAb,CAAsBC,QAAtB,EAHK;AAIxBrB,cAAAA;AAJwB,aAAZ,CAAd;AAMD,WARD,CAQE,OAAOyB,KAAP,EAAc;AACdC,YAAAA,OAAO,CAACD,KAAR,CAAc,oBAAd,EAAoCA,KAApC;AACD;AACF,SAbL,GAcIrB,SAjBD;AAkBLuB,QAAAA,UAAU,EAAEhB,iBAAiB,GACzBP,SADyB,GAEzBI,cAAc,GACdvB,cAAc,CAACU,4BADD,GAEdV,cAAc,CAACQ;AAtBd,OAAP;AAwBD,KAzBM,MAyBA;AACL,aAAOV,cAAP;AACD;AACF,GA7Da,EA6DX,CAACmB,YAAD,EAAeF,OAAf,EAAwBH,aAAxB,EAAuCC,cAAvC,EAAuDO,WAAvD,EAAoEF,OAApE,EAA6EG,cAA7E,CA7DW,CAAd;AA8DD;;IA1EuBV,e;UAKOf,kB,EACRD,e,EACLF,kB,EAGOD,mB","sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\n\nimport { WRAPPED_NATIVE_CURRENCY } from '../constants/tokens'\nimport { tryParseAmount } from '../state/swap/hooks'\nimport { TransactionType } from '../state/transactions/actions'\nimport { useTransactionAdder } from '../state/transactions/hooks'\nimport { useCurrencyBalance } from '../state/wallet/hooks'\nimport { useNativeCurrency } from './Tokens'\nimport { useWETHContract } from './useContract'\nimport { useActiveWeb3React } from './web3'\n\nexport enum WrapType {\n  NOT_APPLICABLE,\n  WRAP,\n  UNWRAP,\n}\n\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\n\nenum WrapInputError {\n  NO_ERROR, // must be equal to 0 so all other errors are truthy\n  ENTER_NATIVE_AMOUNT,\n  ENTER_WRAPPED_AMOUNT,\n  INSUFFICIENT_NATIVE_BALANCE,\n  INSUFFICIENT_WRAPPED_BALANCE,\n}\n\nexport function WrapErrorText({ wrapInputError }: { wrapInputError: WrapInputError }) {\n  const native = useNativeCurrency()\n  const wrapped = native?.wrapped\n\n  switch (wrapInputError) {\n    case WrapInputError.NO_ERROR:\n      return null\n    case WrapInputError.ENTER_NATIVE_AMOUNT:\n      return <Trans>Enter {native?.symbol} amount</Trans>\n    case WrapInputError.ENTER_WRAPPED_AMOUNT:\n      return <Trans>Enter {wrapped?.symbol} amount</Trans>\n\n    case WrapInputError.INSUFFICIENT_NATIVE_BALANCE:\n      return <Trans>Insufficient {native?.symbol} balance</Trans>\n    case WrapInputError.INSUFFICIENT_WRAPPED_BALANCE:\n      return <Trans>Insufficient {wrapped?.symbol} balance</Trans>\n  }\n}\n\n/**\n * Given the selected input and output currency, return a wrap callback\n * @param inputCurrency the selected input currency\n * @param outputCurrency the selected output currency\n * @param typedValue the user input value\n */\nexport default function useWrapCallback(\n  inputCurrency: Currency | undefined | null,\n  outputCurrency: Currency | undefined | null,\n  typedValue: string | undefined\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: WrapInputError } {\n  const { chainId, account } = useActiveWeb3React()\n  const wethContract = useWETHContract()\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency ?? undefined)\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency ?? undefined), [inputCurrency, typedValue])\n  const addTransaction = useTransactionAdder()\n\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId]\n    if (!weth) return NOT_APPLICABLE\n\n    const hasInputAmount = Boolean(inputAmount?.greaterThan('0'))\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\n\n    if (inputCurrency.isNative && weth.equals(outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.quotient.toString(16)}` })\n                  addTransaction(txReceipt, {\n                    type: TransactionType.WRAP,\n                    unwrapped: false,\n                    currencyAmountRaw: inputAmount?.quotient.toString(),\n                    chainId,\n                  })\n                } catch (error) {\n                  console.error('Could not deposit', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance\n          ? undefined\n          : hasInputAmount\n          ? WrapInputError.INSUFFICIENT_NATIVE_BALANCE\n          : WrapInputError.ENTER_NATIVE_AMOUNT,\n      }\n    } else if (weth.equals(inputCurrency) && outputCurrency.isNative) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute:\n          sufficientBalance && inputAmount\n            ? async () => {\n                try {\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.quotient.toString(16)}`)\n                  addTransaction(txReceipt, {\n                    type: TransactionType.WRAP,\n                    unwrapped: true,\n                    currencyAmountRaw: inputAmount?.quotient.toString(),\n                    chainId,\n                  })\n                } catch (error) {\n                  console.error('Could not withdraw', error)\n                }\n              }\n            : undefined,\n        inputError: sufficientBalance\n          ? undefined\n          : hasInputAmount\n          ? WrapInputError.INSUFFICIENT_WRAPPED_BALANCE\n          : WrapInputError.ENTER_WRAPPED_AMOUNT,\n      }\n    } else {\n      return NOT_APPLICABLE\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\n}\n"]},"metadata":{},"sourceType":"module"}