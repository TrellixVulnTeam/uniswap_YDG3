{"ast":null,"code":"import _regeneratorRuntime from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport _ from 'lodash';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { IV2GasModelFactory, usdGasTokensByChain } from '../gas-model'; // Constant cost for doing any swap regardless of pools.\n\nvar BASE_SWAP_COST = BigNumber.from(115000); // Constant per extra hop in the route.\n\nvar COST_PER_EXTRA_HOP = BigNumber.from(20000);\n/**\n * Computes a gas estimate for a V2 swap using heuristics.\n * Considers number of hops in the route and the typical base cost for a swap.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * Note, certain tokens e.g. rebasing/fee-on-transfer, may incur higher gas costs than\n * what we estimate here. This is because they run extra logic on token transfer.\n *\n * @export\n * @class V2HeuristicGasModelFactory\n */\n\nexport var V2HeuristicGasModelFactory = /*#__PURE__*/function (_IV2GasModelFactory) {\n  _inherits(V2HeuristicGasModelFactory, _IV2GasModelFactory);\n\n  var _super = _createSuper(V2HeuristicGasModelFactory);\n\n  function V2HeuristicGasModelFactory() {\n    _classCallCheck(this, V2HeuristicGasModelFactory);\n\n    return _super.call(this);\n  }\n\n  _createClass(V2HeuristicGasModelFactory, [{\n    key: \"buildGasModel\",\n    value: function () {\n      var _buildGasModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(chainId, gasPriceWei, poolProvider, token) {\n        var _this = this;\n\n        var _usdPool, ethPool, usdPool;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!token.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.getHighestLiquidityUSDPool(chainId, poolProvider);\n\n              case 3:\n                _usdPool = _context.sent;\n                return _context.abrupt(\"return\", {\n                  estimateGasCost: function estimateGasCost(routeWithValidQuote) {\n                    var _this$estimateGas = _this.estimateGas(routeWithValidQuote, gasPriceWei, chainId),\n                        gasCostInEth = _this$estimateGas.gasCostInEth,\n                        gasUse = _this$estimateGas.gasUse;\n\n                    var ethToken0 = _usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                    var ethTokenPrice = ethToken0 ? _usdPool.token0Price : _usdPool.token1Price;\n                    var gasCostInTermsOfUSD = ethTokenPrice.quote(gasCostInEth);\n                    return {\n                      gasEstimate: gasUse,\n                      gasCostInToken: gasCostInEth,\n                      gasCostInUSD: gasCostInTermsOfUSD\n                    };\n                  }\n                });\n\n              case 5:\n                _context.next = 7;\n                return this.getEthPool(chainId, token, poolProvider);\n\n              case 7:\n                ethPool = _context.sent;\n                _context.next = 10;\n                return this.getHighestLiquidityUSDPool(chainId, poolProvider);\n\n              case 10:\n                usdPool = _context.sent;\n                return _context.abrupt(\"return\", {\n                  estimateGasCost: function estimateGasCost(routeWithValidQuote) {\n                    var usdToken = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address ? usdPool.token1 : usdPool.token0;\n\n                    var _this$estimateGas2 = _this.estimateGas(routeWithValidQuote, gasPriceWei, chainId),\n                        gasCostInEth = _this$estimateGas2.gasCostInEth,\n                        gasUse = _this$estimateGas2.gasUse;\n\n                    if (!ethPool) {\n                      log.info('Unable to find ETH pool with the quote token to produce gas adjusted costs. Route will not account for gas.');\n                      return {\n                        gasEstimate: gasUse,\n                        gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                        gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n                      };\n                    }\n\n                    var ethToken0 = ethPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                    var ethTokenPrice = ethToken0 ? ethPool.token0Price : ethPool.token1Price;\n                    var gasCostInTermsOfQuoteToken;\n\n                    try {\n                      gasCostInTermsOfQuoteToken = ethTokenPrice.quote(gasCostInEth);\n                    } catch (err) {\n                      log.error({\n                        ethTokenPriceBase: ethTokenPrice.baseCurrency,\n                        ethTokenPriceQuote: ethTokenPrice.quoteCurrency,\n                        gasCostInEth: gasCostInEth.currency\n                      }, 'Debug eth price token issue');\n                      throw err;\n                    }\n\n                    var ethToken0USDPool = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                    var ethTokenPriceUSDPool = ethToken0USDPool ? usdPool.token0Price : usdPool.token1Price;\n                    var gasCostInTermsOfUSD;\n\n                    try {\n                      gasCostInTermsOfUSD = ethTokenPriceUSDPool.quote(gasCostInEth);\n                    } catch (err) {\n                      log.error({\n                        usdT1: usdPool.token0.symbol,\n                        usdT2: usdPool.token1.symbol,\n                        gasCostInEthToken: gasCostInEth.currency.symbol\n                      }, 'Failed to compute USD gas price');\n                      throw err;\n                    }\n\n                    return {\n                      gasEstimate: gasUse,\n                      gasCostInToken: gasCostInTermsOfQuoteToken,\n                      gasCostInUSD: gasCostInTermsOfUSD\n                    };\n                  }\n                });\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function buildGasModel(_x, _x2, _x3, _x4) {\n        return _buildGasModel.apply(this, arguments);\n      }\n\n      return buildGasModel;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n      var hops = routeWithValidQuote.route.pairs.length;\n      var gasUse = BASE_SWAP_COST.add(COST_PER_EXTRA_HOP.mul(hops - 1));\n      var totalGasCostWei = gasPriceWei.mul(gasUse);\n      var weth = WRAPPED_NATIVE_CURRENCY[chainId];\n      var gasCostInEth = CurrencyAmount.fromRawAmount(weth, totalGasCostWei.toString());\n      return {\n        gasCostInEth: gasCostInEth,\n        gasUse: gasUse\n      };\n    }\n  }, {\n    key: \"getEthPool\",\n    value: function () {\n      var _getEthPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chainId, token, poolProvider) {\n        var weth, poolAccessor, pool;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                weth = WRAPPED_NATIVE_CURRENCY[chainId];\n                _context2.next = 3;\n                return poolProvider.getPools([[weth, token]]);\n\n              case 3:\n                poolAccessor = _context2.sent;\n                pool = poolAccessor.getPool(weth, token);\n\n                if (pool) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                log.error({\n                  weth: weth,\n                  token: token\n                }, \"Could not find a WETH pool with \".concat(token.symbol, \" for computing gas costs.\"));\n                return _context2.abrupt(\"return\", null);\n\n              case 8:\n                return _context2.abrupt(\"return\", pool);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getEthPool(_x5, _x6, _x7) {\n        return _getEthPool.apply(this, arguments);\n      }\n\n      return getEthPool;\n    }()\n  }, {\n    key: \"getHighestLiquidityUSDPool\",\n    value: function () {\n      var _getHighestLiquidityUSDPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(chainId, poolProvider) {\n        var usdTokens, usdPools, poolAccessor, pools, maxPool;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                usdTokens = usdGasTokensByChain[chainId];\n\n                if (usdTokens) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Could not find a USD token for computing gas costs on \".concat(chainId));\n\n              case 3:\n                usdPools = _.map(usdTokens, function (usdToken) {\n                  return [usdToken, WRAPPED_NATIVE_CURRENCY[chainId]];\n                });\n                _context3.next = 6;\n                return poolProvider.getPools(usdPools);\n\n              case 6:\n                poolAccessor = _context3.sent;\n                pools = poolAccessor.getAllPools();\n\n                if (!(pools.length == 0)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                log.error({\n                  pools: pools\n                }, \"Could not find a USD/WETH pool for computing gas costs.\");\n                throw new Error(\"Can't find USD/WETH pool for computing gas costs.\");\n\n              case 11:\n                maxPool = _.maxBy(pools, function (pool) {\n                  if (pool.token0.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n                    return parseFloat(pool.reserve0.toSignificant(2));\n                  } else {\n                    return parseFloat(pool.reserve1.toSignificant(2));\n                  }\n                });\n                return _context3.abrupt(\"return\", maxPool);\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function getHighestLiquidityUSDPool(_x8, _x9) {\n        return _getHighestLiquidityUSDPool.apply(this, arguments);\n      }\n\n      return getHighestLiquidityUSDPool;\n    }()\n  }]);\n\n  return V2HeuristicGasModelFactory;\n}(IV2GasModelFactory);","map":{"version":3,"sources":["../../../../../../../src/routers/alpha-router/gas-models/v2/v2-heuristic-gas-model.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,SAAT,QAA0B,0BAA1B;AAGA,OAAO,CAAP,MAAc,QAAd;AAEA,SAAkB,GAAlB,EAAuB,uBAAvB,QAAsD,kBAAtD;AACA,SAAS,cAAT,QAA+B,0BAA/B;AAEA,SAEE,kBAFF,EAGE,mBAHF,QAIO,cAJP,C,CAMA;;AACA,IAAM,cAAc,GAAG,SAAS,CAAC,IAAV,CAAe,MAAf,CAAvB,C,CAEA;;AACA,IAAM,kBAAkB,GAAG,SAAS,CAAC,IAAV,CAAe,KAAf,CAA3B;AAEA;;;;;;;;;;;;;;;;AAgBG;;AACH,WAAa,0BAAb;AAAA;;AAAA;;AACE,wCAAA;AAAA;;AAAA;AAEC;;AAHH;AAAA;AAAA;AAAA,oFAKS,iBACL,OADK,EAEL,WAFK,EAGL,YAHK,EAIL,KAJK;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAMD,KAAK,CAAC,MAAN,CAAa,uBAAuB,CAAC,OAAD,CAApC,CANC;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAOyB,KAAK,0BAAL,CAC1B,OAD0B,EAE1B,YAF0B,CAPzB;;AAAA;AAOG,gBAAA,QAPH;AAAA,iDAYI;AACL,kBAAA,eAAe,EAAE,yBAAC,mBAAD,EAA+C;AAC9D,4CAAiC,KAAI,CAAC,WAAL,CAC/B,mBAD+B,EAE/B,WAF+B,EAG/B,OAH+B,CAAjC;AAAA,wBAAQ,YAAR,qBAAQ,YAAR;AAAA,wBAAsB,MAAtB,qBAAsB,MAAtB;;AAMA,wBAAM,SAAS,GACb,QAAO,CAAC,MAAR,CAAe,OAAf,IAA0B,uBAAuB,CAAC,OAAD,CAAvB,CAAkC,OAD9D;AAGA,wBAAM,aAAa,GAAG,SAAS,GAC3B,QAAO,CAAC,WADmB,GAE3B,QAAO,CAAC,WAFZ;AAIA,wBAAM,mBAAmB,GAAmB,aAAa,CAAC,KAAd,CAC1C,YAD0C,CAA5C;AAIA,2BAAO;AACL,sBAAA,WAAW,EAAE,MADR;AAEL,sBAAA,cAAc,EAAE,YAFX;AAGL,sBAAA,YAAY,EAAE;AAHT,qBAAP;AAKD;AAxBI,iBAZJ;;AAAA;AAAA;AAAA,uBA0C8B,KAAK,UAAL,CACjC,OADiC,EAEjC,KAFiC,EAGjC,YAHiC,CA1C9B;;AAAA;AA0CC,gBAAA,OA1CD;AAAA;AAAA,uBAgDuB,KAAK,0BAAL,CAC1B,OAD0B,EAE1B,YAF0B,CAhDvB;;AAAA;AAgDC,gBAAA,OAhDD;AAAA,iDAqDE;AACL,kBAAA,eAAe,EAAE,yBAAC,mBAAD,EAA+C;AAC9D,wBAAM,QAAQ,GACZ,OAAO,CAAC,MAAR,CAAe,OAAf,IAA0B,uBAAuB,CAAC,OAAD,CAAvB,CAAkC,OAA5D,GACI,OAAO,CAAC,MADZ,GAEI,OAAO,CAAC,MAHd;;AAKA,6CAAiC,KAAI,CAAC,WAAL,CAC/B,mBAD+B,EAE/B,WAF+B,EAG/B,OAH+B,CAAjC;AAAA,wBAAQ,YAAR,sBAAQ,YAAR;AAAA,wBAAsB,MAAtB,sBAAsB,MAAtB;;AAMA,wBAAI,CAAC,OAAL,EAAc;AACZ,sBAAA,GAAG,CAAC,IAAJ,CACE,6GADF;AAGA,6BAAO;AACL,wBAAA,WAAW,EAAE,MADR;AAEL,wBAAA,cAAc,EAAE,cAAc,CAAC,aAAf,CAA6B,KAA7B,EAAoC,CAApC,CAFX;AAGL,wBAAA,YAAY,EAAE,cAAc,CAAC,aAAf,CAA6B,QAA7B,EAAuC,CAAvC;AAHT,uBAAP;AAKD;;AAED,wBAAM,SAAS,GACb,OAAO,CAAC,MAAR,CAAe,OAAf,IAA0B,uBAAuB,CAAC,OAAD,CAAvB,CAAkC,OAD9D;AAGA,wBAAM,aAAa,GAAG,SAAS,GAC3B,OAAO,CAAC,WADmB,GAE3B,OAAO,CAAC,WAFZ;AAIA,wBAAI,0BAAJ;;AACA,wBAAI;AACF,sBAAA,0BAA0B,GAAG,aAAa,CAAC,KAAd,CAC3B,YAD2B,CAA7B;AAGD,qBAJD,CAIE,OAAO,GAAP,EAAY;AACZ,sBAAA,GAAG,CAAC,KAAJ,CACE;AACE,wBAAA,iBAAiB,EAAE,aAAa,CAAC,YADnC;AAEE,wBAAA,kBAAkB,EAAE,aAAa,CAAC,aAFpC;AAGE,wBAAA,YAAY,EAAE,YAAY,CAAC;AAH7B,uBADF,EAME,6BANF;AAQA,4BAAM,GAAN;AACD;;AAED,wBAAM,gBAAgB,GACpB,OAAO,CAAC,MAAR,CAAe,OAAf,IAA0B,uBAAuB,CAAC,OAAD,CAAvB,CAAkC,OAD9D;AAGA,wBAAM,oBAAoB,GAAG,gBAAgB,GACzC,OAAO,CAAC,WADiC,GAEzC,OAAO,CAAC,WAFZ;AAIA,wBAAI,mBAAJ;;AACA,wBAAI;AACF,sBAAA,mBAAmB,GAAG,oBAAoB,CAAC,KAArB,CACpB,YADoB,CAAtB;AAGD,qBAJD,CAIE,OAAO,GAAP,EAAY;AACZ,sBAAA,GAAG,CAAC,KAAJ,CACE;AACE,wBAAA,KAAK,EAAE,OAAO,CAAC,MAAR,CAAe,MADxB;AAEE,wBAAA,KAAK,EAAE,OAAO,CAAC,MAAR,CAAe,MAFxB;AAGE,wBAAA,iBAAiB,EAAE,YAAY,CAAC,QAAb,CAAsB;AAH3C,uBADF,EAME,iCANF;AAQA,4BAAM,GAAN;AACD;;AAED,2BAAO;AACL,sBAAA,WAAW,EAAE,MADR;AAEL,sBAAA,cAAc,EAAE,0BAFX;AAGL,sBAAA,YAAY,EAAE;AAHT,qBAAP;AAKD;AA7EI,iBArDF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OALT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,WA2IU,qBACN,mBADM,EAEN,WAFM,EAGN,OAHM,EAGU;AAEhB,UAAM,IAAI,GAAG,mBAAmB,CAAC,KAApB,CAA0B,KAA1B,CAAgC,MAA7C;AACA,UAAM,MAAM,GAAG,cAAc,CAAC,GAAf,CAAmB,kBAAkB,CAAC,GAAnB,CAAuB,IAAI,GAAG,CAA9B,CAAnB,CAAf;AAEA,UAAM,eAAe,GAAG,WAAW,CAAC,GAAZ,CAAgB,MAAhB,CAAxB;AAEA,UAAM,IAAI,GAAG,uBAAuB,CAAC,OAAD,CAApC;AAEA,UAAM,YAAY,GAAG,cAAc,CAAC,aAAf,CACnB,IADmB,EAEnB,eAAe,CAAC,QAAhB,EAFmB,CAArB;AAKA,aAAO;AAAE,QAAA,YAAY,EAAZ,YAAF;AAAgB,QAAA,MAAM,EAAN;AAAhB,OAAP;AACD;AA7JH;AAAA;AAAA;AAAA,iFA+JU,kBACN,OADM,EAEN,KAFM,EAGN,YAHM;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,gBAAA,IALA,GAKO,uBAAuB,CAAC,OAAD,CAL9B;AAAA;AAAA,uBAOqB,YAAY,CAAC,QAAb,CAAsB,CAAC,CAAC,IAAD,EAAO,KAAP,CAAD,CAAtB,CAPrB;;AAAA;AAOA,gBAAA,YAPA;AAQA,gBAAA,IARA,GAQO,YAAY,CAAC,OAAb,CAAqB,IAArB,EAA2B,KAA3B,CARP;;AAAA,oBAUD,IAVC;AAAA;AAAA;AAAA;;AAWJ,gBAAA,GAAG,CAAC,KAAJ,CACE;AAAE,kBAAA,IAAI,EAAJ,IAAF;AAAQ,kBAAA,KAAK,EAAL;AAAR,iBADF,4CAEqC,KAAK,CAAC,MAF3C;AAXI,kDAgBG,IAhBH;;AAAA;AAAA,kDAmBC,IAnBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA/JV;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iGAqLU,kBACN,OADM,EAEN,YAFM;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,gBAAA,SAJA,GAIY,mBAAmB,CAAC,OAAD,CAJ/B;;AAAA,oBAMD,SANC;AAAA;AAAA;AAAA;;AAAA,sBAOE,IAAI,KAAJ,iEACqD,OADrD,EAPF;;AAAA;AAYA,gBAAA,QAZA,GAYW,CAAC,CAAC,GAAF,CAA6B,SAA7B,EAAwC,UAAC,QAAD;AAAA,yBAAc,CACrE,QADqE,EAErE,uBAAuB,CAAC,OAAD,CAF8C,CAAd;AAAA,iBAAxC,CAZX;AAAA;AAAA,uBAgBqB,YAAY,CAAC,QAAb,CAAsB,QAAtB,CAhBrB;;AAAA;AAgBA,gBAAA,YAhBA;AAiBA,gBAAA,KAjBA,GAiBQ,YAAY,CAAC,WAAb,EAjBR;;AAAA,sBAmBF,KAAK,CAAC,MAAN,IAAgB,CAnBd;AAAA;AAAA;AAAA;;AAoBJ,gBAAA,GAAG,CAAC,KAAJ,CACE;AAAE,kBAAA,KAAK,EAAL;AAAF,iBADF;AApBI,sBAwBE,IAAI,KAAJ,qDAxBF;;AAAA;AA2BA,gBAAA,OA3BA,GA2BU,CAAC,CAAC,KAAF,CAAQ,KAAR,EAAe,UAAC,IAAD,EAAS;AACtC,sBAAI,IAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,uBAAuB,CAAC,OAAD,CAA1C,CAAJ,EAA2D;AACzD,2BAAO,UAAU,CAAC,IAAI,CAAC,QAAL,CAAc,aAAd,CAA4B,CAA5B,CAAD,CAAjB;AACD,mBAFD,MAEO;AACL,2BAAO,UAAU,CAAC,IAAI,CAAC,QAAL,CAAc,aAAd,CAA4B,CAA5B,CAAD,CAAjB;AACD;AACF,iBANe,CA3BV;AAAA,kDAmCC,OAnCD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OArLV;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,EAAgD,kBAAhD","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport _ from 'lodash';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { IV2GasModelFactory, usdGasTokensByChain, } from '../gas-model';\n// Constant cost for doing any swap regardless of pools.\nconst BASE_SWAP_COST = BigNumber.from(115000);\n// Constant per extra hop in the route.\nconst COST_PER_EXTRA_HOP = BigNumber.from(20000);\n/**\n * Computes a gas estimate for a V2 swap using heuristics.\n * Considers number of hops in the route and the typical base cost for a swap.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * Note, certain tokens e.g. rebasing/fee-on-transfer, may incur higher gas costs than\n * what we estimate here. This is because they run extra logic on token transfer.\n *\n * @export\n * @class V2HeuristicGasModelFactory\n */\nexport class V2HeuristicGasModelFactory extends IV2GasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel(chainId, gasPriceWei, poolProvider, token) {\n        if (token.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n            const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n            return {\n                estimateGasCost: (routeWithValidQuote) => {\n                    const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                    const ethToken0 = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                    const ethTokenPrice = ethToken0\n                        ? usdPool.token0Price\n                        : usdPool.token1Price;\n                    const gasCostInTermsOfUSD = ethTokenPrice.quote(gasCostInEth);\n                    return {\n                        gasEstimate: gasUse,\n                        gasCostInToken: gasCostInEth,\n                        gasCostInUSD: gasCostInTermsOfUSD,\n                    };\n                },\n            };\n        }\n        // If the quote token is not WETH, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <token>/ETH pool.\n        const ethPool = await this.getEthPool(chainId, token, poolProvider);\n        const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n        return {\n            estimateGasCost: (routeWithValidQuote) => {\n                const usdToken = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address\n                    ? usdPool.token1\n                    : usdPool.token0;\n                const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                if (!ethPool) {\n                    log.info('Unable to find ETH pool with the quote token to produce gas adjusted costs. Route will not account for gas.');\n                    return {\n                        gasEstimate: gasUse,\n                        gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                        gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                    };\n                }\n                const ethToken0 = ethPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                const ethTokenPrice = ethToken0\n                    ? ethPool.token0Price\n                    : ethPool.token1Price;\n                let gasCostInTermsOfQuoteToken;\n                try {\n                    gasCostInTermsOfQuoteToken = ethTokenPrice.quote(gasCostInEth);\n                }\n                catch (err) {\n                    log.error({\n                        ethTokenPriceBase: ethTokenPrice.baseCurrency,\n                        ethTokenPriceQuote: ethTokenPrice.quoteCurrency,\n                        gasCostInEth: gasCostInEth.currency,\n                    }, 'Debug eth price token issue');\n                    throw err;\n                }\n                const ethToken0USDPool = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                const ethTokenPriceUSDPool = ethToken0USDPool\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                let gasCostInTermsOfUSD;\n                try {\n                    gasCostInTermsOfUSD = ethTokenPriceUSDPool.quote(gasCostInEth);\n                }\n                catch (err) {\n                    log.error({\n                        usdT1: usdPool.token0.symbol,\n                        usdT2: usdPool.token1.symbol,\n                        gasCostInEthToken: gasCostInEth.currency.symbol,\n                    }, 'Failed to compute USD gas price');\n                    throw err;\n                }\n                return {\n                    gasEstimate: gasUse,\n                    gasCostInToken: gasCostInTermsOfQuoteToken,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            },\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const hops = routeWithValidQuote.route.pairs.length;\n        const gasUse = BASE_SWAP_COST.add(COST_PER_EXTRA_HOP.mul(hops - 1));\n        const totalGasCostWei = gasPriceWei.mul(gasUse);\n        const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n        const gasCostInEth = CurrencyAmount.fromRawAmount(weth, totalGasCostWei.toString());\n        return { gasCostInEth, gasUse };\n    }\n    async getEthPool(chainId, token, poolProvider) {\n        const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n        const poolAccessor = await poolProvider.getPools([[weth, token]]);\n        const pool = poolAccessor.getPool(weth, token);\n        if (!pool) {\n            log.error({ weth, token }, `Could not find a WETH pool with ${token.symbol} for computing gas costs.`);\n            return null;\n        }\n        return pool;\n    }\n    async getHighestLiquidityUSDPool(chainId, poolProvider) {\n        const usdTokens = usdGasTokensByChain[chainId];\n        if (!usdTokens) {\n            throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n        }\n        const usdPools = _.map(usdTokens, (usdToken) => [\n            usdToken,\n            WRAPPED_NATIVE_CURRENCY[chainId],\n        ]);\n        const poolAccessor = await poolProvider.getPools(usdPools);\n        const pools = poolAccessor.getAllPools();\n        if (pools.length == 0) {\n            log.error({ pools }, `Could not find a USD/WETH pool for computing gas costs.`);\n            throw new Error(`Can't find USD/WETH pool for computing gas costs.`);\n        }\n        const maxPool = _.maxBy(pools, (pool) => {\n            if (pool.token0.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n                return parseFloat(pool.reserve0.toSignificant(2));\n            }\n            else {\n                return parseFloat(pool.reserve1.toSignificant(2));\n            }\n        });\n        return maxPool;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjItaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YyL3YyLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBR3JELE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUV2QixPQUFPLEVBQVcsR0FBRyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDekUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTFELE9BQU8sRUFFTCxrQkFBa0IsRUFDbEIsbUJBQW1CLEdBQ3BCLE1BQU0sY0FBYyxDQUFDO0FBRXRCLHdEQUF3RDtBQUN4RCxNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBRTlDLHVDQUF1QztBQUN2QyxNQUFNLGtCQUFrQixHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFakQ7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsa0JBQWtCO0lBQ2hFO1FBQ0UsS0FBSyxFQUFFLENBQUM7SUFDVixDQUFDO0lBRU0sS0FBSyxDQUFDLGFBQWEsQ0FDeEIsT0FBZ0IsRUFDaEIsV0FBc0IsRUFDdEIsWUFBNkIsRUFDN0IsS0FBWTtRQUVaLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUUsQ0FBQyxFQUFFO1lBQ25ELE1BQU0sT0FBTyxHQUFTLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUN6RCxPQUFPLEVBQ1AsWUFBWSxDQUNiLENBQUM7WUFFRixPQUFPO2dCQUNMLGVBQWUsRUFBRSxDQUFDLG1CQUEwQyxFQUFFLEVB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"]},"metadata":{},"sourceType":"module"}