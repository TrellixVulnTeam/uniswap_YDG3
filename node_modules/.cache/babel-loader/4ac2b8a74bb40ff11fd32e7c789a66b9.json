{"ast":null,"code":"import { Price } from '@uniswap/sdk-core';\nimport { encodeSqrtRatioX96, nearestUsableTick, priceToClosestTick, TICK_SPACINGS, TickMath } from '@uniswap/v3-sdk';\nimport JSBI from 'jsbi';\nexport function tryParsePrice(baseToken, quoteToken, value) {\n  var _fraction$length;\n\n  if (!baseToken || !quoteToken || !value) {\n    return undefined;\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined;\n  }\n\n  const [whole, fraction] = value.split('.');\n  const decimals = (_fraction$length = fraction === null || fraction === void 0 ? void 0 : fraction.length) !== null && _fraction$length !== void 0 ? _fraction$length : 0;\n  const withoutDecimals = JSBI.BigInt((whole !== null && whole !== void 0 ? whole : '') + (fraction !== null && fraction !== void 0 ? fraction : ''));\n  return new Price(baseToken, quoteToken, JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)), JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals)));\n}\nexport function tryParseTick(baseToken, quoteToken, feeAmount, value) {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined;\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value);\n\n  if (!price) {\n    return undefined;\n  }\n\n  let tick; // check price is within min/max bounds, if outside return min/max\n\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK;\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK;\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price);\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/mint/v3/utils.ts"],"names":["Price","encodeSqrtRatioX96","nearestUsableTick","priceToClosestTick","TICK_SPACINGS","TickMath","JSBI","tryParsePrice","baseToken","quoteToken","value","undefined","match","whole","fraction","split","decimals","length","withoutDecimals","BigInt","multiply","tryParseTick","feeAmount","price","tick","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MAX_SQRT_RATIO","MAX_TICK","lessThanOrEqual","MIN_SQRT_RATIO","MIN_TICK"],"mappings":"AAAA,SAASA,KAAT,QAA6B,mBAA7B;AACA,SACEC,kBADF,EAGEC,iBAHF,EAIEC,kBAJF,EAKEC,aALF,EAMEC,QANF,QAOO,iBAPP;AAQA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,OAAO,SAASC,aAAT,CAAuBC,SAAvB,EAA0CC,UAA1C,EAA8DC,KAA9D,EAA8E;AAAA;;AACnF,MAAI,CAACF,SAAD,IAAc,CAACC,UAAf,IAA6B,CAACC,KAAlC,EAAyC;AACvC,WAAOC,SAAP;AACD;;AAED,MAAI,CAACD,KAAK,CAACE,KAAN,CAAY,aAAZ,CAAL,EAAiC;AAC/B,WAAOD,SAAP;AACD;;AAED,QAAM,CAACE,KAAD,EAAQC,QAAR,IAAoBJ,KAAK,CAACK,KAAN,CAAY,GAAZ,CAA1B;AAEA,QAAMC,QAAQ,uBAAGF,QAAH,aAAGA,QAAH,uBAAGA,QAAQ,CAAEG,MAAb,+DAAuB,CAArC;AACA,QAAMC,eAAe,GAAGZ,IAAI,CAACa,MAAL,CAAY,CAACN,KAAD,aAACA,KAAD,cAACA,KAAD,GAAU,EAAV,KAAiBC,QAAjB,aAAiBA,QAAjB,cAAiBA,QAAjB,GAA6B,EAA7B,CAAZ,CAAxB;AAEA,SAAO,IAAId,KAAJ,CACLQ,SADK,EAELC,UAFK,EAGLH,IAAI,CAACc,QAAL,CAAcd,IAAI,CAACa,MAAL,CAAY,MAAMH,QAAlB,CAAd,EAA2CV,IAAI,CAACa,MAAL,CAAY,MAAMX,SAAS,CAACQ,QAA5B,CAA3C,CAHK,EAILV,IAAI,CAACc,QAAL,CAAcF,eAAd,EAA+BZ,IAAI,CAACa,MAAL,CAAY,MAAMV,UAAU,CAACO,QAA7B,CAA/B,CAJK,CAAP;AAMD;AAED,OAAO,SAASK,YAAT,CACLb,SADK,EAELC,UAFK,EAGLa,SAHK,EAILZ,KAJK,EAKe;AACpB,MAAI,CAACF,SAAD,IAAc,CAACC,UAAf,IAA6B,CAACa,SAA9B,IAA2C,CAACZ,KAAhD,EAAuD;AACrD,WAAOC,SAAP;AACD;;AAED,QAAMY,KAAK,GAAGhB,aAAa,CAACC,SAAD,EAAYC,UAAZ,EAAwBC,KAAxB,CAA3B;;AAEA,MAAI,CAACa,KAAL,EAAY;AACV,WAAOZ,SAAP;AACD;;AAED,MAAIa,IAAJ,CAXoB,CAapB;;AACA,QAAMC,YAAY,GAAGxB,kBAAkB,CAACsB,KAAK,CAACG,SAAP,EAAkBH,KAAK,CAACI,WAAxB,CAAvC;;AAEA,MAAIrB,IAAI,CAACsB,kBAAL,CAAwBH,YAAxB,EAAsCpB,QAAQ,CAACwB,cAA/C,CAAJ,EAAoE;AAClEL,IAAAA,IAAI,GAAGnB,QAAQ,CAACyB,QAAhB;AACD,GAFD,MAEO,IAAIxB,IAAI,CAACyB,eAAL,CAAqBN,YAArB,EAAmCpB,QAAQ,CAAC2B,cAA5C,CAAJ,EAAiE;AACtER,IAAAA,IAAI,GAAGnB,QAAQ,CAAC4B,QAAhB;AACD,GAFM,MAEA;AACL;AACAT,IAAAA,IAAI,GAAGrB,kBAAkB,CAACoB,KAAD,CAAzB;AACD;;AAED,SAAOrB,iBAAiB,CAACsB,IAAD,EAAOpB,aAAa,CAACkB,SAAD,CAApB,CAAxB;AACD","sourcesContent":["import { Price, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined\n  }\n\n  const [whole, fraction] = value.split('.')\n\n  const decimals = fraction?.length ?? 0\n  const withoutDecimals = JSBI.BigInt((whole ?? '') + (fraction ?? ''))\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals))\n  )\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value)\n\n  if (!price) {\n    return undefined\n  }\n\n  let tick: number\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator)\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price)\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount])\n}\n"]},"metadata":{},"sourceType":"module"}