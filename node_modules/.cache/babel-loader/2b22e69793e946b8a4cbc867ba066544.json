{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$();\n\nimport { useTransactionMonitoringEventCallback } from 'hooks/useMonitoringEventCallback';\nimport { useCallback, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { addTransaction, TransactionType } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const dispatch = useAppDispatch();\n  const logMonitoringEvent = useTransactionMonitoringEventCallback();\n  return useCallback((response, info) => {\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      info,\n      chainId\n    }));\n    logMonitoringEvent(info, response);\n  }, [account, chainId, dispatch, logMonitoringEvent]);\n} // returns all the transactions for the current chain\n\n_s(useTransactionAdder, \"WMC8e9GIKnHPAwAfjBVNwmOmv7s=\", false, function () {\n  return [useActiveWeb3React, useAppDispatch, useTransactionMonitoringEventCallback];\n});\n\nexport function useAllTransactions() {\n  _s2();\n\n  var _state$chainId;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const state = useAppSelector(state => state.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\n\n_s2(useAllTransactions, \"REBlQGMAZjxd7Ih0pJeGgYuxwd4=\", false, function () {\n  return [useActiveWeb3React, useAppSelector];\n});\n\nexport function useTransaction(transactionHash) {\n  _s3();\n\n  const allTransactions = useAllTransactions();\n\n  if (!transactionHash) {\n    return undefined;\n  }\n\n  return allTransactions[transactionHash];\n}\n\n_s3(useTransaction, \"Ob9bTgdRot80r/ruWRGnJTDZF0M=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useIsTransactionPending(transactionHash) {\n  _s4();\n\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) return false;\n  return !transactions[transactionHash].receipt;\n}\n\n_s4(useIsTransactionPending, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useIsTransactionConfirmed(transactionHash) {\n  _s5();\n\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) return false;\n  return Boolean(transactions[transactionHash].receipt);\n}\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\n\n_s5(useIsTransactionConfirmed, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n} // returns whether a token has a pending approval transaction\n\nexport function useHasPendingApproval(tokenAddress, spender) {\n  _s6();\n\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n\n    if (tx.receipt) {\n      return false;\n    } else {\n      if (tx.info.type !== TransactionType.APPROVAL) return false;\n      return tx.info.spender === spender && tx.info.tokenAddress === tokenAddress && isTransactionRecent(tx);\n    }\n  }), [allTransactions, spender, tokenAddress]);\n} // watch for submissions to claim\n// return null if not done loading, return undefined if not found\n\n_s6(useHasPendingApproval, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});\n\nexport function useUserHasSubmittedClaim(account) {\n  _s7();\n\n  const allTransactions = useAllTransactions(); // get the txn if it has been submitted\n\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find(hash => {\n      const tx = allTransactions[hash];\n      return tx.info.type === TransactionType.CLAIM && tx.info.recipient === account;\n    });\n    return txnIndex && allTransactions[txnIndex] ? allTransactions[txnIndex] : undefined;\n  }, [account, allTransactions]);\n  return {\n    claimSubmitted: Boolean(claimTxn),\n    claimTxn\n  };\n}\n\n_s7(useUserHasSubmittedClaim, \"VV0KKHrbuq348q6dk6Qn9MylTW8=\", false, function () {\n  return [useAllTransactions];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/transactions/hooks.tsx"],"names":["useTransactionMonitoringEventCallback","useCallback","useMemo","useAppDispatch","useAppSelector","useActiveWeb3React","addTransaction","TransactionType","useTransactionAdder","chainId","account","dispatch","logMonitoringEvent","response","info","hash","Error","from","useAllTransactions","state","transactions","useTransaction","transactionHash","allTransactions","undefined","useIsTransactionPending","receipt","useIsTransactionConfirmed","Boolean","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","Object","keys","some","type","APPROVAL","useUserHasSubmittedClaim","claimTxn","txnIndex","find","CLAIM","recipient","claimSubmitted"],"mappings":";;;;;;;;AACA,SAASA,qCAAT,QAAsD,kCAAtD;AACA,SAASC,WAAT,EAAsBC,OAAtB,QAAqC,OAArC;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,aAA/C;AAEA,SAASC,kBAAT,QAAmC,kBAAnC;AACA,SAASC,cAAT,EAA0CC,eAA1C,QAAiE,WAAjE;AAGA;AACA,OAAO,SAASC,mBAAT,GAA+F;AAAA;;AACpG,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBL,kBAAkB,EAA/C;AACA,QAAMM,QAAQ,GAAGR,cAAc,EAA/B;AAEA,QAAMS,kBAAkB,GAAGZ,qCAAqC,EAAhE;AAEA,SAAOC,WAAW,CAChB,CAACY,QAAD,EAAgCC,IAAhC,KAA0D;AACxD,QAAI,CAACJ,OAAL,EAAc;AACd,QAAI,CAACD,OAAL,EAAc;AAEd,UAAM;AAAEM,MAAAA;AAAF,QAAWF,QAAjB;;AACA,QAAI,CAACE,IAAL,EAAW;AACT,YAAMC,KAAK,CAAC,4BAAD,CAAX;AACD;;AACDL,IAAAA,QAAQ,CAACL,cAAc,CAAC;AAAES,MAAAA,IAAF;AAAQE,MAAAA,IAAI,EAAEP,OAAd;AAAuBI,MAAAA,IAAvB;AAA6BL,MAAAA;AAA7B,KAAD,CAAf,CAAR;AAEAG,IAAAA,kBAAkB,CAACE,IAAD,EAAOD,QAAP,CAAlB;AACD,GAZe,EAahB,CAACH,OAAD,EAAUD,OAAV,EAAmBE,QAAnB,EAA6BC,kBAA7B,CAbgB,CAAlB;AAeD,C,CAED;;GAvBgBJ,mB;UACeH,kB,EACZF,c,EAEUH,qC;;;AAoB7B,OAAO,SAASkB,kBAAT,GAAwE;AAAA;;AAAA;;AAC7E,QAAM;AAAET,IAAAA;AAAF,MAAcJ,kBAAkB,EAAtC;AAEA,QAAMc,KAAK,GAAGf,cAAc,CAAEe,KAAD,IAAWA,KAAK,CAACC,YAAlB,CAA5B;AAEA,SAAOX,OAAO,qBAAGU,KAAK,CAACV,OAAD,CAAR,2DAAqB,EAArB,GAA0B,EAAxC;AACD;;IANeS,kB;UACMb,kB,EAEND,c;;;AAKhB,OAAO,SAASiB,cAAT,CAAwBC,eAAxB,EAAkF;AAAA;;AACvF,QAAMC,eAAe,GAAGL,kBAAkB,EAA1C;;AAEA,MAAI,CAACI,eAAL,EAAsB;AACpB,WAAOE,SAAP;AACD;;AAED,SAAOD,eAAe,CAACD,eAAD,CAAtB;AACD;;IAReD,c;UACUH,kB;;;AAS1B,OAAO,SAASO,uBAAT,CAAiCH,eAAjC,EAAoE;AAAA;;AACzE,QAAMF,YAAY,GAAGF,kBAAkB,EAAvC;AAEA,MAAI,CAACI,eAAD,IAAoB,CAACF,YAAY,CAACE,eAAD,CAArC,EAAwD,OAAO,KAAP;AAExD,SAAO,CAACF,YAAY,CAACE,eAAD,CAAZ,CAA8BI,OAAtC;AACD;;IANeD,uB;UACOP,kB;;;AAOvB,OAAO,SAASS,yBAAT,CAAmCL,eAAnC,EAAsE;AAAA;;AAC3E,QAAMF,YAAY,GAAGF,kBAAkB,EAAvC;AAEA,MAAI,CAACI,eAAD,IAAoB,CAACF,YAAY,CAACE,eAAD,CAArC,EAAwD,OAAO,KAAP;AAExD,SAAOM,OAAO,CAACR,YAAY,CAACE,eAAD,CAAZ,CAA8BI,OAA/B,CAAd;AACD;AAED;AACA;AACA;AACA;;IAXgBC,yB;UACOT,kB;;;AAWvB,OAAO,SAASW,mBAAT,CAA6BC,EAA7B,EAA8D;AACnE,SAAO,IAAIC,IAAJ,GAAWC,OAAX,KAAuBF,EAAE,CAACG,SAA1B,GAAsC,QAA7C;AACD,C,CAED;;AACA,OAAO,SAASC,qBAAT,CAA+BC,YAA/B,EAAiEC,OAAjE,EAAuG;AAAA;;AAC5G,QAAMb,eAAe,GAAGL,kBAAkB,EAA1C;AACA,SAAOhB,OAAO,CACZ,MACE,OAAOiC,YAAP,KAAwB,QAAxB,IACA,OAAOC,OAAP,KAAmB,QADnB,IAEAC,MAAM,CAACC,IAAP,CAAYf,eAAZ,EAA6BgB,IAA7B,CAAmCxB,IAAD,IAAU;AAC1C,UAAMe,EAAE,GAAGP,eAAe,CAACR,IAAD,CAA1B;AACA,QAAI,CAACe,EAAL,EAAS,OAAO,KAAP;;AACT,QAAIA,EAAE,CAACJ,OAAP,EAAgB;AACd,aAAO,KAAP;AACD,KAFD,MAEO;AACL,UAAII,EAAE,CAAChB,IAAH,CAAQ0B,IAAR,KAAiBjC,eAAe,CAACkC,QAArC,EAA+C,OAAO,KAAP;AAC/C,aAAOX,EAAE,CAAChB,IAAH,CAAQsB,OAAR,KAAoBA,OAApB,IAA+BN,EAAE,CAAChB,IAAH,CAAQqB,YAAR,KAAyBA,YAAxD,IAAwEN,mBAAmB,CAACC,EAAD,CAAlG;AACD;AACF,GATD,CAJU,EAcZ,CAACP,eAAD,EAAkBa,OAAlB,EAA2BD,YAA3B,CAdY,CAAd;AAgBD,C,CAED;AACA;;IArBgBD,qB;UACUhB,kB;;;AAqB1B,OAAO,SAASwB,wBAAT,CAAkChC,OAAlC,EAGL;AAAA;;AACA,QAAMa,eAAe,GAAGL,kBAAkB,EAA1C,CADA,CAGA;;AACA,QAAMyB,QAAQ,GAAGzC,OAAO,CAAC,MAAM;AAC7B,UAAM0C,QAAQ,GAAGP,MAAM,CAACC,IAAP,CAAYf,eAAZ,EAA6BsB,IAA7B,CAAmC9B,IAAD,IAAU;AAC3D,YAAMe,EAAE,GAAGP,eAAe,CAACR,IAAD,CAA1B;AACA,aAAOe,EAAE,CAAChB,IAAH,CAAQ0B,IAAR,KAAiBjC,eAAe,CAACuC,KAAjC,IAA0ChB,EAAE,CAAChB,IAAH,CAAQiC,SAAR,KAAsBrC,OAAvE;AACD,KAHgB,CAAjB;AAIA,WAAOkC,QAAQ,IAAIrB,eAAe,CAACqB,QAAD,CAA3B,GAAwCrB,eAAe,CAACqB,QAAD,CAAvD,GAAoEpB,SAA3E;AACD,GANuB,EAMrB,CAACd,OAAD,EAAUa,eAAV,CANqB,CAAxB;AAQA,SAAO;AAAEyB,IAAAA,cAAc,EAAEpB,OAAO,CAACe,QAAD,CAAzB;AAAqCA,IAAAA;AAArC,GAAP;AACD;;IAhBeD,wB;UAIUxB,kB","sourcesContent":["import { TransactionResponse } from '@ethersproject/providers'\nimport { useTransactionMonitoringEventCallback } from 'hooks/useMonitoringEventCallback'\nimport { useCallback, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\n\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { addTransaction, TransactionInfo, TransactionType } from './actions'\nimport { TransactionDetails } from './reducer'\n\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder(): (response: TransactionResponse, info: TransactionInfo) => void {\n  const { chainId, account } = useActiveWeb3React()\n  const dispatch = useAppDispatch()\n\n  const logMonitoringEvent = useTransactionMonitoringEventCallback()\n\n  return useCallback(\n    (response: TransactionResponse, info: TransactionInfo) => {\n      if (!account) return\n      if (!chainId) return\n\n      const { hash } = response\n      if (!hash) {\n        throw Error('No transaction hash found.')\n      }\n      dispatch(addTransaction({ hash, from: account, info, chainId }))\n\n      logMonitoringEvent(info, response)\n    },\n    [account, chainId, dispatch, logMonitoringEvent]\n  )\n}\n\n// returns all the transactions for the current chain\nexport function useAllTransactions(): { [txHash: string]: TransactionDetails } {\n  const { chainId } = useActiveWeb3React()\n\n  const state = useAppSelector((state) => state.transactions)\n\n  return chainId ? state[chainId] ?? {} : {}\n}\n\nexport function useTransaction(transactionHash?: string): TransactionDetails | undefined {\n  const allTransactions = useAllTransactions()\n\n  if (!transactionHash) {\n    return undefined\n  }\n\n  return allTransactions[transactionHash]\n}\n\nexport function useIsTransactionPending(transactionHash?: string): boolean {\n  const transactions = useAllTransactions()\n\n  if (!transactionHash || !transactions[transactionHash]) return false\n\n  return !transactions[transactionHash].receipt\n}\n\nexport function useIsTransactionConfirmed(transactionHash?: string): boolean {\n  const transactions = useAllTransactions()\n\n  if (!transactionHash || !transactions[transactionHash]) return false\n\n  return Boolean(transactions[transactionHash].receipt)\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\n  return new Date().getTime() - tx.addedTime < 86_400_000\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(tokenAddress: string | undefined, spender: string | undefined): boolean {\n  const allTransactions = useAllTransactions()\n  return useMemo(\n    () =>\n      typeof tokenAddress === 'string' &&\n      typeof spender === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash]\n        if (!tx) return false\n        if (tx.receipt) {\n          return false\n        } else {\n          if (tx.info.type !== TransactionType.APPROVAL) return false\n          return tx.info.spender === spender && tx.info.tokenAddress === tokenAddress && isTransactionRecent(tx)\n        }\n      }),\n    [allTransactions, spender, tokenAddress]\n  )\n}\n\n// watch for submissions to claim\n// return null if not done loading, return undefined if not found\nexport function useUserHasSubmittedClaim(account?: string): {\n  claimSubmitted: boolean\n  claimTxn: TransactionDetails | undefined\n} {\n  const allTransactions = useAllTransactions()\n\n  // get the txn if it has been submitted\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find((hash) => {\n      const tx = allTransactions[hash]\n      return tx.info.type === TransactionType.CLAIM && tx.info.recipient === account\n    })\n    return txnIndex && allTransactions[txnIndex] ? allTransactions[txnIndex] : undefined\n  }, [account, allTransactions])\n\n  return { claimSubmitted: Boolean(claimTxn), claimTxn }\n}\n"]},"metadata":{},"sourceType":"module"}