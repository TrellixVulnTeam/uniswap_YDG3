{"ast":null,"code":"import { Pair } from '@uniswap/v2-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n  /**\n   * Creates an instance of V2PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  constructor(chainId, multicall2Provider, retryOptions = {\n    retries: 2,\n    minTimeout: 50,\n    maxTimeout: 500\n  }) {\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions; // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n\n    this.POOL_ADDRESS_CACHE = {};\n  }\n\n  async getPools(tokenPairs, providerConfig) {\n    const poolAddressSet = new Set();\n    const sortedTokenPairs = [];\n    const sortedPoolAddresses = [];\n\n    for (let tokenPair of tokenPairs) {\n      const [tokenA, tokenB] = tokenPair;\n      const {\n        poolAddress,\n        token0,\n        token1\n      } = this.getPoolAddress(tokenA, tokenB);\n\n      if (poolAddressSet.has(poolAddress)) {\n        continue;\n      }\n\n      poolAddressSet.add(poolAddress);\n      sortedTokenPairs.push([token0, token1]);\n      sortedPoolAddresses.push(poolAddress);\n    }\n\n    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n    const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n    log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.` : ``}`);\n    const poolAddressToPool = {};\n    const invalidPools = [];\n\n    for (let i = 0; i < sortedPoolAddresses.length; i++) {\n      const reservesResult = reservesResults[i];\n\n      if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n        const [token0, token1] = sortedTokenPairs[i];\n        invalidPools.push([token0, token1]);\n        continue;\n      }\n\n      const [token0, token1] = sortedTokenPairs[i];\n      const {\n        reserve0,\n        reserve1\n      } = reservesResult.result;\n      const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n      const poolAddress = sortedPoolAddresses[i];\n      poolAddressToPool[poolAddress] = pool;\n    }\n\n    if (invalidPools.length > 0) {\n      log.info({\n        invalidPools: _.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`)\n      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n    }\n\n    const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n\n    log.debug({\n      poolStrs\n    }, `Found ${poolStrs.length} valid pools`);\n    return {\n      getPool: (tokenA, tokenB) => {\n        const {\n          poolAddress\n        } = this.getPoolAddress(tokenA, tokenB);\n        return poolAddressToPool[poolAddress];\n      },\n      getPoolByAddress: address => poolAddressToPool[address],\n      getAllPools: () => Object.values(poolAddressToPool)\n    };\n  }\n\n  getPoolAddress(tokenA, tokenB) {\n    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n    const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n\n    if (cachedAddress) {\n      return {\n        poolAddress: cachedAddress,\n        token0,\n        token1\n      };\n    }\n\n    const poolAddress = Pair.getAddress(token0, token1);\n    this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n    return {\n      poolAddress,\n      token0,\n      token1\n    };\n  }\n\n  async getPoolsData(poolAddresses, functionName, providerConfig) {\n    const {\n      results,\n      blockNumber\n    } = await retry(async () => {\n      return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n        addresses: poolAddresses,\n        contractInterface: IUniswapV2Pair__factory.createInterface(),\n        functionName: functionName,\n        providerConfig\n      });\n    }, this.retryOptions);\n    log.debug(`Pool data fetched as of block ${blockNumber}`);\n    return results;\n  }\n\n}","map":{"version":3,"sources":["../../../../../src/providers/v2/pool-provider.ts"],"names":[],"mappings":"AACA,SAAS,IAAT,QAAqB,iBAArB;AACA,SAAgC,OAAO,IAAI,KAA3C,QAAwD,aAAxD;AAEA,OAAO,CAAP,MAAc,QAAd;AACA,SAAS,uBAAT,QAAwC,gBAAxC;AACA,SAAkB,cAAlB,QAAwC,YAAxC;AACA,SAAS,GAAT,QAAoB,gBAApB;AACA,SAAS,YAAT,QAA6B,mBAA7B;AAkDA,OAAM,MAAO,cAAP,CAAqB;AAKzB;;;;;AAKG;AACH,EAAA,WAAA,CACY,OADZ,EAEY,kBAFZ,EAGY,YAAA,GAAmC;AAC3C,IAAA,OAAO,EAAE,CADkC;AAE3C,IAAA,UAAU,EAAE,EAF+B;AAG3C,IAAA,UAAU,EAAE;AAH+B,GAH/C,EAOG;AANS,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,kBAAA,GAAA,kBAAA;AACA,SAAA,YAAA,GAAA,YAAA,CAIT,CAjBH;AACA;;AACQ,SAAA,kBAAA,GAAgD,EAAhD;AAgBJ;;AAEiB,QAAR,QAAQ,CACnB,UADmB,EAEnB,cAFmB,EAEY;AAE/B,UAAM,cAAc,GAAgB,IAAI,GAAJ,EAApC;AACA,UAAM,gBAAgB,GAA0B,EAAhD;AACA,UAAM,mBAAmB,GAAa,EAAtC;;AAEA,SAAK,IAAI,SAAT,IAAsB,UAAtB,EAAkC;AAChC,YAAM,CAAC,MAAD,EAAS,MAAT,IAAmB,SAAzB;AAEA,YAAM;AAAE,QAAA,WAAF;AAAe,QAAA,MAAf;AAAuB,QAAA;AAAvB,UAAkC,KAAK,cAAL,CACtC,MADsC,EAEtC,MAFsC,CAAxC;;AAKA,UAAI,cAAc,CAAC,GAAf,CAAmB,WAAnB,CAAJ,EAAqC;AACnC;AACD;;AAED,MAAA,cAAc,CAAC,GAAf,CAAmB,WAAnB;AACA,MAAA,gBAAgB,CAAC,IAAjB,CAAsB,CAAC,MAAD,EAAS,MAAT,CAAtB;AACA,MAAA,mBAAmB,CAAC,IAApB,CAAyB,WAAzB;AACD;;AAED,IAAA,GAAG,CAAC,KAAJ,CACE,wBAAwB,UAAU,CAAC,MAAM,iCAAiC,cAAc,CAAC,IAAI,EAD/F;AAIA,UAAM,eAAe,GAAG,MAAM,KAAK,YAAL,CAC5B,mBAD4B,EAE5B,aAF4B,EAG5B,cAH4B,CAA9B;AAMA,IAAA,GAAG,CAAC,IAAJ,CACE,oBAAoB,cAAc,CAAC,IAAI,UACrC,CAAA,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAE,WAAhB,IACI,gBAAgB,OAAM,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAE,WAAtB,CAAiC,GADrD,GAEI,EACN,EALF;AAQA,UAAM,iBAAiB,GAAoC,EAA3D;AAEA,UAAM,YAAY,GAAqB,EAAvC;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,mBAAmB,CAAC,MAAxC,EAAgD,CAAC,EAAjD,EAAqD;AACnD,YAAM,cAAc,GAAG,eAAe,CAAC,CAAD,CAAtC;;AAEA,UAAI,EAAC,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAE,OAAjB,CAAJ,EAA8B;AAC5B,cAAM,CAAC,MAAD,EAAS,MAAT,IAAmB,gBAAgB,CAAC,CAAD,CAAzC;AACA,QAAA,YAAY,CAAC,IAAb,CAAkB,CAAC,MAAD,EAAS,MAAT,CAAlB;AAEA;AACD;;AAED,YAAM,CAAC,MAAD,EAAS,MAAT,IAAmB,gBAAgB,CAAC,CAAD,CAAzC;AACA,YAAM;AAAE,QAAA,QAAF;AAAY,QAAA;AAAZ,UAAyB,cAAc,CAAC,MAA9C;AAEA,YAAM,IAAI,GAAG,IAAI,IAAJ,CACX,cAAc,CAAC,aAAf,CAA6B,MAA7B,EAAqC,QAAQ,CAAC,QAAT,EAArC,CADW,EAEX,cAAc,CAAC,aAAf,CAA6B,MAA7B,EAAqC,QAAQ,CAAC,QAAT,EAArC,CAFW,CAAb;AAKA,YAAM,WAAW,GAAG,mBAAmB,CAAC,CAAD,CAAvC;AAEA,MAAA,iBAAiB,CAAC,WAAD,CAAjB,GAAiC,IAAjC;AACD;;AAED,QAAI,YAAY,CAAC,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,MAAA,GAAG,CAAC,IAAJ,CACE;AACE,QAAA,YAAY,EAAE,CAAC,CAAC,GAAF,CACZ,YADY,EAEZ,CAAC,CAAC,MAAD,EAAS,MAAT,CAAD,KAAsB,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,EAF3C;AADhB,OADF,EAOE,GAAG,YAAY,CAAC,MAAM,4EAPxB;AASD;;AAED,UAAM,QAAQ,GAAG,CAAC,CAAC,GAAF,CAAM,MAAM,CAAC,MAAP,CAAc,iBAAd,CAAN,EAAwC,YAAxC,CAAjB;;AAEA,IAAA,GAAG,CAAC,KAAJ,CAAU;AAAE,MAAA;AAAF,KAAV,EAAwB,SAAS,QAAQ,CAAC,MAAM,cAAhD;AAEA,WAAO;AACL,MAAA,OAAO,EAAE,CAAC,MAAD,EAAgB,MAAhB,KAAmD;AAC1D,cAAM;AAAE,UAAA;AAAF,YAAkB,KAAK,cAAL,CAAoB,MAApB,EAA4B,MAA5B,CAAxB;AACA,eAAO,iBAAiB,CAAC,WAAD,CAAxB;AACD,OAJI;AAKL,MAAA,gBAAgB,EAAG,OAAD,IAChB,iBAAiB,CAAC,OAAD,CANd;AAOL,MAAA,WAAW,EAAE,MAAc,MAAM,CAAC,MAAP,CAAc,iBAAd;AAPtB,KAAP;AASD;;AAEM,EAAA,cAAc,CACnB,MADmB,EAEnB,MAFmB,EAEN;AAEb,UAAM,CAAC,MAAD,EAAS,MAAT,IAAmB,MAAM,CAAC,WAAP,CAAmB,MAAnB,IACrB,CAAC,MAAD,EAAS,MAAT,CADqB,GAErB,CAAC,MAAD,EAAS,MAAT,CAFJ;AAIA,UAAM,QAAQ,GAAG,GAAG,KAAK,OAAO,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,EAApE;AAEA,UAAM,aAAa,GAAG,KAAK,kBAAL,CAAwB,QAAxB,CAAtB;;AAEA,QAAI,aAAJ,EAAmB;AACjB,aAAO;AAAE,QAAA,WAAW,EAAE,aAAf;AAA8B,QAAA,MAA9B;AAAsC,QAAA;AAAtC,OAAP;AACD;;AAED,UAAM,WAAW,GAAG,IAAI,CAAC,UAAL,CAAgB,MAAhB,EAAwB,MAAxB,CAApB;AAEA,SAAK,kBAAL,CAAwB,QAAxB,IAAoC,WAApC;AAEA,WAAO;AAAE,MAAA,WAAF;AAAe,MAAA,MAAf;AAAuB,MAAA;AAAvB,KAAP;AACD;;AAEyB,QAAZ,YAAY,CACxB,aADwB,EAExB,YAFwB,EAGxB,cAHwB,EAGO;AAE/B,UAAM;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,QAA2B,MAAM,KAAK,CAAC,YAAW;AACtD,aAAO,KAAK,kBAAL,CAAwB,mCAAxB,CAGL;AACA,QAAA,SAAS,EAAE,aADX;AAEA,QAAA,iBAAiB,EAAE,uBAAuB,CAAC,eAAxB,EAFnB;AAGA,QAAA,YAAY,EAAE,YAHd;AAIA,QAAA;AAJA,OAHK,CAAP;AASD,KAV2C,EAUzC,KAAK,YAVoC,CAA5C;AAYA,IAAA,GAAG,CAAC,KAAJ,CAAU,iCAAiC,WAAW,EAAtD;AAEA,WAAO,OAAP;AACD;;AAjKwB","sourceRoot":"","sourcesContent":["import { Pair } from '@uniswap/v2-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV2Pair__factory } from '../../types/v2';\nimport { CurrencyAmount } from '../../util';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V2PoolProvider {\n    /**\n     * Creates an instance of V2PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (let tokenPair of tokenPairs) {\n            const [tokenA, tokenB] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const reservesResults = await this.getPoolsData(sortedPoolAddresses, 'getReserves', providerConfig);\n        log.info(`Got reserves for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${await (providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const reservesResult = reservesResults[i];\n            if (!(reservesResult === null || reservesResult === void 0 ? void 0 : reservesResult.success)) {\n                const [token0, token1] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1]);\n                continue;\n            }\n            const [token0, token1] = sortedTokenPairs[i];\n            const { reserve0, reserve1 } = reservesResult.result;\n            const pool = new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()));\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1]) => `${token0.symbol}/${token1.symbol}`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = Pair.getAddress(token0, token1);\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV2Pair__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjIvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUF5QixPQUFPLElBQUksS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXRFLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RCxPQUFPLEVBQVcsY0FBYyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3JELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFrRGpELE1BQU0sT0FBTyxjQUFjO0lBS3pCOzs7OztPQUtHO0lBQ0gsWUFDWSxPQUFnQixFQUNoQixrQkFBc0MsRUFDdEMsZUFBbUM7UUFDM0MsT0FBTyxFQUFFLENBQUM7UUFDVixVQUFVLEVBQUUsRUFBRTtRQUNkLFVBQVUsRUFBRSxHQUFHO0tBQ2hCO1FBTlMsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQUNoQix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO1FBQ3RDLGlCQUFZLEdBQVosWUFBWSxDQUlyQjtRQWpCSCx5RUFBeUU7UUFDekUsa0RBQWtEO1FBQzFDLHVCQUFrQixHQUE4QixFQUFFLENBQUM7SUFnQnhELENBQUM7SUFFRyxLQUFLLENBQUMsUUFBUSxDQUNuQixVQUE0QixFQUM1QixjQUErQjtRQUUvQixNQUFNLGNBQWMsR0FBZ0IsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUN0RCxNQUFNLGdCQUFnQixHQUEwQixFQUFFLENBQUM7UUFDbkQsTUFBTSxtQkFBbUIsR0FBYSxFQUFFLENBQUM7UUFFekMsS0FBSyxJQUFJLFNBQVMsSUFBSSxVQUFVLEVBQUU7WUFDaEMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUM7WUFFbkMsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FDekQsTUFBTSxFQUNOLE1BQU0sQ0FDUCxDQUFDO1lBRUYsSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNuQyxTQUFTO2FBQ1Y7WUFFRCxjQUFjLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2hDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN2QztRQUVELEdBQUcsQ0FBQyxLQUFLLENBQ1Asd0JBQXdCLFVBQVUsQ0FBQyxNQUFNLGlDQUFpQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQ2hHLENBQUM7UUFFRixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQzdDLG1CQUFtQixFQUNuQixhQUFhLEVBQ2IsY0FBYyxDQUNmLENBQUM7UUFFRixHQUFHLENBQUMsSUFBSSxDQUNOLG9CQUFvQixjQUFjLENBQUMsSUFBSSxVQUNyQyxDQUFBLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxXQUFXO1lBQ3pCLENBQUMsQ0FBQyxnQkFBZ0IsTUFBTSxDQUFBLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxXQUFXLENBQUEsR0FBRztZQUN0RCxDQUFDLENBQUMsRUFDTixFQUFFLENBQ0gsQ0FBQztRQUVGLE1BQU0saUJBQWlCLEdBQW9DLEVBQUUsQ0FBQztRQUU5RCxNQUFNLFlBQVksR0FBcUIsRUFBRSxDQUFDO1FBRTFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbkQsTUFBTSxjQUFjLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBRSxDQUFDO1lBRTNDLElBQUksQ0FBQyxDQUFBLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRSxPQUFPLENBQUEsRUFBRTtnQkFDNUIsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUUsQ0FBQztnQkFDOUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUVwQyxTQUFTO2FBQ1Y7WUFFRCxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBRSxDQUFDO1lBQzlDLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztZQUVyRCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FDbkIsY0FBYyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQ3pELGNBQWMsQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUMxRCxDQUFDO1lBRUYsTUFBTSxXQUFXLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFFLENBQUM7WUFFNUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQ3ZDO1FBRUQsSUFBSSxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzQixHQUFHLENBQUMsSUFBSSxDQUNOO2dCQUNFLFlBQVksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUNqQixZQUFZLEVBQ1osQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FDMUQ7YUFDRixFQUNELEdBQUcsWUFBWSxDQUFDLE1BQU0sNEVBQTRFLENBQ25HLENBQUM7U0FDSDtRQUVELE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRXZFLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxTQUFTLFFBQVEsQ0FBQyxNQUFNLGNBQWMsQ0FBQyxDQUFDO1FBRWhFLE9BQU87WUFDTCxPQUFPLEVBQUUsQ0FBQyxNQUFhLEVBQUUsTUFBYSxFQUFvQixFQUFFO2dCQUMxRCxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQzVELE9BQU8saUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUNELGdCQUFnQixFQUFFLENBQUMsT0FBZSxFQUFvQixFQUFFLENBQ3RELGlCQUFpQixDQUFDLE9BQU8sQ0FBQztZQUM1QixXQUFXLEVBQUUsR0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztTQUM1RCxDQUFDO0lBQ0osQ0FBQztJQUVNLGNBQWMsQ0FDbkIsTUFBYSxFQUNiLE1BQWE7UUFFYixNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1lBQ2pELENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7WUFDbEIsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXJCLE1BQU0sUUFBUSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV2RSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFeEQsSUFBSSxhQUFhLEVBQUU7WUFDakIsT0FBTyxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO1NBQ3ZEO1FBRUQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFcEQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQztRQUVoRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVksQ0FDeEIsYUFBdUIsRUFDdkIsWUFBb0IsRUFDcEIsY0FBK0I7UUFFL0IsTUFBTSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxNQUFNLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRTtZQUN0RCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxtQ0FBbUMsQ0FHaEU7Z0JBQ0EsU0FBUyxFQUFFLGFBQWE7Z0JBQ3hCLGlCQUFpQixFQUFFLHVCQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDNUQsWUFBWSxFQUFFLFlBQVk7Z0JBQzFCLGNBQWM7YUFDZixDQUFDLENBQUM7UUFDTCxDQUFDLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXRCLEdBQUcsQ0FBQyxLQUFLLENBQUMsaUNBQWlDLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFFMUQsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztDQUNGIn0="]},"metadata":{},"sourceType":"module"}