{"ast":null,"code":"import _objectSpread from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{useMemo}from'react';import{useAppSelector}from'state/hooks';import sortByListPriority from'utils/listSort';import BROKEN_LIST from'../../constants/tokenLists/broken.tokenlist.json';import UNSUPPORTED_TOKEN_LIST from'../../constants/tokenLists/unsupported.tokenlist.json';import{UNSUPPORTED_LIST_URLS}from'./../../constants/lists';import{WrappedTokenInfo}from'./wrappedTokenInfo';var listCache=typeof WeakMap!=='undefined'?new WeakMap():null;function listToTokenMap(list){var result=listCache===null||listCache===void 0?void 0:listCache.get(list);if(result)return result;var map=list.tokens.reduce(function(tokenMap,tokenInfo){var _tokenMap$token$chain;var token=new WrappedTokenInfo(tokenInfo,list);if(((_tokenMap$token$chain=tokenMap[token.chainId])===null||_tokenMap$token$chain===void 0?void 0:_tokenMap$token$chain[token.address])!==undefined){console.error(\"Duplicate token! \".concat(token.address));return tokenMap;}if(!tokenMap[token.chainId])tokenMap[token.chainId]={};tokenMap[token.chainId][token.address]={token:token,list:list};return tokenMap;},{});listCache===null||listCache===void 0?void 0:listCache.set(list,map);return map;}export function useAllLists(){return useAppSelector(function(state){return state.lists.byUrl;});}/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */export function combineMaps(map1,map2){var chainIds=Object.keys(Object.keys(map1).concat(Object.keys(map2)).reduce(function(memo,value){memo[value]=true;return memo;},{})).map(function(id){return parseInt(id);});return chainIds.reduce(function(memo,chainId){memo[chainId]=_objectSpread(_objectSpread({},map2[chainId]),map1[chainId]);return memo;},{});}// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls){var lists=useAllLists();return useMemo(function(){if(!urls)return{};return urls.slice()// sort by priority so top priority goes last\n.sort(sortByListPriority).reduce(function(allTokens,currentUrl){var _lists$currentUrl;var current=(_lists$currentUrl=lists[currentUrl])===null||_lists$currentUrl===void 0?void 0:_lists$currentUrl.current;if(!current)return allTokens;try{return combineMaps(allTokens,listToTokenMap(current));}catch(error){console.error('Could not show token list due to error',error);return allTokens;}},{});},[lists,urls]);}// filter out unsupported lists\nexport function useActiveListUrls(){var activeListUrls=useAppSelector(function(state){return state.lists.activeListUrls;});return useMemo(function(){return activeListUrls===null||activeListUrls===void 0?void 0:activeListUrls.filter(function(url){return!UNSUPPORTED_LIST_URLS.includes(url);});},[activeListUrls]);}export function useInactiveListUrls(){var lists=useAllLists();var allActiveListUrls=useActiveListUrls();return useMemo(function(){return Object.keys(lists).filter(function(url){return!(allActiveListUrls===null||allActiveListUrls===void 0?void 0:allActiveListUrls.includes(url))&&!UNSUPPORTED_LIST_URLS.includes(url);});},[lists,allActiveListUrls]);}// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(){var activeListUrls=useActiveListUrls();var activeTokens=useCombinedTokenMapFromUrls(activeListUrls);return activeTokens;}// list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(){// get hard-coded broken tokens\nvar brokenListMap=useMemo(function(){return listToTokenMap(BROKEN_LIST);},[]);// get hard-coded list of unsupported tokens\nvar localUnsupportedListMap=useMemo(function(){return listToTokenMap(UNSUPPORTED_TOKEN_LIST);},[]);// get dynamic list of unsupported tokens\nvar loadedUnsupportedListMap=useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS);// format into one token address map\nreturn useMemo(function(){return combineMaps(brokenListMap,combineMaps(localUnsupportedListMap,loadedUnsupportedListMap));},[brokenListMap,localUnsupportedListMap,loadedUnsupportedListMap]);}export function useIsListActive(url){var activeListUrls=useActiveListUrls();return Boolean(activeListUrls===null||activeListUrls===void 0?void 0:activeListUrls.includes(url));}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/lists/hooks.ts"],"names":["useMemo","useAppSelector","sortByListPriority","BROKEN_LIST","UNSUPPORTED_TOKEN_LIST","UNSUPPORTED_LIST_URLS","WrappedTokenInfo","listCache","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","tokenInfo","token","chainId","address","undefined","console","error","set","useAllLists","state","lists","byUrl","combineMaps","map1","map2","chainIds","Object","keys","concat","memo","value","id","parseInt","useCombinedTokenMapFromUrls","urls","slice","sort","allTokens","currentUrl","current","useActiveListUrls","activeListUrls","filter","url","includes","useInactiveListUrls","allActiveListUrls","useCombinedActiveList","activeTokens","useUnsupportedTokenList","brokenListMap","localUnsupportedListMap","loadedUnsupportedListMap","useIsListActive","Boolean"],"mappings":"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","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport { useMemo } from 'react'\nimport { useAppSelector } from 'state/hooks'\nimport sortByListPriority from 'utils/listSort'\n\nimport BROKEN_LIST from '../../constants/tokenLists/broken.tokenlist.json'\nimport UNSUPPORTED_TOKEN_LIST from '../../constants/tokenLists/unsupported.tokenlist.json'\nimport { AppState } from '../index'\nimport { UNSUPPORTED_LIST_URLS } from './../../constants/lists'\nimport { WrappedTokenInfo } from './wrappedTokenInfo'\n\nexport type TokenAddressMap = Readonly<{\n  [chainId: number]: Readonly<{ [tokenAddress: string]: { token: WrappedTokenInfo; list: TokenList } }>\n}>\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: Mutable<T[P]>\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  typeof WeakMap !== 'undefined' ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nfunction listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n  if (result) return result\n\n  const map = list.tokens.reduce<Mutable<TokenAddressMap>>((tokenMap, tokenInfo) => {\n    const token = new WrappedTokenInfo(tokenInfo, list)\n    if (tokenMap[token.chainId]?.[token.address] !== undefined) {\n      console.error(`Duplicate token! ${token.address}`)\n      return tokenMap\n    }\n    if (!tokenMap[token.chainId]) tokenMap[token.chainId] = {}\n    tokenMap[token.chainId][token.address] = {\n      token,\n      list,\n    }\n    return tokenMap\n  }, {}) as TokenAddressMap\n  listCache?.set(list, map)\n  return map\n}\n\nexport function useAllLists(): AppState['lists']['byUrl'] {\n  return useAppSelector((state) => state.lists.byUrl)\n}\n\n/**\n * Combine the tokens in map2 with the tokens on map1, where tokens on map1 take precedence\n * @param map1 the base token map\n * @param map2 the map of additioanl tokens to add to the base map\n */\nexport function combineMaps(map1: TokenAddressMap, map2: TokenAddressMap): TokenAddressMap {\n  const chainIds = Object.keys(\n    Object.keys(map1)\n      .concat(Object.keys(map2))\n      .reduce<{ [chainId: string]: true }>((memo, value) => {\n        memo[value] = true\n        return memo\n      }, {})\n  ).map((id) => parseInt(id))\n\n  return chainIds.reduce<Mutable<TokenAddressMap>>((memo, chainId) => {\n    memo[chainId] = {\n      ...map2[chainId],\n      // map1 takes precedence\n      ...map1[chainId],\n    }\n    return memo\n  }, {}) as TokenAddressMap\n}\n\n// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls: string[] | undefined): TokenAddressMap {\n  const lists = useAllLists()\n  return useMemo(() => {\n    if (!urls) return {}\n    return (\n      urls\n        .slice()\n        // sort by priority so top priority goes last\n        .sort(sortByListPriority)\n        .reduce((allTokens, currentUrl) => {\n          const current = lists[currentUrl]?.current\n          if (!current) return allTokens\n          try {\n            return combineMaps(allTokens, listToTokenMap(current))\n          } catch (error) {\n            console.error('Could not show token list due to error', error)\n            return allTokens\n          }\n        }, {})\n    )\n  }, [lists, urls])\n}\n\n// filter out unsupported lists\nexport function useActiveListUrls(): string[] | undefined {\n  const activeListUrls = useAppSelector((state) => state.lists.activeListUrls)\n  return useMemo(() => activeListUrls?.filter((url) => !UNSUPPORTED_LIST_URLS.includes(url)), [activeListUrls])\n}\n\nexport function useInactiveListUrls(): string[] {\n  const lists = useAllLists()\n  const allActiveListUrls = useActiveListUrls()\n  return useMemo(\n    () => Object.keys(lists).filter((url) => !allActiveListUrls?.includes(url) && !UNSUPPORTED_LIST_URLS.includes(url)),\n    [lists, allActiveListUrls]\n  )\n}\n\n// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(): TokenAddressMap {\n  const activeListUrls = useActiveListUrls()\n  const activeTokens = useCombinedTokenMapFromUrls(activeListUrls)\n  return activeTokens\n}\n\n// list of tokens not supported on interface for various reasons, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(): TokenAddressMap {\n  // get hard-coded broken tokens\n  const brokenListMap = useMemo(() => listToTokenMap(BROKEN_LIST), [])\n\n  // get hard-coded list of unsupported tokens\n  const localUnsupportedListMap = useMemo(() => listToTokenMap(UNSUPPORTED_TOKEN_LIST), [])\n\n  // get dynamic list of unsupported tokens\n  const loadedUnsupportedListMap = useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS)\n\n  // format into one token address map\n  return useMemo(\n    () => combineMaps(brokenListMap, combineMaps(localUnsupportedListMap, loadedUnsupportedListMap)),\n    [brokenListMap, localUnsupportedListMap, loadedUnsupportedListMap]\n  )\n}\nexport function useIsListActive(url: string): boolean {\n  const activeListUrls = useActiveListUrls()\n  return Boolean(activeListUrls?.includes(url))\n}\n"]},"metadata":{},"sourceType":"module"}