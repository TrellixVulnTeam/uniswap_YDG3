{"ast":null,"code":"import { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport { BigNumber } from 'ethers';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { IQuoterV2__factory } from '../../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../../util';\nimport { QUOTER_V2_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { routeToString } from '../../util/routes';\nexport class BlockConflictError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'BlockConflictError';\n  }\n\n}\nexport class SuccessRateError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'SuccessRateError';\n  }\n\n}\nexport class ProviderBlockHeaderError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'ProviderBlockHeaderError';\n  }\n\n}\nexport class ProviderTimeoutError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'ProviderTimeoutError';\n  }\n\n}\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\n\nexport class ProviderGasError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'ProviderGasError';\n  }\n\n}\nconst DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes quotes for V3. For V3, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. This is because computing quotes off-chain would\n * require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class V3QuoteProvider\n */\n\nexport class V3QuoteProvider {\n  /**\n   * Creates an instance of V3QuoteProvider.\n   *\n   * @param chainId The chain to get quotes for.\n   * @param provider The web 3 provider.\n   * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n   * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n   * @param retryOptions The retry options for each call to the multicall.\n   * @param batchParams The parameters for each batched call to the multicall.\n   * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n   * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n   * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n   * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n   */\n  constructor(chainId, provider, // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n  multicall2Provider, retryOptions = {\n    retries: DEFAULT_BATCH_RETRIES,\n    minTimeout: 25,\n    maxTimeout: 250\n  }, batchParams = {\n    multicallChunk: 150,\n    gasLimitPerCall: 1000000,\n    quoteMinSuccessRate: 0.2\n  }, gasErrorFailureOverride = {\n    gasLimitOverride: 1500000,\n    multicallChunk: 100\n  }, successRateFailureOverrides = {\n    gasLimitOverride: 1300000,\n    multicallChunk: 110\n  }, blockNumberConfig = {\n    baseBlockOffset: 0,\n    rollback: {\n      enabled: false\n    }\n  }, quoterAddressOverride) {\n    this.chainId = chainId;\n    this.provider = provider;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    this.batchParams = batchParams;\n    this.gasErrorFailureOverride = gasErrorFailureOverride;\n    this.successRateFailureOverrides = successRateFailureOverrides;\n    this.blockNumberConfig = blockNumberConfig;\n    this.quoterAddressOverride = quoterAddressOverride;\n    const quoterAddress = quoterAddressOverride ? quoterAddressOverride : QUOTER_V2_ADDRESS;\n\n    if (!quoterAddress) {\n      throw new Error(`No address for Uniswap QuoterV2 Contract on chain id: ${chainId}`);\n    }\n\n    this.quoterAddress = quoterAddress;\n  }\n\n  async getQuotesManyExactIn(amountIns, routes, providerConfig) {\n    return this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig);\n  }\n\n  async getQuotesManyExactOut(amountOuts, routes, providerConfig) {\n    return this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig);\n  }\n\n  async getQuotesManyData(amounts, routes, functionName, _providerConfig) {\n    var _a;\n\n    let multicallChunk = this.batchParams.multicallChunk;\n    let gasLimitOverride = this.batchParams.gasLimitPerCall;\n    const {\n      baseBlockOffset,\n      rollback\n    } = this.blockNumberConfig; // Apply the base block offset if provided\n\n    const originalBlockNumber = await this.provider.getBlockNumber();\n    const providerConfig = { ..._providerConfig,\n      blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset\n    };\n\n    const inputs = _(routes).flatMap(route => {\n      const encodedRoute = encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n      );\n      const routeInputs = amounts.map(amount => [encodedRoute, `0x${amount.quotient.toString(16)}`]);\n      return routeInputs;\n    }).value();\n\n    const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n\n    const inputsChunked = _.chunk(inputs, normalizedChunk);\n\n    let quoteStates = _.map(inputsChunked, inputChunk => {\n      return {\n        status: 'pending',\n        inputs: inputChunk\n      };\n    });\n\n    log.info(`About to get ${inputs.length} quotes in chunks of ${normalizedChunk} [${_.map(inputsChunked, i => i.length).join(',')}] ${gasLimitOverride ? `with a gas limit override of ${gasLimitOverride}` : ''} and block number: ${await providerConfig.blockNumber} [Original before offset: ${originalBlockNumber}].`);\n    let haveRetriedForSuccessRate = false;\n    let haveRetriedForBlockHeader = false;\n    let blockHeaderRetryAttemptNumber = 0;\n    let haveIncrementedBlockHeaderFailureCounter = false;\n    let blockHeaderRolledBack = false;\n    let haveRetriedForBlockConflictError = false;\n    let haveRetriedForOutOfGas = false;\n    let haveRetriedForTimeout = false;\n    let haveRetriedForUnknownReason = false;\n    let finalAttemptNumber = 1;\n    let expectedCallsMade = quoteStates.length;\n    let totalCallsMade = 0;\n    const {\n      results: quoteResults,\n      blockNumber,\n      approxGasUsedPerSuccessCall\n    } = await retry(async (_bail, attemptNumber) => {\n      haveIncrementedBlockHeaderFailureCounter = false;\n      finalAttemptNumber = attemptNumber;\n      const [success, failed, pending] = this.partitionQuotes(quoteStates);\n      log.info(`Starting attempt: ${attemptNumber}.\n          Currently ${success.length} success, ${failed.length} failed, ${pending.length} pending.\n          Gas limit override: ${gasLimitOverride} Block number override: ${providerConfig.blockNumber}.`);\n      quoteStates = await Promise.all(_.map(quoteStates, async (quoteState, idx) => {\n        if (quoteState.status == 'success') {\n          return quoteState;\n        } // QuoteChunk is pending or failed, so we try again\n\n\n        const {\n          inputs\n        } = quoteState;\n\n        try {\n          totalCallsMade = totalCallsMade + 1;\n          const results = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n            address: this.quoterAddress,\n            contractInterface: IQuoterV2__factory.createInterface(),\n            functionName,\n            functionParams: inputs,\n            providerConfig,\n            additionalConfig: {\n              gasLimitPerCallOverride: gasLimitOverride\n            }\n          });\n          const successRateError = this.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n\n          if (successRateError) {\n            return {\n              status: 'failed',\n              inputs,\n              reason: successRateError,\n              results\n            };\n          }\n\n          return {\n            status: 'success',\n            inputs,\n            results\n          };\n        } catch (err) {\n          // Error from providers have huge messages that include all the calldata and fill the logs.\n          // Catch them and rethrow with shorter message.\n          if (err.message.includes('header not found')) {\n            return {\n              status: 'failed',\n              inputs,\n              reason: new ProviderBlockHeaderError(err.message.slice(0, 500))\n            };\n          }\n\n          if (err.message.includes('timeout')) {\n            return {\n              status: 'failed',\n              inputs,\n              reason: new ProviderTimeoutError(`Req ${idx}/${quoteStates.length}. Request had ${inputs.length} inputs. ${err.message.slice(0, 500)}`)\n            };\n          }\n\n          if (err.message.includes('out of gas')) {\n            return {\n              status: 'failed',\n              inputs,\n              reason: new ProviderGasError(err.message.slice(0, 500))\n            };\n          }\n\n          return {\n            status: 'failed',\n            inputs,\n            reason: new Error(`Unknown error from provider: ${err.message.slice(0, 500)}`)\n          };\n        }\n      }));\n      const [successfulQuoteStates, failedQuoteStates, pendingQuoteStates] = this.partitionQuotes(quoteStates);\n\n      if (pendingQuoteStates.length > 0) {\n        throw new Error('Pending quote after waiting for all promises.');\n      }\n\n      let retryAll = false;\n      const blockNumberError = this.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride); // If there is a block number conflict we retry all the quotes.\n\n      if (blockNumberError) {\n        retryAll = true;\n      }\n\n      const reasonForFailureStr = _.map(failedQuoteStates, failedQuoteState => failedQuoteState.reason.name).join(', ');\n\n      if (failedQuoteStates.length > 0) {\n        log.info(`On attempt ${attemptNumber}: ${failedQuoteStates.length}/${quoteStates.length} quotes failed. Reasons: ${reasonForFailureStr}`);\n\n        for (const failedQuoteState of failedQuoteStates) {\n          const {\n            reason: error\n          } = failedQuoteState;\n          log.info({\n            error\n          }, `[QuoteFetchError] Attempt ${attemptNumber}. ${error.message}`);\n\n          if (error instanceof BlockConflictError) {\n            if (!haveRetriedForBlockConflictError) {\n              metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForBlockConflictError = true;\n            }\n\n            retryAll = true;\n          } else if (error instanceof ProviderBlockHeaderError) {\n            if (!haveRetriedForBlockHeader) {\n              metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForBlockHeader = true;\n            } // Ensure that if multiple calls fail due to block header in the current pending batch,\n            // we only count once.\n\n\n            if (!haveIncrementedBlockHeaderFailureCounter) {\n              blockHeaderRetryAttemptNumber = blockHeaderRetryAttemptNumber + 1;\n              haveIncrementedBlockHeaderFailureCounter = true;\n            }\n\n            if (rollback.enabled) {\n              const {\n                rollbackBlockOffset,\n                attemptsBeforeRollback\n              } = rollback;\n\n              if (blockHeaderRetryAttemptNumber >= attemptsBeforeRollback && !blockHeaderRolledBack) {\n                log.info(`Attempt ${attemptNumber}. Have failed due to block header ${blockHeaderRetryAttemptNumber - 1} times. Rolling back block number by ${rollbackBlockOffset} for next retry`);\n                providerConfig.blockNumber = providerConfig.blockNumber ? (await providerConfig.blockNumber) + rollbackBlockOffset : (await this.provider.getBlockNumber()) + rollbackBlockOffset;\n                retryAll = true;\n                blockHeaderRolledBack = true;\n              }\n            }\n          } else if (error instanceof ProviderTimeoutError) {\n            if (!haveRetriedForTimeout) {\n              metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForTimeout = true;\n            }\n          } else if (error instanceof ProviderGasError) {\n            if (!haveRetriedForOutOfGas) {\n              metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForOutOfGas = true;\n            }\n\n            gasLimitOverride = this.gasErrorFailureOverride.gasLimitOverride;\n            multicallChunk = this.gasErrorFailureOverride.multicallChunk;\n            retryAll = true;\n          } else if (error instanceof SuccessRateError) {\n            if (!haveRetriedForSuccessRate) {\n              metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForSuccessRate = true; // Low success rate can indicate too little gas given to each call.\n\n              gasLimitOverride = this.successRateFailureOverrides.gasLimitOverride;\n              multicallChunk = this.successRateFailureOverrides.multicallChunk;\n              retryAll = true;\n            }\n          } else {\n            if (!haveRetriedForUnknownReason) {\n              metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n              haveRetriedForUnknownReason = true;\n            }\n          }\n        }\n      }\n\n      if (retryAll) {\n        log.info(`Attempt ${attemptNumber}. Resetting all requests to pending for next attempt.`);\n        const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n\n        const inputsChunked = _.chunk(inputs, normalizedChunk);\n\n        quoteStates = _.map(inputsChunked, inputChunk => {\n          return {\n            status: 'pending',\n            inputs: inputChunk\n          };\n        });\n      }\n\n      if (failedQuoteStates.length > 0) {\n        // TODO: Work with Arbitrum to find a solution for making large multicalls with gas limits that always\n        // successfully.\n        //\n        // On Arbitrum we can not set a gas limit for every call in the multicall and guarantee that\n        // we will not run out of gas on the node. This is because they have a different way of accounting\n        // for gas, that seperates storage and compute gas costs, and we can not cover both in a single limit.\n        //\n        // To work around this and avoid throwing errors when really we just couldn't get a quote, we catch this\n        // case and return 0 quotes found.\n        if ((this.chainId == ChainId.ARBITRUM_ONE || this.chainId == ChainId.ARBITRUM_RINKEBY) && _.every(failedQuoteStates, failedQuoteState => failedQuoteState.reason instanceof ProviderGasError) && attemptNumber == this.retryOptions.retries) {\n          log.error(`Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.`);\n          return {\n            results: [],\n            blockNumber: BigNumber.from(0),\n            approxGasUsedPerSuccessCall: 0\n          };\n        }\n\n        throw new Error(`Failed to get ${failedQuoteStates.length} quotes. Reasons: ${reasonForFailureStr}`);\n      }\n\n      const callResults = _.map(successfulQuoteStates, quoteState => quoteState.results);\n\n      return {\n        results: _.flatMap(callResults, result => result.results),\n        blockNumber: BigNumber.from(callResults[0].blockNumber),\n        approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, result => result.approxGasUsedPerSuccessCall), 100)\n      };\n    }, {\n      retries: DEFAULT_BATCH_RETRIES,\n      ...this.retryOptions\n    });\n    const routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n    metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n    metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n    metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n    metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n    metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n\n    const [successfulQuotes, failedQuotes] = _(routesQuotes).flatMap(routeWithQuotes => routeWithQuotes[1]).partition(quote => quote.quote != null).value();\n\n    log.info(`Got ${successfulQuotes.length} successful quotes, ${failedQuotes.length} failed quotes. Took ${finalAttemptNumber - 1} attempt loops. Total calls made to provider: ${totalCallsMade}. Have retried for timeout: ${haveRetriedForTimeout}`);\n    return {\n      routesWithQuotes: routesQuotes,\n      blockNumber\n    };\n  }\n\n  partitionQuotes(quoteStates) {\n    const successfulQuoteStates = _.filter(quoteStates, quoteState => quoteState.status == 'success');\n\n    const failedQuoteStates = _.filter(quoteStates, quoteState => quoteState.status == 'failed');\n\n    const pendingQuoteStates = _.filter(quoteStates, quoteState => quoteState.status == 'pending');\n\n    return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n  }\n\n  processQuoteResults(quoteResults, routes, amounts) {\n    const routesQuotes = [];\n\n    const quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n\n    const debugFailedQuotes = [];\n\n    for (let i = 0; i < quotesResultsByRoute.length; i++) {\n      const route = routes[i];\n      const quoteResults = quotesResultsByRoute[i];\n\n      const quotes = _.map(quoteResults, (quoteResult, index) => {\n        const amount = amounts[index];\n\n        if (!quoteResult.success) {\n          const percent = 100 / amounts.length * (index + 1);\n          const amountStr = amount.toFixed(2);\n          const routeStr = routeToString(route);\n          debugFailedQuotes.push({\n            route: routeStr,\n            percent,\n            amount: amountStr\n          });\n          return {\n            amount,\n            quote: null,\n            sqrtPriceX96AfterList: null,\n            gasEstimate: null,\n            initializedTicksCrossedList: null\n          };\n        }\n\n        return {\n          amount,\n          quote: quoteResult.result[0],\n          sqrtPriceX96AfterList: quoteResult.result[1],\n          initializedTicksCrossedList: quoteResult.result[2],\n          gasEstimate: quoteResult.result[3]\n        };\n      });\n\n      routesQuotes.push([route, quotes]);\n    } // For routes and amounts that we failed to get a quote for, group them by route\n    // and batch them together before logging to minimize number of logs.\n\n\n    const debugChunk = 80;\n\n    _.forEach(_.chunk(debugFailedQuotes, debugChunk), (quotes, idx) => {\n      const failedQuotesByRoute = _.groupBy(quotes, q => q.route);\n\n      const failedFlat = _.mapValues(failedQuotesByRoute, f => _(f).map(f => `${f.percent}%[${f.amount}]`).join(','));\n\n      log.info({\n        failedQuotes: _.map(failedFlat, (amounts, routeStr) => `${routeStr} : ${amounts}`)\n      }, `Failed quotes for routes Part ${idx}/${Math.ceil(debugFailedQuotes.length / debugChunk)}`);\n    });\n\n    return routesQuotes;\n  }\n\n  validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n    if (successfulQuoteStates.length <= 1) {\n      return null;\n    }\n\n    const results = _.map(successfulQuoteStates, quoteState => quoteState.results);\n\n    const blockNumbers = _.map(results, result => result.blockNumber);\n\n    const uniqBlocks = _(blockNumbers).map(blockNumber => blockNumber.toNumber()).uniq().value();\n\n    if (uniqBlocks.length == 1) {\n      return null;\n    }\n    /* if (\n      uniqBlocks.length == 2 &&\n      Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n    ) {\n      return null;\n    } */\n\n\n    return new BlockConflictError(`Quotes returned from different blocks. ${uniqBlocks}. ${totalCalls} calls were made with gas limit ${gasLimitOverride}`);\n  }\n\n  validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n    const numResults = allResults.length;\n    const numSuccessResults = allResults.filter(result => result.success).length;\n    const successRate = 1.0 * numSuccessResults / numResults;\n    const {\n      quoteMinSuccessRate\n    } = this.batchParams;\n\n    if (successRate < quoteMinSuccessRate) {\n      if (haveRetriedForSuccessRate) {\n        log.info(`Quote success rate still below threshold despite retry. Continuing. ${quoteMinSuccessRate}: ${successRate}`);\n        return;\n      }\n\n      return new SuccessRateError(`Quote success rate below threshold of ${quoteMinSuccessRate}: ${successRate}`);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../../src/providers/v3/quote-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport { BigNumber } from 'ethers';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { IQuoterV2__factory } from '../../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../../util';\nimport { QUOTER_V2_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { routeToString } from '../../util/routes';\nexport class BlockConflictError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BlockConflictError';\n    }\n}\nexport class SuccessRateError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SuccessRateError';\n    }\n}\nexport class ProviderBlockHeaderError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderBlockHeaderError';\n    }\n}\nexport class ProviderTimeoutError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderTimeoutError';\n    }\n}\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\nexport class ProviderGasError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderGasError';\n    }\n}\nconst DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes quotes for V3. For V3, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. This is because computing quotes off-chain would\n * require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class V3QuoteProvider\n */\nexport class V3QuoteProvider {\n    /**\n     * Creates an instance of V3QuoteProvider.\n     *\n     * @param chainId The chain to get quotes for.\n     * @param provider The web 3 provider.\n     * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n     * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n     * @param retryOptions The retry options for each call to the multicall.\n     * @param batchParams The parameters for each batched call to the multicall.\n     * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n     * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n     * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n     * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n     */\n    constructor(chainId, provider, \n    // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n    multicall2Provider, retryOptions = {\n        retries: DEFAULT_BATCH_RETRIES,\n        minTimeout: 25,\n        maxTimeout: 250,\n    }, batchParams = {\n        multicallChunk: 150,\n        gasLimitPerCall: 1000000,\n        quoteMinSuccessRate: 0.2,\n    }, gasErrorFailureOverride = {\n        gasLimitOverride: 1500000,\n        multicallChunk: 100,\n    }, successRateFailureOverrides = {\n        gasLimitOverride: 1300000,\n        multicallChunk: 110,\n    }, blockNumberConfig = {\n        baseBlockOffset: 0,\n        rollback: { enabled: false },\n    }, quoterAddressOverride) {\n        this.chainId = chainId;\n        this.provider = provider;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        this.batchParams = batchParams;\n        this.gasErrorFailureOverride = gasErrorFailureOverride;\n        this.successRateFailureOverrides = successRateFailureOverrides;\n        this.blockNumberConfig = blockNumberConfig;\n        this.quoterAddressOverride = quoterAddressOverride;\n        const quoterAddress = quoterAddressOverride\n            ? quoterAddressOverride\n            : QUOTER_V2_ADDRESS;\n        if (!quoterAddress) {\n            throw new Error(`No address for Uniswap QuoterV2 Contract on chain id: ${chainId}`);\n        }\n        this.quoterAddress = quoterAddress;\n    }\n    async getQuotesManyExactIn(amountIns, routes, providerConfig) {\n        return this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig);\n    }\n    async getQuotesManyExactOut(amountOuts, routes, providerConfig) {\n        return this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig);\n    }\n    async getQuotesManyData(amounts, routes, functionName, _providerConfig) {\n        var _a;\n        let multicallChunk = this.batchParams.multicallChunk;\n        let gasLimitOverride = this.batchParams.gasLimitPerCall;\n        const { baseBlockOffset, rollback } = this.blockNumberConfig;\n        // Apply the base block offset if provided\n        const originalBlockNumber = await this.provider.getBlockNumber();\n        const providerConfig = {\n            ..._providerConfig,\n            blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset,\n        };\n        const inputs = _(routes)\n            .flatMap((route) => {\n            const encodedRoute = encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n            );\n            const routeInputs = amounts.map((amount) => [\n                encodedRoute,\n                `0x${amount.quotient.toString(16)}`,\n            ]);\n            return routeInputs;\n        })\n            .value();\n        const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n        const inputsChunked = _.chunk(inputs, normalizedChunk);\n        let quoteStates = _.map(inputsChunked, (inputChunk) => {\n            return {\n                status: 'pending',\n                inputs: inputChunk,\n            };\n        });\n        log.info(`About to get ${inputs.length} quotes in chunks of ${normalizedChunk} [${_.map(inputsChunked, (i) => i.length).join(',')}] ${gasLimitOverride\n            ? `with a gas limit override of ${gasLimitOverride}`\n            : ''} and block number: ${await providerConfig.blockNumber} [Original before offset: ${originalBlockNumber}].`);\n        let haveRetriedForSuccessRate = false;\n        let haveRetriedForBlockHeader = false;\n        let blockHeaderRetryAttemptNumber = 0;\n        let haveIncrementedBlockHeaderFailureCounter = false;\n        let blockHeaderRolledBack = false;\n        let haveRetriedForBlockConflictError = false;\n        let haveRetriedForOutOfGas = false;\n        let haveRetriedForTimeout = false;\n        let haveRetriedForUnknownReason = false;\n        let finalAttemptNumber = 1;\n        let expectedCallsMade = quoteStates.length;\n        let totalCallsMade = 0;\n        const { results: quoteResults, blockNumber, approxGasUsedPerSuccessCall, } = await retry(async (_bail, attemptNumber) => {\n            haveIncrementedBlockHeaderFailureCounter = false;\n            finalAttemptNumber = attemptNumber;\n            const [success, failed, pending] = this.partitionQuotes(quoteStates);\n            log.info(`Starting attempt: ${attemptNumber}.\n          Currently ${success.length} success, ${failed.length} failed, ${pending.length} pending.\n          Gas limit override: ${gasLimitOverride} Block number override: ${providerConfig.blockNumber}.`);\n            quoteStates = await Promise.all(_.map(quoteStates, async (quoteState, idx) => {\n                if (quoteState.status == 'success') {\n                    return quoteState;\n                }\n                // QuoteChunk is pending or failed, so we try again\n                const { inputs } = quoteState;\n                try {\n                    totalCallsMade = totalCallsMade + 1;\n                    const results = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n                        address: this.quoterAddress,\n                        contractInterface: IQuoterV2__factory.createInterface(),\n                        functionName,\n                        functionParams: inputs,\n                        providerConfig,\n                        additionalConfig: {\n                            gasLimitPerCallOverride: gasLimitOverride,\n                        },\n                    });\n                    const successRateError = this.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n                    if (successRateError) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: successRateError,\n                            results,\n                        };\n                    }\n                    return {\n                        status: 'success',\n                        inputs,\n                        results,\n                    };\n                }\n                catch (err) {\n                    // Error from providers have huge messages that include all the calldata and fill the logs.\n                    // Catch them and rethrow with shorter message.\n                    if (err.message.includes('header not found')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderBlockHeaderError(err.message.slice(0, 500)),\n                        };\n                    }\n                    if (err.message.includes('timeout')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderTimeoutError(`Req ${idx}/${quoteStates.length}. Request had ${inputs.length} inputs. ${err.message.slice(0, 500)}`),\n                        };\n                    }\n                    if (err.message.includes('out of gas')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderGasError(err.message.slice(0, 500)),\n                        };\n                    }\n                    return {\n                        status: 'failed',\n                        inputs,\n                        reason: new Error(`Unknown error from provider: ${err.message.slice(0, 500)}`),\n                    };\n                }\n            }));\n            const [successfulQuoteStates, failedQuoteStates, pendingQuoteStates] = this.partitionQuotes(quoteStates);\n            if (pendingQuoteStates.length > 0) {\n                throw new Error('Pending quote after waiting for all promises.');\n            }\n            let retryAll = false;\n            const blockNumberError = this.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride);\n            // If there is a block number conflict we retry all the quotes.\n            if (blockNumberError) {\n                retryAll = true;\n            }\n            const reasonForFailureStr = _.map(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason.name).join(', ');\n            if (failedQuoteStates.length > 0) {\n                log.info(`On attempt ${attemptNumber}: ${failedQuoteStates.length}/${quoteStates.length} quotes failed. Reasons: ${reasonForFailureStr}`);\n                for (const failedQuoteState of failedQuoteStates) {\n                    const { reason: error } = failedQuoteState;\n                    log.info({ error }, `[QuoteFetchError] Attempt ${attemptNumber}. ${error.message}`);\n                    if (error instanceof BlockConflictError) {\n                        if (!haveRetriedForBlockConflictError) {\n                            metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockConflictError = true;\n                        }\n                        retryAll = true;\n                    }\n                    else if (error instanceof ProviderBlockHeaderError) {\n                        if (!haveRetriedForBlockHeader) {\n                            metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockHeader = true;\n                        }\n                        // Ensure that if multiple calls fail due to block header in the current pending batch,\n                        // we only count once.\n                        if (!haveIncrementedBlockHeaderFailureCounter) {\n                            blockHeaderRetryAttemptNumber =\n                                blockHeaderRetryAttemptNumber + 1;\n                            haveIncrementedBlockHeaderFailureCounter = true;\n                        }\n                        if (rollback.enabled) {\n                            const { rollbackBlockOffset, attemptsBeforeRollback } = rollback;\n                            if (blockHeaderRetryAttemptNumber >= attemptsBeforeRollback &&\n                                !blockHeaderRolledBack) {\n                                log.info(`Attempt ${attemptNumber}. Have failed due to block header ${blockHeaderRetryAttemptNumber - 1} times. Rolling back block number by ${rollbackBlockOffset} for next retry`);\n                                providerConfig.blockNumber = providerConfig.blockNumber\n                                    ? (await providerConfig.blockNumber) + rollbackBlockOffset\n                                    : (await this.provider.getBlockNumber()) +\n                                        rollbackBlockOffset;\n                                retryAll = true;\n                                blockHeaderRolledBack = true;\n                            }\n                        }\n                    }\n                    else if (error instanceof ProviderTimeoutError) {\n                        if (!haveRetriedForTimeout) {\n                            metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForTimeout = true;\n                        }\n                    }\n                    else if (error instanceof ProviderGasError) {\n                        if (!haveRetriedForOutOfGas) {\n                            metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForOutOfGas = true;\n                        }\n                        gasLimitOverride = this.gasErrorFailureOverride.gasLimitOverride;\n                        multicallChunk = this.gasErrorFailureOverride.multicallChunk;\n                        retryAll = true;\n                    }\n                    else if (error instanceof SuccessRateError) {\n                        if (!haveRetriedForSuccessRate) {\n                            metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForSuccessRate = true;\n                            // Low success rate can indicate too little gas given to each call.\n                            gasLimitOverride =\n                                this.successRateFailureOverrides.gasLimitOverride;\n                            multicallChunk =\n                                this.successRateFailureOverrides.multicallChunk;\n                            retryAll = true;\n                        }\n                    }\n                    else {\n                        if (!haveRetriedForUnknownReason) {\n                            metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForUnknownReason = true;\n                        }\n                    }\n                }\n            }\n            if (retryAll) {\n                log.info(`Attempt ${attemptNumber}. Resetting all requests to pending for next attempt.`);\n                const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                const inputsChunked = _.chunk(inputs, normalizedChunk);\n                quoteStates = _.map(inputsChunked, (inputChunk) => {\n                    return {\n                        status: 'pending',\n                        inputs: inputChunk,\n                    };\n                });\n            }\n            if (failedQuoteStates.length > 0) {\n                // TODO: Work with Arbitrum to find a solution for making large multicalls with gas limits that always\n                // successfully.\n                //\n                // On Arbitrum we can not set a gas limit for every call in the multicall and guarantee that\n                // we will not run out of gas on the node. This is because they have a different way of accounting\n                // for gas, that seperates storage and compute gas costs, and we can not cover both in a single limit.\n                //\n                // To work around this and avoid throwing errors when really we just couldn't get a quote, we catch this\n                // case and return 0 quotes found.\n                if ((this.chainId == ChainId.ARBITRUM_ONE ||\n                    this.chainId == ChainId.ARBITRUM_RINKEBY) &&\n                    _.every(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason instanceof ProviderGasError) &&\n                    attemptNumber == this.retryOptions.retries) {\n                    log.error(`Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.`);\n                    return {\n                        results: [],\n                        blockNumber: BigNumber.from(0),\n                        approxGasUsedPerSuccessCall: 0,\n                    };\n                }\n                throw new Error(`Failed to get ${failedQuoteStates.length} quotes. Reasons: ${reasonForFailureStr}`);\n            }\n            const callResults = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n            return {\n                results: _.flatMap(callResults, (result) => result.results),\n                blockNumber: BigNumber.from(callResults[0].blockNumber),\n                approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, (result) => result.approxGasUsedPerSuccessCall), 100),\n            };\n        }, {\n            retries: DEFAULT_BATCH_RETRIES,\n            ...this.retryOptions,\n        });\n        const routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n        metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n        const [successfulQuotes, failedQuotes] = _(routesQuotes)\n            .flatMap((routeWithQuotes) => routeWithQuotes[1])\n            .partition((quote) => quote.quote != null)\n            .value();\n        log.info(`Got ${successfulQuotes.length} successful quotes, ${failedQuotes.length} failed quotes. Took ${finalAttemptNumber - 1} attempt loops. Total calls made to provider: ${totalCallsMade}. Have retried for timeout: ${haveRetriedForTimeout}`);\n        return { routesWithQuotes: routesQuotes, blockNumber };\n    }\n    partitionQuotes(quoteStates) {\n        const successfulQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'success');\n        const failedQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'failed');\n        const pendingQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'pending');\n        return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n    }\n    processQuoteResults(quoteResults, routes, amounts) {\n        const routesQuotes = [];\n        const quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n        const debugFailedQuotes = [];\n        for (let i = 0; i < quotesResultsByRoute.length; i++) {\n            const route = routes[i];\n            const quoteResults = quotesResultsByRoute[i];\n            const quotes = _.map(quoteResults, (quoteResult, index) => {\n                const amount = amounts[index];\n                if (!quoteResult.success) {\n                    const percent = (100 / amounts.length) * (index + 1);\n                    const amountStr = amount.toFixed(2);\n                    const routeStr = routeToString(route);\n                    debugFailedQuotes.push({\n                        route: routeStr,\n                        percent,\n                        amount: amountStr,\n                    });\n                    return {\n                        amount,\n                        quote: null,\n                        sqrtPriceX96AfterList: null,\n                        gasEstimate: null,\n                        initializedTicksCrossedList: null,\n                    };\n                }\n                return {\n                    amount,\n                    quote: quoteResult.result[0],\n                    sqrtPriceX96AfterList: quoteResult.result[1],\n                    initializedTicksCrossedList: quoteResult.result[2],\n                    gasEstimate: quoteResult.result[3],\n                };\n            });\n            routesQuotes.push([route, quotes]);\n        }\n        // For routes and amounts that we failed to get a quote for, group them by route\n        // and batch them together before logging to minimize number of logs.\n        const debugChunk = 80;\n        _.forEach(_.chunk(debugFailedQuotes, debugChunk), (quotes, idx) => {\n            const failedQuotesByRoute = _.groupBy(quotes, (q) => q.route);\n            const failedFlat = _.mapValues(failedQuotesByRoute, (f) => _(f)\n                .map((f) => `${f.percent}%[${f.amount}]`)\n                .join(','));\n            log.info({\n                failedQuotes: _.map(failedFlat, (amounts, routeStr) => `${routeStr} : ${amounts}`),\n            }, `Failed quotes for routes Part ${idx}/${Math.ceil(debugFailedQuotes.length / debugChunk)}`);\n        });\n        return routesQuotes;\n    }\n    validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n        if (successfulQuoteStates.length <= 1) {\n            return null;\n        }\n        const results = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n        const blockNumbers = _.map(results, (result) => result.blockNumber);\n        const uniqBlocks = _(blockNumbers)\n            .map((blockNumber) => blockNumber.toNumber())\n            .uniq()\n            .value();\n        if (uniqBlocks.length == 1) {\n            return null;\n        }\n        /* if (\n          uniqBlocks.length == 2 &&\n          Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n        ) {\n          return null;\n        } */\n        return new BlockConflictError(`Quotes returned from different blocks. ${uniqBlocks}. ${totalCalls} calls were made with gas limit ${gasLimitOverride}`);\n    }\n    validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n        const numResults = allResults.length;\n        const numSuccessResults = allResults.filter((result) => result.success).length;\n        const successRate = (1.0 * numSuccessResults) / numResults;\n        const { quoteMinSuccessRate } = this.batchParams;\n        if (successRate < quoteMinSuccessRate) {\n            if (haveRetriedForSuccessRate) {\n                log.info(`Quote success rate still below threshold despite retry. Continuing. ${quoteMinSuccessRate}: ${successRate}`);\n                return;\n            }\n            return new SuccessRateError(`Quote success rate below threshold of ${quoteMinSuccessRate}: ${successRate}`);\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVvdGUtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvcHJvdmlkZXJzL3YzL3F1b3RlLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFBeUIsT0FBTyxJQUFJLEtBQUssRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN0RSxPQUFPLEVBQUUsU0FBUyxFQUFhLE1BQU0sUUFBUSxDQUFDO0FBQzlDLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxZQUFZLENBQUM7QUFFL0IsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDakYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDL0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFekQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQThCbEQsTUFBTSxPQUFPLGtCQUFtQixTQUFRLEtBQUs7SUFBN0M7O1FBQ1MsU0FBSSxHQUFHLG9CQUFvQixDQUFDO0lBQ3JDLENBQUM7Q0FBQTtBQUNELE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxLQUFLO0lBQTNDOztRQUNTLFNBQUksR0FBRyxrQkFBa0IsQ0FBQztJQUNuQyxDQUFDO0NBQUE7QUFFRCxNQUFNLE9BQU8sd0JBQXlCLFNBQVEsS0FBSztJQUFuRDs7UUFDUyxTQUFJLEdBQUcsMEJBQTBCLENBQUM7SUFDM0MsQ0FBQztDQUFBO0FBRUQsTUFBTSxPQUFPLG9CQUFxQixTQUFRLEtBQUs7SUFBL0M7O1FBQ1MsU0FBSSxHQUFHLHNCQUFzQixDQUFDO0lBQ3ZD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"]},"metadata":{},"sourceType":"module"}