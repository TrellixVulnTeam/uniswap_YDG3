{"ast":null,"code":"/**\n * Mnemonist Vantage Point Tree\n * =============================\n *\n * JavaScript implementation of the Vantage Point Tree storing the binary\n * tree as a flat byte array.\n *\n * Note that a VPTree has worst cases and is likely not to be perfectly\n * balanced because of median ambiguity. It is therefore not suitable\n * for hairballs and tiny datasets.\n *\n * [Reference]:\n * https://en.wikipedia.org/wiki/Vantage-point_tree\n */\nvar iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js'),\n    inplaceQuickSortIndices = require('./sort/quick.js').inplaceQuickSortIndices,\n    lowerBoundIndices = require('./utils/binary-search.js').lowerBoundIndices,\n    Heap = require('./heap.js');\n\nvar getPointerArray = typed.getPointerArray; // TODO: implement vantage point selection techniques (by swapping with last)\n// TODO: is this required to implement early termination for k <= size?\n\n/**\n * Heap comparator used by the #.nearestNeighbors method.\n */\n\nfunction comparator(a, b) {\n  if (a.distance < b.distance) return 1;\n  if (a.distance > b.distance) return -1;\n  return 0;\n}\n/**\n * Function used to create the binary tree.\n *\n * @param  {function}     distance - Distance function to use.\n * @param  {array}        items    - Items to index (will be mutated).\n * @param  {array}        indices  - Indexes of the items.\n * @return {Float64Array}          - The flat binary tree.\n */\n\n\nfunction createBinaryTree(distance, items, indices) {\n  var N = indices.length;\n  var PointerArray = getPointerArray(N);\n  var C = 0,\n      nodes = new PointerArray(N),\n      lefts = new PointerArray(N),\n      rights = new PointerArray(N),\n      mus = new Float64Array(N),\n      stack = [0, 0, N],\n      distances = new Float64Array(N),\n      nodeIndex,\n      vantagePoint,\n      medianIndex,\n      lo,\n      hi,\n      mid,\n      mu,\n      i,\n      l;\n\n  while (stack.length) {\n    hi = stack.pop();\n    lo = stack.pop();\n    nodeIndex = stack.pop(); // Getting our vantage point\n\n    vantagePoint = indices[hi - 1];\n    hi--;\n    l = hi - lo; // Storing vantage point\n\n    nodes[nodeIndex] = vantagePoint; // We are in a leaf\n\n    if (l === 0) continue; // We only have two elements, the second one has to go right\n\n    if (l === 1) {\n      // We put remaining item to the right\n      mu = distance(items[vantagePoint], items[indices[lo]]);\n      mus[nodeIndex] = mu; // Right\n\n      C++;\n      rights[nodeIndex] = C;\n      nodes[C] = indices[lo];\n      continue;\n    } // Computing distance from vantage point to other points\n\n\n    for (i = lo; i < hi; i++) {\n      distances[indices[i]] = distance(items[vantagePoint], items[indices[i]]);\n    }\n\n    inplaceQuickSortIndices(distances, indices, lo, hi); // Finding median of distances\n\n    medianIndex = lo + l / 2 - 1; // Need to interpolate?\n\n    if (medianIndex === (medianIndex | 0)) {\n      mu = (distances[indices[medianIndex]] + distances[indices[medianIndex + 1]]) / 2;\n    } else {\n      mu = distances[indices[Math.ceil(medianIndex)]];\n    } // Storing mu\n\n\n    mus[nodeIndex] = mu;\n    mid = lowerBoundIndices(distances, indices, mu, lo, hi); // console.log('Vantage point', items[vantagePoint], vantagePoint);\n    // console.log('mu =', mu);\n    // console.log('lo =', lo);\n    // console.log('hi =', hi);\n    // console.log('mid =', mid);\n    // console.log('need to split', Array.from(indices).slice(lo, hi).map(i => {\n    //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n    // }));\n    // Right\n\n    if (hi - mid > 0) {\n      C++;\n      rights[nodeIndex] = C;\n      stack.push(C, mid, hi); // console.log('Went right with ', Array.from(indices).slice(mid, hi).map(i => {\n      //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n      // }));\n    } // Left\n\n\n    if (mid - lo > 0) {\n      C++;\n      lefts[nodeIndex] = C;\n      stack.push(C, lo, mid); // console.log('Went left with', Array.from(indices).slice(lo, mid).map(i => {\n      //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n      // }));\n    } // console.log();\n\n  }\n\n  return {\n    nodes: nodes,\n    lefts: lefts,\n    rights: rights,\n    mus: mus\n  };\n}\n/**\n * VPTree.\n *\n * @constructor\n * @param {function} distance - Distance function to use.\n * @param {Iterable} items    - Items to store.\n */\n\n\nfunction VPTree(distance, items) {\n  if (typeof distance !== 'function') throw new Error('mnemonist/VPTree.constructor: given `distance` must be a function.');\n  if (!items) throw new Error('mnemonist/VPTree.constructor: you must provide items to the tree. A VPTree cannot be updated after its creation.'); // Properties\n\n  this.distance = distance;\n  this.heap = new Heap(comparator);\n  this.D = 0;\n  var arrays = iterables.toArrayWithIndices(items);\n  this.items = arrays[0];\n  var indices = arrays[1]; // Creating the binary tree\n\n  this.size = indices.length;\n  var result = createBinaryTree(distance, this.items, indices);\n  this.nodes = result.nodes;\n  this.lefts = result.lefts;\n  this.rights = result.rights;\n  this.mus = result.mus;\n}\n/**\n * Function used to retrieve the k nearest neighbors of the query.\n *\n * @param  {number} k     - Number of neighbors to retrieve.\n * @param  {any}    query - The query.\n * @return {array}\n */\n\n\nVPTree.prototype.nearestNeighbors = function (k, query) {\n  var neighbors = this.heap,\n      stack = [0],\n      tau = Infinity,\n      nodeIndex,\n      itemIndex,\n      vantagePoint,\n      leftIndex,\n      rightIndex,\n      mu,\n      d;\n  this.D = 0;\n\n  while (stack.length) {\n    nodeIndex = stack.pop();\n    itemIndex = this.nodes[nodeIndex];\n    vantagePoint = this.items[itemIndex]; // Distance between query & the current vantage point\n\n    d = this.distance(vantagePoint, query);\n    this.D++;\n\n    if (d < tau) {\n      neighbors.push({\n        distance: d,\n        item: vantagePoint\n      }); // Trimming\n\n      if (neighbors.size > k) neighbors.pop(); // Adjusting tau (only if we already have k items, else it stays Infinity)\n\n      if (neighbors.size >= k) tau = neighbors.peek().distance;\n    }\n\n    leftIndex = this.lefts[nodeIndex];\n    rightIndex = this.rights[nodeIndex]; // We are a leaf\n\n    if (!leftIndex && !rightIndex) continue;\n    mu = this.mus[nodeIndex];\n\n    if (d < mu) {\n      if (leftIndex && d < mu + tau) stack.push(leftIndex);\n      if (rightIndex && d >= mu - tau) // Might not be necessary to test d\n        stack.push(rightIndex);\n    } else {\n      if (rightIndex && d >= mu - tau) stack.push(rightIndex);\n      if (leftIndex && d < mu + tau) // Might not be necessary to test d\n        stack.push(leftIndex);\n    }\n  }\n\n  var array = new Array(neighbors.size);\n\n  for (var i = neighbors.size - 1; i >= 0; i--) {\n    array[i] = neighbors.pop();\n  }\n\n  return array;\n};\n/**\n * Function used to retrieve every neighbors of query in the given radius.\n *\n * @param  {number} radius - Radius.\n * @param  {any}    query  - The query.\n * @return {array}\n */\n\n\nVPTree.prototype.neighbors = function (radius, query) {\n  var neighbors = [],\n      stack = [0],\n      nodeIndex,\n      itemIndex,\n      vantagePoint,\n      leftIndex,\n      rightIndex,\n      mu,\n      d;\n  this.D = 0;\n\n  while (stack.length) {\n    nodeIndex = stack.pop();\n    itemIndex = this.nodes[nodeIndex];\n    vantagePoint = this.items[itemIndex]; // Distance between query & the current vantage point\n\n    d = this.distance(vantagePoint, query);\n    this.D++;\n    if (d <= radius) neighbors.push({\n      distance: d,\n      item: vantagePoint\n    });\n    leftIndex = this.lefts[nodeIndex];\n    rightIndex = this.rights[nodeIndex]; // We are a leaf\n\n    if (!leftIndex && !rightIndex) continue;\n    mu = this.mus[nodeIndex];\n\n    if (d < mu) {\n      if (leftIndex && d < mu + radius) stack.push(leftIndex);\n      if (rightIndex && d >= mu - radius) // Might not be necessary to test d\n        stack.push(rightIndex);\n    } else {\n      if (rightIndex && d >= mu - radius) stack.push(rightIndex);\n      if (leftIndex && d < mu + radius) // Might not be necessary to test d\n        stack.push(leftIndex);\n    }\n  }\n\n  return neighbors;\n};\n/**\n * Convenience known methods.\n */\n\n\nVPTree.prototype.inspect = function () {\n  var array = this.items.slice(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(array, 'constructor', {\n    value: VPTree,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') VPTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = VPTree.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a tree.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} distance - Distance function to use.\n * @return {VPTree}\n */\n\nVPTree.from = function (iterable, distance) {\n  return new VPTree(distance, iterable);\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = VPTree;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/vp-tree.js"],"names":["iterables","require","typed","inplaceQuickSortIndices","lowerBoundIndices","Heap","getPointerArray","comparator","a","b","distance","createBinaryTree","items","indices","N","length","PointerArray","C","nodes","lefts","rights","mus","Float64Array","stack","distances","nodeIndex","vantagePoint","medianIndex","lo","hi","mid","mu","i","l","pop","Math","ceil","push","VPTree","Error","heap","D","arrays","toArrayWithIndices","size","result","prototype","nearestNeighbors","k","query","neighbors","tau","Infinity","itemIndex","leftIndex","rightIndex","d","item","peek","array","Array","radius","inspect","slice","Object","defineProperty","value","enumerable","Symbol","for","from","iterable","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Vantage Point Tree\n * =============================\n *\n * JavaScript implementation of the Vantage Point Tree storing the binary\n * tree as a flat byte array.\n *\n * Note that a VPTree has worst cases and is likely not to be perfectly\n * balanced because of median ambiguity. It is therefore not suitable\n * for hairballs and tiny datasets.\n *\n * [Reference]:\n * https://en.wikipedia.org/wiki/Vantage-point_tree\n */\nvar iterables = require('./utils/iterables.js'),\n    typed = require('./utils/typed-arrays.js'),\n    inplaceQuickSortIndices = require('./sort/quick.js').inplaceQuickSortIndices,\n    lowerBoundIndices = require('./utils/binary-search.js').lowerBoundIndices,\n    Heap = require('./heap.js');\n\nvar getPointerArray = typed.getPointerArray;\n\n// TODO: implement vantage point selection techniques (by swapping with last)\n// TODO: is this required to implement early termination for k <= size?\n\n/**\n * Heap comparator used by the #.nearestNeighbors method.\n */\nfunction comparator(a, b) {\n  if (a.distance < b.distance)\n    return 1;\n\n  if (a.distance > b.distance)\n    return -1;\n\n  return 0;\n}\n\n/**\n * Function used to create the binary tree.\n *\n * @param  {function}     distance - Distance function to use.\n * @param  {array}        items    - Items to index (will be mutated).\n * @param  {array}        indices  - Indexes of the items.\n * @return {Float64Array}          - The flat binary tree.\n */\nfunction createBinaryTree(distance, items, indices) {\n  var N = indices.length;\n\n  var PointerArray = getPointerArray(N);\n\n  var C = 0,\n      nodes = new PointerArray(N),\n      lefts = new PointerArray(N),\n      rights = new PointerArray(N),\n      mus = new Float64Array(N),\n      stack = [0, 0, N],\n      distances = new Float64Array(N),\n      nodeIndex,\n      vantagePoint,\n      medianIndex,\n      lo,\n      hi,\n      mid,\n      mu,\n      i,\n      l;\n\n  while (stack.length) {\n    hi = stack.pop();\n    lo = stack.pop();\n    nodeIndex = stack.pop();\n\n    // Getting our vantage point\n    vantagePoint = indices[hi - 1];\n    hi--;\n\n    l = hi - lo;\n\n    // Storing vantage point\n    nodes[nodeIndex] = vantagePoint;\n\n    // We are in a leaf\n    if (l === 0)\n      continue;\n\n    // We only have two elements, the second one has to go right\n    if (l === 1) {\n\n      // We put remaining item to the right\n      mu = distance(items[vantagePoint], items[indices[lo]]);\n\n      mus[nodeIndex] = mu;\n\n      // Right\n      C++;\n      rights[nodeIndex] = C;\n      nodes[C] = indices[lo];\n\n      continue;\n    }\n\n    // Computing distance from vantage point to other points\n    for (i = lo; i < hi; i++)\n      distances[indices[i]] = distance(items[vantagePoint], items[indices[i]]);\n\n    inplaceQuickSortIndices(distances, indices, lo, hi);\n\n    // Finding median of distances\n    medianIndex = lo + (l / 2) - 1;\n\n    // Need to interpolate?\n    if (medianIndex === (medianIndex | 0)) {\n      mu = (\n        distances[indices[medianIndex]] +\n        distances[indices[medianIndex + 1]]\n      ) / 2;\n    }\n    else {\n      mu = distances[indices[Math.ceil(medianIndex)]];\n    }\n\n    // Storing mu\n    mus[nodeIndex] = mu;\n\n    mid = lowerBoundIndices(distances, indices, mu, lo, hi);\n\n    // console.log('Vantage point', items[vantagePoint], vantagePoint);\n    // console.log('mu =', mu);\n    // console.log('lo =', lo);\n    // console.log('hi =', hi);\n    // console.log('mid =', mid);\n\n    // console.log('need to split', Array.from(indices).slice(lo, hi).map(i => {\n    //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n    // }));\n\n    // Right\n    if (hi - mid > 0) {\n      C++;\n      rights[nodeIndex] = C;\n      stack.push(C, mid, hi);\n      // console.log('Went right with ', Array.from(indices).slice(mid, hi).map(i => {\n      //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n      // }));\n    }\n\n    // Left\n    if (mid - lo > 0) {\n      C++;\n      lefts[nodeIndex] = C;\n      stack.push(C, lo, mid);\n      // console.log('Went left with', Array.from(indices).slice(lo, mid).map(i => {\n      //   return [distances[i], distance(items[vantagePoint], items[i]), items[i]];\n      // }));\n    }\n\n    // console.log();\n  }\n\n  return {\n    nodes: nodes,\n    lefts: lefts,\n    rights: rights,\n    mus: mus\n  };\n}\n\n/**\n * VPTree.\n *\n * @constructor\n * @param {function} distance - Distance function to use.\n * @param {Iterable} items    - Items to store.\n */\nfunction VPTree(distance, items) {\n  if (typeof distance !== 'function')\n    throw new Error('mnemonist/VPTree.constructor: given `distance` must be a function.');\n\n  if (!items)\n    throw new Error('mnemonist/VPTree.constructor: you must provide items to the tree. A VPTree cannot be updated after its creation.');\n\n  // Properties\n  this.distance = distance;\n  this.heap = new Heap(comparator);\n  this.D = 0;\n\n  var arrays = iterables.toArrayWithIndices(items);\n  this.items = arrays[0];\n  var indices = arrays[1];\n\n  // Creating the binary tree\n  this.size = indices.length;\n\n  var result = createBinaryTree(distance, this.items, indices);\n\n  this.nodes = result.nodes;\n  this.lefts = result.lefts;\n  this.rights = result.rights;\n  this.mus = result.mus;\n}\n\n/**\n * Function used to retrieve the k nearest neighbors of the query.\n *\n * @param  {number} k     - Number of neighbors to retrieve.\n * @param  {any}    query - The query.\n * @return {array}\n */\nVPTree.prototype.nearestNeighbors = function(k, query) {\n  var neighbors = this.heap,\n      stack = [0],\n      tau = Infinity,\n      nodeIndex,\n      itemIndex,\n      vantagePoint,\n      leftIndex,\n      rightIndex,\n      mu,\n      d;\n\n  this.D = 0;\n\n  while (stack.length) {\n    nodeIndex = stack.pop();\n    itemIndex = this.nodes[nodeIndex];\n    vantagePoint = this.items[itemIndex];\n\n    // Distance between query & the current vantage point\n    d = this.distance(vantagePoint, query);\n    this.D++;\n\n    if (d < tau) {\n      neighbors.push({distance: d, item: vantagePoint});\n\n      // Trimming\n      if (neighbors.size > k)\n        neighbors.pop();\n\n      // Adjusting tau (only if we already have k items, else it stays Infinity)\n      if (neighbors.size >= k)\n       tau = neighbors.peek().distance;\n    }\n\n    leftIndex = this.lefts[nodeIndex];\n    rightIndex = this.rights[nodeIndex];\n\n    // We are a leaf\n    if (!leftIndex && !rightIndex)\n      continue;\n\n    mu = this.mus[nodeIndex];\n\n    if (d < mu) {\n      if (leftIndex && d < mu + tau)\n        stack.push(leftIndex);\n      if (rightIndex && d >= mu - tau) // Might not be necessary to test d\n        stack.push(rightIndex);\n    }\n    else {\n      if (rightIndex && d >= mu - tau)\n        stack.push(rightIndex);\n      if (leftIndex && d < mu + tau) // Might not be necessary to test d\n        stack.push(leftIndex);\n    }\n  }\n\n  var array = new Array(neighbors.size);\n\n  for (var i = neighbors.size - 1; i >= 0; i--)\n    array[i] = neighbors.pop();\n\n  return array;\n};\n\n/**\n * Function used to retrieve every neighbors of query in the given radius.\n *\n * @param  {number} radius - Radius.\n * @param  {any}    query  - The query.\n * @return {array}\n */\nVPTree.prototype.neighbors = function(radius, query) {\n  var neighbors = [],\n      stack = [0],\n      nodeIndex,\n      itemIndex,\n      vantagePoint,\n      leftIndex,\n      rightIndex,\n      mu,\n      d;\n\n  this.D = 0;\n\n  while (stack.length) {\n    nodeIndex = stack.pop();\n    itemIndex = this.nodes[nodeIndex];\n    vantagePoint = this.items[itemIndex];\n\n    // Distance between query & the current vantage point\n    d = this.distance(vantagePoint, query);\n    this.D++;\n\n    if (d <= radius)\n      neighbors.push({distance: d, item: vantagePoint});\n\n    leftIndex = this.lefts[nodeIndex];\n    rightIndex = this.rights[nodeIndex];\n\n    // We are a leaf\n    if (!leftIndex && !rightIndex)\n      continue;\n\n    mu = this.mus[nodeIndex];\n\n    if (d < mu) {\n      if (leftIndex && d < mu + radius)\n        stack.push(leftIndex);\n      if (rightIndex && d >= mu - radius) // Might not be necessary to test d\n        stack.push(rightIndex);\n    }\n    else {\n      if (rightIndex && d >= mu - radius)\n        stack.push(rightIndex);\n      if (leftIndex && d < mu + radius) // Might not be necessary to test d\n        stack.push(leftIndex);\n    }\n  }\n\n  return neighbors;\n};\n\n/**\n * Convenience known methods.\n */\nVPTree.prototype.inspect = function() {\n  var array = this.items.slice();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: VPTree,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  VPTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = VPTree.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a tree.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} distance - Distance function to use.\n * @return {VPTree}\n */\nVPTree.from = function(iterable, distance) {\n  return new VPTree(distance, iterable);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = VPTree;\n"]},"metadata":{},"sourceType":"script"}