{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { CurrencyAmount, Price, Rounding } from '@uniswap/sdk-core';\nimport { encodeSqrtRatioX96, nearestUsableTick, Pool, Position, priceToClosestTick, TICK_SPACINGS, TickMath, tickToPrice } from '@uniswap/v3-sdk';\nimport { usePool } from 'hooks/usePools';\nimport JSBI from 'jsbi';\nimport { useCallback, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { getTickToPrice } from 'utils/getTickToPrice';\nimport { BIG_INT_ZERO } from '../../../constants/misc';\nimport { PoolState } from '../../../hooks/usePools';\nimport { useActiveWeb3React } from '../../../hooks/web3';\nimport { tryParseAmount } from '../../swap/hooks';\nimport { useCurrencyBalances } from '../../wallet/hooks';\nimport { Bound, Field, setFullRange, typeInput, typeLeftRangeInput, typeRightRangeInput, typeStartPriceInput } from './actions';\nimport { tryParseTick } from './utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function useV3MintState() {\n  _s();\n\n  return useAppSelector(state => state.mintV3);\n}\n\n_s(useV3MintState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function useV3MintActionHandlers(noLiquidity) {\n  _s2();\n\n  const dispatch = useAppDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onLeftRangeInput = useCallback(typedValue => {\n    dispatch(typeLeftRangeInput({\n      typedValue\n    }));\n  }, [dispatch]);\n  const onRightRangeInput = useCallback(typedValue => {\n    dispatch(typeRightRangeInput({\n      typedValue\n    }));\n  }, [dispatch]);\n  const onStartPriceInput = useCallback(typedValue => {\n    dispatch(typeStartPriceInput({\n      typedValue\n    }));\n  }, [dispatch]);\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput\n  };\n}\n\n_s2(useV3MintActionHandlers, \"dOTZHF17zY9BuUfYGfh2RaVZy6M=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function useV3DerivedMintInfo(currencyA, currencyB, feeAmount, baseCurrency, // override for existing position\nexistingPosition) {\n  _s3();\n\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    startPriceTypedValue\n  } = useV3MintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // currencies\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA,\n    [Field.CURRENCY_B]: currencyB\n  }), [currencyA, currencyB]); // formatted with tokens\n\n  const [tokenA, tokenB, baseToken] = useMemo(() => [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped], [currencyA, currencyB, baseCurrency]);\n  const [token0, token1] = useMemo(() => tokenA && tokenB ? tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] : [undefined, undefined], [tokenA, tokenB]); // balances\n\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]));\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // pool\n\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount);\n  const noLiquidity = poolState === PoolState.NOT_EXISTS; // note to parse inputs in reverse\n\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0)); // always returns the price with 0 as base token\n\n  const price = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1);\n\n      if (parsedQuoteAmount && token0 && token1) {\n        var _ref;\n\n        const baseAmount = tryParseAmount('1', invertPrice ? token1 : token0);\n        const price = baseAmount && parsedQuoteAmount ? new Price(baseAmount.currency, parsedQuoteAmount.currency, baseAmount.quotient, parsedQuoteAmount.quotient) : undefined;\n        return (_ref = invertPrice ? price === null || price === void 0 ? void 0 : price.invert() : price) !== null && _ref !== void 0 ? _ref : undefined;\n      }\n\n      return undefined;\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined;\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool]); // check for invalid price input (converts to invalid ratio)\n\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    return price && sqrtRatioX96 && !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO));\n  }, [price]); // used for ratio calculation when pool not initialized\n\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price);\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, []);\n    } else {\n      return undefined;\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]); // if pool exists use it, if not use the mock pool\n\n  const poolForPosition = pool !== null && pool !== void 0 ? pool : mockPool; // lower and upper limits in the tick space for `feeAmoun<Trans>\n\n  const tickSpaceLimits = useMemo(() => ({\n    [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined\n  }), [feeAmount]); // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n\n  const ticks = useMemo(() => {\n    return {\n      [Bound.LOWER]: typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickLower) === 'number' ? existingPosition.tickLower : invertPrice && typeof rightRangeTypedValue === 'boolean' || !invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.LOWER] : invertPrice ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]: typeof (existingPosition === null || existingPosition === void 0 ? void 0 : existingPosition.tickUpper) === 'number' ? existingPosition.tickUpper : !invertPrice && typeof rightRangeTypedValue === 'boolean' || invertPrice && typeof leftRangeTypedValue === 'boolean' ? tickSpaceLimits[Bound.UPPER] : invertPrice ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString()) : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString())\n    };\n  }, [existingPosition, feeAmount, invertPrice, leftRangeTypedValue, rightRangeTypedValue, token0, token1, tickSpaceLimits]);\n  const {\n    [Bound.LOWER]: tickLower,\n    [Bound.UPPER]: tickUpper\n  } = ticks || {}; // specifies whether the lower and upper ticks is at the exteme bounds\n\n  const ticksAtLimit = useMemo(() => ({\n    [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n    [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER\n  }), [tickSpaceLimits, tickLower, tickUpper, feeAmount]); // mark invalid range\n\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper); // always returns the price with 0 as base token\n\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER])\n    };\n  }, [token0, token1, ticks]);\n  const {\n    [Bound.LOWER]: lowerPrice,\n    [Bound.UPPER]: upperPrice\n  } = pricesAtTicks; // liquidity range warning\n\n  const outOfRange = Boolean(!invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))); // amounts\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n\n    if (independentAmount && wrappedIndependentAmount && typeof tickLower === 'number' && typeof tickUpper === 'number' && poolForPosition) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n\n      const position = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? Position.fromAmount0({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0: independentAmount.quotient,\n        useFullPrecision: true // we want full precision for the theoretical position\n\n      }) : Position.fromAmount1({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount1: independentAmount.quotient\n      });\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0) ? position.amount1 : position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n\n    return undefined;\n  }, [independentAmount, outOfRange, dependentField, currencyB, currencyA, tickLower, tickUpper, poolForPosition, invalidRange]);\n  const parsedAmounts = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n    };\n  }, [dependentAmount, independentAmount, independentField]); // single deposit only if price is out of range\n\n  const deposit0Disabled = Boolean(typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper);\n  const deposit1Disabled = Boolean(typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower); // sorted for token order\n\n  const depositADisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA) || deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA));\n  const depositBDisabled = invalidRange || Boolean(deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB) || deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)); // create position entity based on users selection\n\n  const position = useMemo(() => {\n    var _parsedAmounts, _parsedAmounts2;\n\n    if (!poolForPosition || !tokenA || !tokenB || typeof tickLower !== 'number' || typeof tickUpper !== 'number' || invalidRange) {\n      return undefined;\n    } // mark as 0 if disabled because out of range\n\n\n    const amount0 = !deposit0Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]) === null || _parsedAmounts === void 0 ? void 0 : _parsedAmounts.quotient : BIG_INT_ZERO;\n    const amount1 = !deposit1Disabled ? parsedAmounts === null || parsedAmounts === void 0 ? void 0 : (_parsedAmounts2 = parsedAmounts[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]) === null || _parsedAmounts2 === void 0 ? void 0 : _parsedAmounts2.quotient : BIG_INT_ZERO;\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true // we want full precision for the theoretical position\n\n      });\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, poolForPosition, tokenA, tokenB, deposit0Disabled, deposit1Disabled, invalidRange, tickLower, tickUpper]);\n  let errorMessage;\n\n  if (!account) {\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (poolState === PoolState.INVALID) {\n    var _errorMessage;\n\n    errorMessage = (_errorMessage = errorMessage) !== null && _errorMessage !== void 0 ? _errorMessage : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid pair\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (invalidPrice) {\n    var _errorMessage2;\n\n    errorMessage = (_errorMessage2 = errorMessage) !== null && _errorMessage2 !== void 0 ? _errorMessage2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid price input\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled || !parsedAmounts[Field.CURRENCY_B] && !depositBDisabled) {\n    var _errorMessage3;\n\n    errorMessage = (_errorMessage3 = errorMessage) !== null && _errorMessage3 !== void 0 ? _errorMessage3 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n\n    errorMessage = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  const invalidPool = poolState === PoolState.INVALID;\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit\n  };\n}\n\n_s3(useV3DerivedMintInfo, \"p173w3fKHr8mNkHTe/PRMLuSIxo=\", false, function () {\n  return [useActiveWeb3React, useV3MintState, useCurrencyBalances, usePool];\n});\n\nexport function useRangeHopCallbacks(baseCurrency, quoteCurrency, feeAmount, tickLower, tickUpper, pool) {\n  _s4();\n\n  const dispatch = useAppDispatch();\n  const baseToken = useMemo(() => baseCurrency === null || baseCurrency === void 0 ? void 0 : baseCurrency.wrapped, [baseCurrency]);\n  const quoteToken = useMemo(() => quoteCurrency === null || quoteCurrency === void 0 ? void 0 : quoteCurrency.wrapped, [quoteCurrency]);\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    } // use pool current tick as starting tick if we have pool but no tick input\n\n\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    } // use pool current tick as starting tick if we have pool but no tick input\n\n\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    } // use pool current tick as starting tick if we have pool but no tick input\n\n\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    } // use pool current tick as starting tick if we have pool but no tick input\n\n\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n\n    return '';\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange());\n  }, [dispatch]);\n  return {\n    getDecrementLower,\n    getIncrementLower,\n    getDecrementUpper,\n    getIncrementUpper,\n    getSetFullRange\n  };\n}\n\n_s4(useRangeHopCallbacks, \"5VrOUxhhOxfWbS+6gNLkNCiogqw=\", false, function () {\n  return [useAppDispatch];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/mint/v3/hooks.tsx"],"names":["CurrencyAmount","Price","Rounding","encodeSqrtRatioX96","nearestUsableTick","Pool","Position","priceToClosestTick","TICK_SPACINGS","TickMath","tickToPrice","usePool","JSBI","useCallback","useMemo","useAppDispatch","useAppSelector","getTickToPrice","BIG_INT_ZERO","PoolState","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Bound","Field","setFullRange","typeInput","typeLeftRangeInput","typeRightRangeInput","typeStartPriceInput","tryParseTick","useV3MintState","state","mintV3","useV3MintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","onLeftRangeInput","onRightRangeInput","onStartPriceInput","useV3DerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","tokenA","tokenB","baseToken","wrapped","token0","token1","sortsBefore","undefined","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","errorMessage","INVALID","currencyAAmount","currencyBAmount","symbol","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"mappings":";;;;;;AACA,SAAmBA,cAAnB,EAAmCC,KAAnC,EAA0CC,QAA1C,QAAiE,mBAAjE;AACA,SACEC,kBADF,EAGEC,iBAHF,EAIEC,IAJF,EAKEC,QALF,EAMEC,kBANF,EAOEC,aAPF,EAQEC,QARF,EASEC,WATF,QAUO,iBAVP;AAWA,SAASC,OAAT,QAAwB,gBAAxB;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,SAAoBC,WAApB,EAAiCC,OAAjC,QAAgD,OAAhD;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,aAA/C;AACA,SAASC,cAAT,QAA+B,sBAA/B;AAEA,SAASC,YAAT,QAA6B,yBAA7B;AACA,SAASC,SAAT,QAA0B,yBAA1B;AACA,SAASC,kBAAT,QAAmC,qBAAnC;AAEA,SAASC,cAAT,QAA+B,kBAA/B;AACA,SAASC,mBAAT,QAAoC,oBAApC;AACA,SACEC,KADF,EAEEC,KAFF,EAGEC,YAHF,EAIEC,SAJF,EAKEC,kBALF,EAMEC,mBANF,EAOEC,mBAPF,QAQO,WARP;AASA,SAASC,YAAT,QAA6B,SAA7B;;AAEA,OAAO,SAASC,cAAT,GAA8C;AAAA;;AACnD,SAAOf,cAAc,CAAEgB,KAAD,IAAWA,KAAK,CAACC,MAAlB,CAArB;AACD;;GAFeF,c;UACPf,c;;;AAGT,OAAO,SAASkB,uBAAT,CAAiCC,WAAjC,EAML;AAAA;;AACA,QAAMC,QAAQ,GAAGrB,cAAc,EAA/B;AAEA,QAAMsB,aAAa,GAAGxB,WAAW,CAC9ByB,UAAD,IAAwB;AACtBF,IAAAA,QAAQ,CAACV,SAAS,CAAC;AAAEa,MAAAA,KAAK,EAAEf,KAAK,CAACgB,UAAf;AAA2BF,MAAAA,UAA3B;AAAuCH,MAAAA,WAAW,EAAEA,WAAW,KAAK;AAApE,KAAD,CAAV,CAAR;AACD,GAH8B,EAI/B,CAACC,QAAD,EAAWD,WAAX,CAJ+B,CAAjC;AAOA,QAAMM,aAAa,GAAG5B,WAAW,CAC9ByB,UAAD,IAAwB;AACtBF,IAAAA,QAAQ,CAACV,SAAS,CAAC;AAAEa,MAAAA,KAAK,EAAEf,KAAK,CAACkB,UAAf;AAA2BJ,MAAAA,UAA3B;AAAuCH,MAAAA,WAAW,EAAEA,WAAW,KAAK;AAApE,KAAD,CAAV,CAAR;AACD,GAH8B,EAI/B,CAACC,QAAD,EAAWD,WAAX,CAJ+B,CAAjC;AAOA,QAAMQ,gBAAgB,GAAG9B,WAAW,CACjCyB,UAAD,IAAwB;AACtBF,IAAAA,QAAQ,CAACT,kBAAkB,CAAC;AAAEW,MAAAA;AAAF,KAAD,CAAnB,CAAR;AACD,GAHiC,EAIlC,CAACF,QAAD,CAJkC,CAApC;AAOA,QAAMQ,iBAAiB,GAAG/B,WAAW,CAClCyB,UAAD,IAAwB;AACtBF,IAAAA,QAAQ,CAACR,mBAAmB,CAAC;AAAEU,MAAAA;AAAF,KAAD,CAApB,CAAR;AACD,GAHkC,EAInC,CAACF,QAAD,CAJmC,CAArC;AAOA,QAAMS,iBAAiB,GAAGhC,WAAW,CAClCyB,UAAD,IAAwB;AACtBF,IAAAA,QAAQ,CAACP,mBAAmB,CAAC;AAAES,MAAAA;AAAF,KAAD,CAApB,CAAR;AACD,GAHkC,EAInC,CAACF,QAAD,CAJmC,CAArC;AAOA,SAAO;AACLC,IAAAA,aADK;AAELI,IAAAA,aAFK;AAGLE,IAAAA,gBAHK;AAILC,IAAAA,iBAJK;AAKLC,IAAAA;AALK,GAAP;AAOD;;IAnDeX,uB;UAOGnB,c;;;AA8CnB,OAAO,SAAS+B,oBAAT,CACLC,SADK,EAELC,SAFK,EAGLC,SAHK,EAILC,YAJK,EAKL;AACAC,gBANK,EA6BL;AAAA;;AAAA;;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAchC,kBAAkB,EAAtC;AAEA,QAAM;AAAEiC,IAAAA,gBAAF;AAAoBf,IAAAA,UAApB;AAAgCgB,IAAAA,mBAAhC;AAAqDC,IAAAA,oBAArD;AAA2EC,IAAAA;AAA3E,MACJzB,cAAc,EADhB;AAGA,QAAM0B,cAAc,GAAGJ,gBAAgB,KAAK7B,KAAK,CAACgB,UAA3B,GAAwChB,KAAK,CAACkB,UAA9C,GAA2DlB,KAAK,CAACgB,UAAxF,CANA,CAQA;;AACA,QAAMkB,UAA2C,GAAG5C,OAAO,CACzD,OAAO;AACL,KAACU,KAAK,CAACgB,UAAP,GAAoBO,SADf;AAEL,KAACvB,KAAK,CAACkB,UAAP,GAAoBM;AAFf,GAAP,CADyD,EAKzD,CAACD,SAAD,EAAYC,SAAZ,CALyD,CAA3D,CATA,CAiBA;;AACA,QAAM,CAACW,MAAD,EAASC,MAAT,EAAiBC,SAAjB,IAA8B/C,OAAO,CACzC,MAAM,CAACiC,SAAD,aAACA,SAAD,uBAACA,SAAS,CAAEe,OAAZ,EAAqBd,SAArB,aAAqBA,SAArB,uBAAqBA,SAAS,CAAEc,OAAhC,EAAyCZ,YAAzC,aAAyCA,YAAzC,uBAAyCA,YAAY,CAAEY,OAAvD,CADmC,EAEzC,CAACf,SAAD,EAAYC,SAAZ,EAAuBE,YAAvB,CAFyC,CAA3C;AAKA,QAAM,CAACa,MAAD,EAASC,MAAT,IAAmBlD,OAAO,CAC9B,MACE6C,MAAM,IAAIC,MAAV,GAAoBD,MAAM,CAACM,WAAP,CAAmBL,MAAnB,IAA6B,CAACD,MAAD,EAASC,MAAT,CAA7B,GAAgD,CAACA,MAAD,EAASD,MAAT,CAApE,GAAwF,CAACO,SAAD,EAAYA,SAAZ,CAF5D,EAG9B,CAACP,MAAD,EAASC,MAAT,CAH8B,CAAhC,CAvBA,CA6BA;;AACA,QAAMO,QAAQ,GAAG7C,mBAAmB,CAClC8B,OADkC,aAClCA,OADkC,cAClCA,OADkC,GACvBc,SADuB,EAElCpD,OAAO,CAAC,MAAM,CAAC4C,UAAU,CAAClC,KAAK,CAACgB,UAAP,CAAX,EAA+BkB,UAAU,CAAClC,KAAK,CAACkB,UAAP,CAAzC,CAAP,EAAqE,CAACgB,UAAD,CAArE,CAF2B,CAApC;AAIA,QAAMU,gBAAiE,GAAG;AACxE,KAAC5C,KAAK,CAACgB,UAAP,GAAoB2B,QAAQ,CAAC,CAAD,CAD4C;AAExE,KAAC3C,KAAK,CAACkB,UAAP,GAAoByB,QAAQ,CAAC,CAAD;AAF4C,GAA1E,CAlCA,CAuCA;;AACA,QAAM,CAACE,SAAD,EAAYC,IAAZ,IAAoB3D,OAAO,CAAC+C,UAAU,CAAClC,KAAK,CAACgB,UAAP,CAAX,EAA+BkB,UAAU,CAAClC,KAAK,CAACkB,UAAP,CAAzC,EAA6DO,SAA7D,CAAjC;AACA,QAAMd,WAAW,GAAGkC,SAAS,KAAKlD,SAAS,CAACoD,UAA5C,CAzCA,CA2CA;;AACA,QAAMC,WAAW,GAAGC,OAAO,CAACZ,SAAS,IAAIE,MAAb,IAAuB,CAACF,SAAS,CAACa,MAAV,CAAiBX,MAAjB,CAAzB,CAA3B,CA5CA,CA8CA;;AACA,QAAMY,KAAsC,GAAG7D,OAAO,CAAC,MAAM;AAC3D;AACA,QAAIqB,WAAJ,EAAiB;AACf,YAAMyC,iBAAiB,GAAGvD,cAAc,CAACmC,oBAAD,EAAuBgB,WAAW,GAAGT,MAAH,GAAYC,MAA9C,CAAxC;;AACA,UAAIY,iBAAiB,IAAIb,MAArB,IAA+BC,MAAnC,EAA2C;AAAA;;AACzC,cAAMa,UAAU,GAAGxD,cAAc,CAAC,GAAD,EAAMmD,WAAW,GAAGR,MAAH,GAAYD,MAA7B,CAAjC;AACA,cAAMY,KAAK,GACTE,UAAU,IAAID,iBAAd,GACI,IAAI3E,KAAJ,CACE4E,UAAU,CAACC,QADb,EAEEF,iBAAiB,CAACE,QAFpB,EAGED,UAAU,CAACE,QAHb,EAIEH,iBAAiB,CAACG,QAJpB,CADJ,GAOIb,SARN;AASA,uBAAQM,WAAW,GAAGG,KAAH,aAAGA,KAAH,uBAAGA,KAAK,CAAEK,MAAP,EAAH,GAAqBL,KAAxC,uCAAkDT,SAAlD;AACD;;AACD,aAAOA,SAAP;AACD,KAhBD,MAgBO;AACL;AACA,aAAOI,IAAI,IAAIP,MAAR,GAAiBO,IAAI,CAACW,OAAL,CAAalB,MAAb,CAAjB,GAAwCG,SAA/C;AACD;AACF,GAtBqD,EAsBnD,CAAC/B,WAAD,EAAcqB,oBAAd,EAAoCgB,WAApC,EAAiDR,MAAjD,EAAyDD,MAAzD,EAAiEO,IAAjE,CAtBmD,CAAtD,CA/CA,CAuEA;;AACA,QAAMY,YAAY,GAAGpE,OAAO,CAAC,MAAM;AACjC,UAAMqE,YAAY,GAAGR,KAAK,GAAGxE,kBAAkB,CAACwE,KAAK,CAACS,SAAP,EAAkBT,KAAK,CAACU,WAAxB,CAArB,GAA4DnB,SAAtF;AACA,WACES,KAAK,IACLQ,YADA,IAEA,EACEvE,IAAI,CAAC0E,kBAAL,CAAwBH,YAAxB,EAAsC1E,QAAQ,CAAC8E,cAA/C,KACA3E,IAAI,CAAC4E,QAAL,CAAcL,YAAd,EAA4B1E,QAAQ,CAACgF,cAArC,CAFF,CAHF;AAQD,GAV2B,EAUzB,CAACd,KAAD,CAVyB,CAA5B,CAxEA,CAoFA;;AACA,QAAMe,QAAQ,GAAG5E,OAAO,CAAC,MAAM;AAC7B,QAAI6C,MAAM,IAAIC,MAAV,IAAoBX,SAApB,IAAiC0B,KAAjC,IAA0C,CAACO,YAA/C,EAA6D;AAC3D,YAAMS,WAAW,GAAGpF,kBAAkB,CAACoE,KAAD,CAAtC;AACA,YAAMiB,WAAW,GAAGnF,QAAQ,CAACoF,kBAAT,CAA4BF,WAA5B,CAApB;AACA,aAAO,IAAItF,IAAJ,CAASsD,MAAT,EAAiBC,MAAjB,EAAyBX,SAAzB,EAAoC2C,WAApC,EAAiDhF,IAAI,CAACkF,MAAL,CAAY,CAAZ,CAAjD,EAAiEH,WAAjE,EAA8E,EAA9E,CAAP;AACD,KAJD,MAIO;AACL,aAAOzB,SAAP;AACD;AACF,GARuB,EAQrB,CAACjB,SAAD,EAAYiC,YAAZ,EAA0BP,KAA1B,EAAiChB,MAAjC,EAAyCC,MAAzC,CARqB,CAAxB,CArFA,CA+FA;;AACA,QAAMmC,eAAiC,GAAGzB,IAAH,aAAGA,IAAH,cAAGA,IAAH,GAAWoB,QAAlD,CAhGA,CAkGA;;AACA,QAAMM,eAEL,GAAGlF,OAAO,CACT,OAAO;AACL,KAACS,KAAK,CAAC0E,KAAP,GAAehD,SAAS,GAAG7C,iBAAiB,CAACK,QAAQ,CAACyF,QAAV,EAAoB1F,aAAa,CAACyC,SAAD,CAAjC,CAApB,GAAoEiB,SADvF;AAEL,KAAC3C,KAAK,CAAC4E,KAAP,GAAelD,SAAS,GAAG7C,iBAAiB,CAACK,QAAQ,CAAC2F,QAAV,EAAoB5F,aAAa,CAACyC,SAAD,CAAjC,CAApB,GAAoEiB;AAFvF,GAAP,CADS,EAKT,CAACjB,SAAD,CALS,CAFX,CAnGA,CA6GA;AACA;;AACA,QAAMoD,KAEL,GAAGvF,OAAO,CAAC,MAAM;AAChB,WAAO;AACL,OAACS,KAAK,CAAC0E,KAAP,GACE,QAAO9C,gBAAP,aAAOA,gBAAP,uBAAOA,gBAAgB,CAAEmD,SAAzB,MAAuC,QAAvC,GACInD,gBAAgB,CAACmD,SADrB,GAEK9B,WAAW,IAAI,OAAOjB,oBAAP,KAAgC,SAAhD,IACC,CAACiB,WAAD,IAAgB,OAAOlB,mBAAP,KAA+B,SADhD,GAEA0C,eAAe,CAACzE,KAAK,CAAC0E,KAAP,CAFf,GAGAzB,WAAW,GACX1C,YAAY,CAACkC,MAAD,EAASD,MAAT,EAAiBd,SAAjB,EAA4BM,oBAAoB,CAACgD,QAArB,EAA5B,CADD,GAEXzE,YAAY,CAACiC,MAAD,EAASC,MAAT,EAAiBf,SAAjB,EAA4BK,mBAAmB,CAACiD,QAApB,EAA5B,CATb;AAUL,OAAChF,KAAK,CAAC4E,KAAP,GACE,QAAOhD,gBAAP,aAAOA,gBAAP,uBAAOA,gBAAgB,CAAEqD,SAAzB,MAAuC,QAAvC,GACIrD,gBAAgB,CAACqD,SADrB,GAEK,CAAChC,WAAD,IAAgB,OAAOjB,oBAAP,KAAgC,SAAjD,IACCiB,WAAW,IAAI,OAAOlB,mBAAP,KAA+B,SAD/C,GAEA0C,eAAe,CAACzE,KAAK,CAAC4E,KAAP,CAFf,GAGA3B,WAAW,GACX1C,YAAY,CAACkC,MAAD,EAASD,MAAT,EAAiBd,SAAjB,EAA4BK,mBAAmB,CAACiD,QAApB,EAA5B,CADD,GAEXzE,YAAY,CAACiC,MAAD,EAASC,MAAT,EAAiBf,SAAjB,EAA4BM,oBAAoB,CAACgD,QAArB,EAA5B;AAlBb,KAAP;AAoBD,GArBU,EAqBR,CACDpD,gBADC,EAEDF,SAFC,EAGDuB,WAHC,EAIDlB,mBAJC,EAKDC,oBALC,EAMDQ,MANC,EAODC,MAPC,EAQDgC,eARC,CArBQ,CAFX;AAkCA,QAAM;AAAE,KAACzE,KAAK,CAAC0E,KAAP,GAAeK,SAAjB;AAA4B,KAAC/E,KAAK,CAAC4E,KAAP,GAAeK;AAA3C,MAAyDH,KAAK,IAAI,EAAxE,CAjJA,CAmJA;;AACA,QAAMI,YAAY,GAAG3F,OAAO,CAC1B,OAAO;AACL,KAACS,KAAK,CAAC0E,KAAP,GAAehD,SAAS,IAAIqD,SAAS,KAAKN,eAAe,CAACC,KADrD;AAEL,KAAC1E,KAAK,CAAC4E,KAAP,GAAelD,SAAS,IAAIuD,SAAS,KAAKR,eAAe,CAACG;AAFrD,GAAP,CAD0B,EAK1B,CAACH,eAAD,EAAkBM,SAAlB,EAA6BE,SAA7B,EAAwCvD,SAAxC,CAL0B,CAA5B,CApJA,CA4JA;;AACA,QAAMyD,YAAY,GAAGjC,OAAO,CAAC,OAAO6B,SAAP,KAAqB,QAArB,IAAiC,OAAOE,SAAP,KAAqB,QAAtD,IAAkEF,SAAS,IAAIE,SAAhF,CAA5B,CA7JA,CA+JA;;AACA,QAAMG,aAAa,GAAG7F,OAAO,CAAC,MAAM;AAClC,WAAO;AACL,OAACS,KAAK,CAAC0E,KAAP,GAAehF,cAAc,CAAC8C,MAAD,EAASC,MAAT,EAAiBqC,KAAK,CAAC9E,KAAK,CAAC0E,KAAP,CAAtB,CADxB;AAEL,OAAC1E,KAAK,CAAC4E,KAAP,GAAelF,cAAc,CAAC8C,MAAD,EAASC,MAAT,EAAiBqC,KAAK,CAAC9E,KAAK,CAAC4E,KAAP,CAAtB;AAFxB,KAAP;AAID,GAL4B,EAK1B,CAACpC,MAAD,EAASC,MAAT,EAAiBqC,KAAjB,CAL0B,CAA7B;AAMA,QAAM;AAAE,KAAC9E,KAAK,CAAC0E,KAAP,GAAeW,UAAjB;AAA6B,KAACrF,KAAK,CAAC4E,KAAP,GAAeU;AAA5C,MAA2DF,aAAjE,CAtKA,CAwKA;;AACA,QAAMG,UAAU,GAAGrC,OAAO,CACxB,CAACiC,YAAD,IAAiB/B,KAAjB,IAA0BiC,UAA1B,IAAwCC,UAAxC,KAAuDlC,KAAK,CAACa,QAAN,CAAeoB,UAAf,KAA8BjC,KAAK,CAACoC,WAAN,CAAkBF,UAAlB,CAArF,CADwB,CAA1B,CAzKA,CA6KA;;AACA,QAAMG,iBAAuD,GAAG3F,cAAc,CAC5EiB,UAD4E,EAE5EoB,UAAU,CAACL,gBAAD,CAFkE,CAA9E;AAKA,QAAM4D,eAAqD,GAAGnG,OAAO,CAAC,MAAM;AAC1E;AACA,UAAMoG,wBAAwB,GAAGF,iBAAH,aAAGA,iBAAH,uBAAGA,iBAAiB,CAAElD,OAApD;AACA,UAAMqD,iBAAiB,GAAG1D,cAAc,KAAKjC,KAAK,CAACkB,UAAzB,GAAsCM,SAAtC,GAAkDD,SAA5E;;AACA,QACEiE,iBAAiB,IACjBE,wBADA,IAEA,OAAOZ,SAAP,KAAqB,QAFrB,IAGA,OAAOE,SAAP,KAAqB,QAHrB,IAIAT,eALF,EAME;AACA;AACA,UAAIe,UAAU,IAAIJ,YAAlB,EAAgC;AAC9B,eAAOxC,SAAP;AACD;;AAED,YAAMkD,QAA8B,GAAGF,wBAAwB,CAACpC,QAAzB,CAAkCJ,MAAlC,CAAyCqB,eAAe,CAAChC,MAAzD,IACnCzD,QAAQ,CAAC+G,WAAT,CAAqB;AACnB/C,QAAAA,IAAI,EAAEyB,eADa;AAEnBO,QAAAA,SAFmB;AAGnBE,QAAAA,SAHmB;AAInBc,QAAAA,OAAO,EAAEN,iBAAiB,CAACjC,QAJR;AAKnBwC,QAAAA,gBAAgB,EAAE,IALC,CAKK;;AALL,OAArB,CADmC,GAQnCjH,QAAQ,CAACkH,WAAT,CAAqB;AACnBlD,QAAAA,IAAI,EAAEyB,eADa;AAEnBO,QAAAA,SAFmB;AAGnBE,QAAAA,SAHmB;AAInBiB,QAAAA,OAAO,EAAET,iBAAiB,CAACjC;AAJR,OAArB,CARJ;AAeA,YAAM2C,oBAAoB,GAAGR,wBAAwB,CAACpC,QAAzB,CAAkCJ,MAAlC,CAAyCqB,eAAe,CAAChC,MAAzD,IACzBqD,QAAQ,CAACK,OADgB,GAEzBL,QAAQ,CAACE,OAFb;AAGA,aAAOH,iBAAiB,IAAInH,cAAc,CAAC2H,aAAf,CAA6BR,iBAA7B,EAAgDO,oBAAoB,CAAC3C,QAArE,CAA5B;AACD;;AAED,WAAOb,SAAP;AACD,GAtCoE,EAsClE,CACD8C,iBADC,EAEDF,UAFC,EAGDrD,cAHC,EAIDT,SAJC,EAKDD,SALC,EAMDuD,SANC,EAODE,SAPC,EAQDT,eARC,EASDW,YATC,CAtCkE,CAArE;AAkDA,QAAMkB,aAAyE,GAAG9G,OAAO,CAAC,MAAM;AAC9F,WAAO;AACL,OAACU,KAAK,CAACgB,UAAP,GAAoBa,gBAAgB,KAAK7B,KAAK,CAACgB,UAA3B,GAAwCwE,iBAAxC,GAA4DC,eAD3E;AAEL,OAACzF,KAAK,CAACkB,UAAP,GAAoBW,gBAAgB,KAAK7B,KAAK,CAACgB,UAA3B,GAAwCyE,eAAxC,GAA0DD;AAFzE,KAAP;AAID,GALwF,EAKtF,CAACC,eAAD,EAAkBD,iBAAlB,EAAqC3D,gBAArC,CALsF,CAAzF,CArOA,CA4OA;;AACA,QAAMwE,gBAAgB,GAAGpD,OAAO,CAC9B,OAAO+B,SAAP,KAAqB,QAArB,IAAiCT,eAAjC,IAAoDA,eAAe,CAAC+B,WAAhB,IAA+BtB,SADrD,CAAhC;AAGA,QAAMuB,gBAAgB,GAAGtD,OAAO,CAC9B,OAAO6B,SAAP,KAAqB,QAArB,IAAiCP,eAAjC,IAAoDA,eAAe,CAAC+B,WAAhB,IAA+BxB,SADrD,CAAhC,CAhPA,CAoPA;;AACA,QAAM0B,gBAAgB,GACpBtB,YAAY,IACZjC,OAAO,CACJoD,gBAAgB,IAAI9B,eAApB,IAAuCpC,MAAvC,IAAiDoC,eAAe,CAAChC,MAAhB,CAAuBW,MAAvB,CAA8Bf,MAA9B,CAAlD,IACGoE,gBAAgB,IAAIhC,eAApB,IAAuCpC,MAAvC,IAAiDoC,eAAe,CAAC/B,MAAhB,CAAuBU,MAAvB,CAA8Bf,MAA9B,CAF/C,CAFT;AAMA,QAAMsE,gBAAgB,GACpBvB,YAAY,IACZjC,OAAO,CACJoD,gBAAgB,IAAI9B,eAApB,IAAuCnC,MAAvC,IAAiDmC,eAAe,CAAChC,MAAhB,CAAuBW,MAAvB,CAA8Bd,MAA9B,CAAlD,IACGmE,gBAAgB,IAAIhC,eAApB,IAAuCnC,MAAvC,IAAiDmC,eAAe,CAAC/B,MAAhB,CAAuBU,MAAvB,CAA8Bd,MAA9B,CAF/C,CAFT,CA3PA,CAkQA;;AACA,QAAMwD,QAA8B,GAAGtG,OAAO,CAAC,MAAM;AAAA;;AACnD,QACE,CAACiF,eAAD,IACA,CAACpC,MADD,IAEA,CAACC,MAFD,IAGA,OAAO0C,SAAP,KAAqB,QAHrB,IAIA,OAAOE,SAAP,KAAqB,QAJrB,IAKAE,YANF,EAOE;AACA,aAAOxC,SAAP;AACD,KAVkD,CAYnD;;;AACA,UAAMoD,OAAO,GAAG,CAACO,gBAAD,GACZD,aADY,aACZA,aADY,yCACZA,aAAa,CAAGjE,MAAM,CAACe,MAAP,CAAcqB,eAAe,CAAChC,MAA9B,IAAwCvC,KAAK,CAACgB,UAA9C,GAA2DhB,KAAK,CAACkB,UAApE,CADD,mDACZ,eAA8FqC,QADlF,GAEZ7D,YAFJ;AAGA,UAAMuG,OAAO,GAAG,CAACM,gBAAD,GACZH,aADY,aACZA,aADY,0CACZA,aAAa,CAAGjE,MAAM,CAACe,MAAP,CAAcqB,eAAe,CAAChC,MAA9B,IAAwCvC,KAAK,CAACkB,UAA9C,GAA2DlB,KAAK,CAACgB,UAApE,CADD,oDACZ,gBAA8FuC,QADlF,GAEZ7D,YAFJ;;AAIA,QAAIoG,OAAO,KAAKpD,SAAZ,IAAyBuD,OAAO,KAAKvD,SAAzC,EAAoD;AAClD,aAAO5D,QAAQ,CAAC4H,WAAT,CAAqB;AAC1B5D,QAAAA,IAAI,EAAEyB,eADoB;AAE1BO,QAAAA,SAF0B;AAG1BE,QAAAA,SAH0B;AAI1Bc,QAAAA,OAJ0B;AAK1BG,QAAAA,OAL0B;AAM1BF,QAAAA,gBAAgB,EAAE,IANQ,CAMF;;AANE,OAArB,CAAP;AAQD,KATD,MASO;AACL,aAAOrD,SAAP;AACD;AACF,GAhC6C,EAgC3C,CACD0D,aADC,EAED7B,eAFC,EAGDpC,MAHC,EAIDC,MAJC,EAKDiE,gBALC,EAMDE,gBANC,EAODrB,YAPC,EAQDJ,SARC,EASDE,SATC,CAhC2C,CAA9C;AA4CA,MAAI2B,YAAJ;;AACA,MAAI,CAAC/E,OAAL,EAAc;AACZ+E,IAAAA,YAAY,gBAAG;AAAA;AAAA,mCAAf;AACD;;AAED,MAAI9D,SAAS,KAAKlD,SAAS,CAACiH,OAA5B,EAAqC;AAAA;;AACnCD,IAAAA,YAAY,oBAAGA,YAAH,sEAAmB;AAAA;AAAA,mCAA/B;AACD;;AAED,MAAIjD,YAAJ,EAAkB;AAAA;;AAChBiD,IAAAA,YAAY,qBAAGA,YAAH,wEAAmB;AAAA;AAAA,mCAA/B;AACD;;AAED,MACG,CAACP,aAAa,CAACpG,KAAK,CAACgB,UAAP,CAAd,IAAoC,CAACwF,gBAAtC,IACC,CAACJ,aAAa,CAACpG,KAAK,CAACkB,UAAP,CAAd,IAAoC,CAACuF,gBAFxC,EAGE;AAAA;;AACAE,IAAAA,YAAY,qBAAGA,YAAH,wEAAmB;AAAA;AAAA,mCAA/B;AACD;;AAED,QAAM;AAAE,KAAC3G,KAAK,CAACgB,UAAP,GAAoB6F,eAAtB;AAAuC,KAAC7G,KAAK,CAACkB,UAAP,GAAoB4F;AAA3D,MAA+EV,aAArF;;AAEA,MAAIS,eAAe,KAAIjE,gBAAJ,aAAIA,gBAAJ,gDAAIA,gBAAgB,CAAG5C,KAAK,CAACgB,UAAT,CAApB,0DAAI,sBAAsCgD,QAAtC,CAA+C6C,eAA/C,CAAJ,CAAnB,EAAwF;AAAA;;AACtFF,IAAAA,YAAY,gBAAG;AAAA;AAAA;AAAA,oCAAqBzE,UAAU,CAAClC,KAAK,CAACgB,UAAP,CAA/B,0DAAqB,sBAA8B+F;AAAnD;AAAA,mCAAf;AACD;;AAED,MAAID,eAAe,KAAIlE,gBAAJ,aAAIA,gBAAJ,iDAAIA,gBAAgB,CAAG5C,KAAK,CAACkB,UAAT,CAApB,2DAAI,uBAAsC8C,QAAtC,CAA+C8C,eAA/C,CAAJ,CAAnB,EAAwF;AAAA;;AACtFH,IAAAA,YAAY,gBAAG;AAAA;AAAA;AAAA,qCAAqBzE,UAAU,CAAClC,KAAK,CAACkB,UAAP,CAA/B,2DAAqB,uBAA8B6F;AAAnD;AAAA,mCAAf;AACD;;AAED,QAAMC,WAAW,GAAGnE,SAAS,KAAKlD,SAAS,CAACiH,OAA5C;AAEA,SAAO;AACL3E,IAAAA,cADK;AAELC,IAAAA,UAFK;AAGLY,IAAAA,IAHK;AAILD,IAAAA,SAJK;AAKLD,IAAAA,gBALK;AAMLwD,IAAAA,aANK;AAOLvB,IAAAA,KAPK;AAQL1B,IAAAA,KARK;AASLgC,IAAAA,aATK;AAULS,IAAAA,QAVK;AAWLjF,IAAAA,WAXK;AAYLgG,IAAAA,YAZK;AAaLK,IAAAA,WAbK;AAcL9B,IAAAA,YAdK;AAeLI,IAAAA,UAfK;AAgBLkB,IAAAA,gBAhBK;AAiBLC,IAAAA,gBAjBK;AAkBLzD,IAAAA,WAlBK;AAmBLiC,IAAAA;AAnBK,GAAP;AAqBD;;IAjYe3D,oB;UA8BM1B,kB,EAGlBW,c,EA0BeT,mB,EAUSX,O;;;AA8T5B,OAAO,SAAS8H,oBAAT,CACLvF,YADK,EAELwF,aAFK,EAGLzF,SAHK,EAILqD,SAJK,EAKLE,SALK,EAMLlC,IANK,EAOL;AAAA;;AACA,QAAMlC,QAAQ,GAAGrB,cAAc,EAA/B;AAEA,QAAM8C,SAAS,GAAG/C,OAAO,CAAC,MAAMoC,YAAN,aAAMA,YAAN,uBAAMA,YAAY,CAAEY,OAArB,EAA8B,CAACZ,YAAD,CAA9B,CAAzB;AACA,QAAMyF,UAAU,GAAG7H,OAAO,CAAC,MAAM4H,aAAN,aAAMA,aAAN,uBAAMA,aAAa,CAAE5E,OAAtB,EAA+B,CAAC4E,aAAD,CAA/B,CAA1B;AAEA,QAAME,iBAAiB,GAAG/H,WAAW,CAAC,MAAM;AAC1C,QAAIgD,SAAS,IAAI8E,UAAb,IAA2B,OAAOrC,SAAP,KAAqB,QAAhD,IAA4DrD,SAAhE,EAA2E;AACzE,YAAM4F,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrC,SAAS,GAAG9F,aAAa,CAACyC,SAAD,CAAjD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD,KAJyC,CAK1C;;;AACA,QAAI,EAAE,OAAOzC,SAAP,KAAqB,QAAvB,KAAoCzC,SAApC,IAAiD8E,UAAjD,IAA+D1F,SAA/D,IAA4EqB,IAAhF,EAAsF;AACpF,YAAMuE,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrE,IAAI,CAACwD,WAAL,GAAmBtH,aAAa,CAACyC,SAAD,CAAxD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD;;AACD,WAAO,EAAP;AACD,GAXoC,EAWlC,CAAClF,SAAD,EAAY8E,UAAZ,EAAwBrC,SAAxB,EAAmCrD,SAAnC,EAA8CqB,IAA9C,CAXkC,CAArC;AAaA,QAAM0E,iBAAiB,GAAGnI,WAAW,CAAC,MAAM;AAC1C,QAAIgD,SAAS,IAAI8E,UAAb,IAA2B,OAAOrC,SAAP,KAAqB,QAAhD,IAA4DrD,SAAhE,EAA2E;AACzE,YAAM4F,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrC,SAAS,GAAG9F,aAAa,CAACyC,SAAD,CAAjD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD,KAJyC,CAK1C;;;AACA,QAAI,EAAE,OAAOzC,SAAP,KAAqB,QAAvB,KAAoCzC,SAApC,IAAiD8E,UAAjD,IAA+D1F,SAA/D,IAA4EqB,IAAhF,EAAsF;AACpF,YAAMuE,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrE,IAAI,CAACwD,WAAL,GAAmBtH,aAAa,CAACyC,SAAD,CAAxD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD;;AACD,WAAO,EAAP;AACD,GAXoC,EAWlC,CAAClF,SAAD,EAAY8E,UAAZ,EAAwBrC,SAAxB,EAAmCrD,SAAnC,EAA8CqB,IAA9C,CAXkC,CAArC;AAaA,QAAM2E,iBAAiB,GAAGpI,WAAW,CAAC,MAAM;AAC1C,QAAIgD,SAAS,IAAI8E,UAAb,IAA2B,OAAOnC,SAAP,KAAqB,QAAhD,IAA4DvD,SAAhE,EAA2E;AACzE,YAAM4F,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBnC,SAAS,GAAGhG,aAAa,CAACyC,SAAD,CAAjD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD,KAJyC,CAK1C;;;AACA,QAAI,EAAE,OAAOvC,SAAP,KAAqB,QAAvB,KAAoC3C,SAApC,IAAiD8E,UAAjD,IAA+D1F,SAA/D,IAA4EqB,IAAhF,EAAsF;AACpF,YAAMuE,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrE,IAAI,CAACwD,WAAL,GAAmBtH,aAAa,CAACyC,SAAD,CAAxD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD;;AACD,WAAO,EAAP;AACD,GAXoC,EAWlC,CAAClF,SAAD,EAAY8E,UAAZ,EAAwBnC,SAAxB,EAAmCvD,SAAnC,EAA8CqB,IAA9C,CAXkC,CAArC;AAaA,QAAM4E,iBAAiB,GAAGrI,WAAW,CAAC,MAAM;AAC1C,QAAIgD,SAAS,IAAI8E,UAAb,IAA2B,OAAOnC,SAAP,KAAqB,QAAhD,IAA4DvD,SAAhE,EAA2E;AACzE,YAAM4F,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBnC,SAAS,GAAGhG,aAAa,CAACyC,SAAD,CAAjD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD,KAJyC,CAK1C;;;AACA,QAAI,EAAE,OAAOvC,SAAP,KAAqB,QAAvB,KAAoC3C,SAApC,IAAiD8E,UAAjD,IAA+D1F,SAA/D,IAA4EqB,IAAhF,EAAsF;AACpF,YAAMuE,QAAQ,GAAGnI,WAAW,CAACmD,SAAD,EAAY8E,UAAZ,EAAwBrE,IAAI,CAACwD,WAAL,GAAmBtH,aAAa,CAACyC,SAAD,CAAxD,CAA5B;AACA,aAAO4F,QAAQ,CAACC,aAAT,CAAuB,CAAvB,EAA0B5E,SAA1B,EAAqChE,QAAQ,CAAC6I,QAA9C,CAAP;AACD;;AACD,WAAO,EAAP;AACD,GAXoC,EAWlC,CAAClF,SAAD,EAAY8E,UAAZ,EAAwBnC,SAAxB,EAAmCvD,SAAnC,EAA8CqB,IAA9C,CAXkC,CAArC;AAaA,QAAM6E,eAAe,GAAGtI,WAAW,CAAC,MAAM;AACxCuB,IAAAA,QAAQ,CAACX,YAAY,EAAb,CAAR;AACD,GAFkC,EAEhC,CAACW,QAAD,CAFgC,CAAnC;AAIA,SAAO;AAAEwG,IAAAA,iBAAF;AAAqBI,IAAAA,iBAArB;AAAwCC,IAAAA,iBAAxC;AAA2DC,IAAAA,iBAA3D;AAA8EC,IAAAA;AAA9E,GAAP;AACD;;IAtEeV,oB;UAQG1H,c","sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Price, Rounding, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  Pool,\n  Position,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n  tickToPrice,\n} from '@uniswap/v3-sdk'\nimport { usePool } from 'hooks/usePools'\nimport JSBI from 'jsbi'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { getTickToPrice } from 'utils/getTickToPrice'\n\nimport { BIG_INT_ZERO } from '../../../constants/misc'\nimport { PoolState } from '../../../hooks/usePools'\nimport { useActiveWeb3React } from '../../../hooks/web3'\nimport { AppState } from '../../index'\nimport { tryParseAmount } from '../../swap/hooks'\nimport { useCurrencyBalances } from '../../wallet/hooks'\nimport {\n  Bound,\n  Field,\n  setFullRange,\n  typeInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  typeStartPriceInput,\n} from './actions'\nimport { tryParseTick } from './utils'\n\nexport function useV3MintState(): AppState['mintV3'] {\n  return useAppSelector((state) => state.mintV3)\n}\n\nexport function useV3MintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useV3DerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: ReactNode\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useV3MintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency]\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB]\n  )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    return (\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    )\n  }, [price])\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmoun<Trans>\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount]\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount]\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField]\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower\n  )\n\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA))\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB))\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  let errorMessage: ReactNode | undefined\n  if (!account) {\n    errorMessage = <Trans>Connect Wallet</Trans>\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? <Trans>Invalid price input</Trans>\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null\n) {\n  const dispatch = useAppDispatch()\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"]},"metadata":{},"sourceType":"module"}