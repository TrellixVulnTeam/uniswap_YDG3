{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { CurrencyAmount, Price, TradeType } from '@uniswap/sdk-core';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from 'state/swap/hooks';\nimport { SupportedChainId } from '../constants/chains';\nimport { DAI_OPTIMISM, USDC, USDC_ARBITRUM, USDC_POLYGON } from '../constants/tokens';\nimport { useBestV2Trade } from './useBestV2Trade';\nimport { useClientSideV3Trade } from './useClientSideV3Trade';\nimport { useActiveWeb3React } from './web3'; // Stablecoin amounts used when calculating spot price for a given currency.\n// The amount is large enough to filter low liquidity pairs.\n\nexport const STABLECOIN_AMOUNT_OUT = {\n  [SupportedChainId.MAINNET]: CurrencyAmount.fromRawAmount(USDC, 100000e6),\n  [SupportedChainId.ARBITRUM_ONE]: CurrencyAmount.fromRawAmount(USDC_ARBITRUM, 10000e6),\n  [SupportedChainId.OPTIMISM]: CurrencyAmount.fromRawAmount(DAI_OPTIMISM, 10000e18),\n  [SupportedChainId.POLYGON]: CurrencyAmount.fromRawAmount(USDC_POLYGON, 10000e6)\n};\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\n\nexport default function useUSDCPrice(currency) {\n  _s();\n\n  const chainId = currency === null || currency === void 0 ? void 0 : currency.chainId;\n  const amountOut = chainId ? STABLECOIN_AMOUNT_OUT[chainId] : undefined;\n  const stablecoin = amountOut === null || amountOut === void 0 ? void 0 : amountOut.currency; // TODO(#2808): remove dependency on useBestV2Trade\n\n  const v2USDCTrade = useBestV2Trade(TradeType.EXACT_OUTPUT, amountOut, currency, {\n    maxHops: 2\n  });\n  const v3USDCTrade = useClientSideV3Trade(TradeType.EXACT_OUTPUT, amountOut, currency);\n  return useMemo(() => {\n    if (!currency || !stablecoin) {\n      return undefined;\n    } // handle usdc\n\n\n    if (currency === null || currency === void 0 ? void 0 : currency.wrapped.equals(stablecoin)) {\n      return new Price(stablecoin, stablecoin, '1', '1');\n    } // use v2 price if available, v3 as fallback\n\n\n    if (v2USDCTrade) {\n      const {\n        numerator,\n        denominator\n      } = v2USDCTrade.route.midPrice;\n      return new Price(currency, stablecoin, denominator, numerator);\n    } else if (v3USDCTrade.trade) {\n      const {\n        numerator,\n        denominator\n      } = v3USDCTrade.trade.routes[0].midPrice;\n      return new Price(currency, stablecoin, denominator, numerator);\n    }\n\n    return undefined;\n  }, [currency, stablecoin, v2USDCTrade, v3USDCTrade.trade]);\n}\n\n_s(useUSDCPrice, \"3mopoO940OTCvnpt9I+ouOCpPTg=\", false, function () {\n  return [useBestV2Trade, useClientSideV3Trade];\n});\n\nexport function useUSDCValue(currencyAmount) {\n  _s2();\n\n  const price = useUSDCPrice(currencyAmount === null || currencyAmount === void 0 ? void 0 : currencyAmount.currency);\n  return useMemo(() => {\n    if (!price || !currencyAmount) return null;\n\n    try {\n      return price.quote(currencyAmount);\n    } catch (error) {\n      return null;\n    }\n  }, [currencyAmount, price]);\n}\n/**\n *\n * @param fiatValue string representation of a USD amount\n * @returns CurrencyAmount where currency is stablecoin on active chain\n */\n\n_s2(useUSDCValue, \"6qSxKojIxm4ppqgh1D8ADJlU4cI=\", false, function () {\n  return [useUSDCPrice];\n});\n\nexport function useStablecoinAmountFromFiatValue(fiatValue) {\n  _s3();\n\n  var _STABLECOIN_AMOUNT_OU;\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const stablecoin = chainId ? (_STABLECOIN_AMOUNT_OU = STABLECOIN_AMOUNT_OUT[chainId]) === null || _STABLECOIN_AMOUNT_OU === void 0 ? void 0 : _STABLECOIN_AMOUNT_OU.currency : undefined;\n\n  if (fiatValue === null || fiatValue === undefined || !chainId || !stablecoin) {\n    return undefined;\n  } // trim for decimal precision when parsing\n\n\n  const parsedForDecimals = parseFloat(fiatValue).toFixed(stablecoin.decimals).toString();\n\n  try {\n    // parse USD string into CurrencyAmount based on stablecoin decimals\n    return tryParseAmount(parsedForDecimals, stablecoin);\n  } catch (error) {\n    return undefined;\n  }\n}\n\n_s3(useStablecoinAmountFromFiatValue, \"Srgj51dvRDiLRw5YTqb92Ixo5OU=\", false, function () {\n  return [useActiveWeb3React];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useUSDCPrice.ts"],"names":["CurrencyAmount","Price","TradeType","useMemo","tryParseAmount","SupportedChainId","DAI_OPTIMISM","USDC","USDC_ARBITRUM","USDC_POLYGON","useBestV2Trade","useClientSideV3Trade","useActiveWeb3React","STABLECOIN_AMOUNT_OUT","MAINNET","fromRawAmount","ARBITRUM_ONE","OPTIMISM","POLYGON","useUSDCPrice","currency","chainId","amountOut","undefined","stablecoin","v2USDCTrade","EXACT_OUTPUT","maxHops","v3USDCTrade","wrapped","equals","numerator","denominator","route","midPrice","trade","routes","useUSDCValue","currencyAmount","price","quote","error","useStablecoinAmountFromFiatValue","fiatValue","parsedForDecimals","parseFloat","toFixed","decimals","toString"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Price, Token, TradeType } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\nimport { tryParseAmount } from 'state/swap/hooks'\n\nimport { SupportedChainId } from '../constants/chains'\nimport { DAI_OPTIMISM, USDC, USDC_ARBITRUM, USDC_POLYGON } from '../constants/tokens'\nimport { useBestV2Trade } from './useBestV2Trade'\nimport { useClientSideV3Trade } from './useClientSideV3Trade'\nimport { useActiveWeb3React } from './web3'\n\n// Stablecoin amounts used when calculating spot price for a given currency.\n// The amount is large enough to filter low liquidity pairs.\nexport const STABLECOIN_AMOUNT_OUT: { [chainId: number]: CurrencyAmount<Token> } = {\n  [SupportedChainId.MAINNET]: CurrencyAmount.fromRawAmount(USDC, 100_000e6),\n  [SupportedChainId.ARBITRUM_ONE]: CurrencyAmount.fromRawAmount(USDC_ARBITRUM, 10_000e6),\n  [SupportedChainId.OPTIMISM]: CurrencyAmount.fromRawAmount(DAI_OPTIMISM, 10_000e18),\n  [SupportedChainId.POLYGON]: CurrencyAmount.fromRawAmount(USDC_POLYGON, 10_000e6),\n}\n\n/**\n * Returns the price in USDC of the input currency\n * @param currency currency to compute the USDC price of\n */\nexport default function useUSDCPrice(currency?: Currency): Price<Currency, Token> | undefined {\n  const chainId = currency?.chainId\n\n  const amountOut = chainId ? STABLECOIN_AMOUNT_OUT[chainId] : undefined\n  const stablecoin = amountOut?.currency\n\n  // TODO(#2808): remove dependency on useBestV2Trade\n  const v2USDCTrade = useBestV2Trade(TradeType.EXACT_OUTPUT, amountOut, currency, {\n    maxHops: 2,\n  })\n  const v3USDCTrade = useClientSideV3Trade(TradeType.EXACT_OUTPUT, amountOut, currency)\n\n  return useMemo(() => {\n    if (!currency || !stablecoin) {\n      return undefined\n    }\n\n    // handle usdc\n    if (currency?.wrapped.equals(stablecoin)) {\n      return new Price(stablecoin, stablecoin, '1', '1')\n    }\n\n    // use v2 price if available, v3 as fallback\n    if (v2USDCTrade) {\n      const { numerator, denominator } = v2USDCTrade.route.midPrice\n      return new Price(currency, stablecoin, denominator, numerator)\n    } else if (v3USDCTrade.trade) {\n      const { numerator, denominator } = v3USDCTrade.trade.routes[0].midPrice\n      return new Price(currency, stablecoin, denominator, numerator)\n    }\n\n    return undefined\n  }, [currency, stablecoin, v2USDCTrade, v3USDCTrade.trade])\n}\n\nexport function useUSDCValue(currencyAmount: CurrencyAmount<Currency> | undefined | null) {\n  const price = useUSDCPrice(currencyAmount?.currency)\n\n  return useMemo(() => {\n    if (!price || !currencyAmount) return null\n    try {\n      return price.quote(currencyAmount)\n    } catch (error) {\n      return null\n    }\n  }, [currencyAmount, price])\n}\n\n/**\n *\n * @param fiatValue string representation of a USD amount\n * @returns CurrencyAmount where currency is stablecoin on active chain\n */\nexport function useStablecoinAmountFromFiatValue(fiatValue: string | null | undefined) {\n  const { chainId } = useActiveWeb3React()\n  const stablecoin = chainId ? STABLECOIN_AMOUNT_OUT[chainId]?.currency : undefined\n\n  if (fiatValue === null || fiatValue === undefined || !chainId || !stablecoin) {\n    return undefined\n  }\n\n  // trim for decimal precision when parsing\n  const parsedForDecimals = parseFloat(fiatValue).toFixed(stablecoin.decimals).toString()\n\n  try {\n    // parse USD string into CurrencyAmount based on stablecoin decimals\n    return tryParseAmount(parsedForDecimals, stablecoin)\n  } catch (error) {\n    return undefined\n  }\n}\n"]},"metadata":{},"sourceType":"module"}