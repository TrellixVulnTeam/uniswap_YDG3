{"ast":null,"code":"import{CurrencyAmount,Token}from'@uniswap/sdk-core';import{Pair,Route as V2Route}from'@uniswap/v2-sdk';import{Pool,Route as V3Route}from'@uniswap/v3-sdk';import{nativeOnChain}from'../../constants/tokens';import{InterfaceTrade}from'./types';/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */export function computeRoutes(currencyIn,currencyOut,tradeType,quoteResult){if(!quoteResult||!quoteResult.route||!currencyIn||!currencyOut)return undefined;if(quoteResult.route.length===0)return[];var parsedTokenIn=parseToken(quoteResult.route[0][0].tokenIn);var parsedTokenOut=parseToken(quoteResult.route[0][quoteResult.route[0].length-1].tokenOut);if(parsedTokenIn.address!==currencyIn.wrapped.address)return undefined;if(parsedTokenOut.address!==currencyOut.wrapped.address)return undefined;var parsedCurrencyIn=currencyIn.isNative?nativeOnChain(currencyIn.chainId):parsedTokenIn;var parsedCurrencyOut=currencyOut.isNative?nativeOnChain(currencyOut.chainId):parsedTokenOut;try{return quoteResult.route.map(function(route){if(route.length===0){throw new Error('Expected route to have at least one pair or pool');}var rawAmountIn=route[0].amountIn;var rawAmountOut=route[route.length-1].amountOut;if(!rawAmountIn||!rawAmountOut){throw new Error('Expected both amountIn and amountOut to be present');}return{routev3:isV3Route(route)?new V3Route(route.map(parsePool),parsedCurrencyIn,parsedCurrencyOut):null,routev2:!isV3Route(route)?new V2Route(route.map(parsePair),parsedCurrencyIn,parsedCurrencyOut):null,inputAmount:CurrencyAmount.fromRawAmount(parsedCurrencyIn,rawAmountIn),outputAmount:CurrencyAmount.fromRawAmount(parsedCurrencyOut,rawAmountOut)};});}catch(e){// `Route` constructor may throw if inputs/outputs are temporarily out of sync\n// (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n// This is not fatal and will fix itself in future render cycles\nconsole.error(e);return undefined;}}export function transformRoutesToTrade(route,tradeType,gasUseEstimateUSD){var _route$filter$map,_route$filter$map2;return new InterfaceTrade({v2Routes:(_route$filter$map=route===null||route===void 0?void 0:route.filter(function(r){return r.routev2!==null;}).map(function(_ref){var routev2=_ref.routev2,inputAmount=_ref.inputAmount,outputAmount=_ref.outputAmount;return{routev2:routev2,inputAmount:inputAmount,outputAmount:outputAmount};}))!==null&&_route$filter$map!==void 0?_route$filter$map:[],v3Routes:(_route$filter$map2=route===null||route===void 0?void 0:route.filter(function(r){return r.routev3!==null;}).map(function(_ref2){var routev3=_ref2.routev3,inputAmount=_ref2.inputAmount,outputAmount=_ref2.outputAmount;return{routev3:routev3,inputAmount:inputAmount,outputAmount:outputAmount};}))!==null&&_route$filter$map2!==void 0?_route$filter$map2:[],tradeType:tradeType,gasUseEstimateUSD:gasUseEstimateUSD});}var parseToken=function parseToken(_ref3){var address=_ref3.address,chainId=_ref3.chainId,decimals=_ref3.decimals,symbol=_ref3.symbol;return new Token(chainId,address,parseInt(decimals.toString()),symbol);};var parsePool=function parsePool(_ref4){var fee=_ref4.fee,sqrtRatioX96=_ref4.sqrtRatioX96,liquidity=_ref4.liquidity,tickCurrent=_ref4.tickCurrent,tokenIn=_ref4.tokenIn,tokenOut=_ref4.tokenOut;return new Pool(parseToken(tokenIn),parseToken(tokenOut),parseInt(fee),sqrtRatioX96,liquidity,parseInt(tickCurrent));};var parsePair=function parsePair(_ref5){var reserve0=_ref5.reserve0,reserve1=_ref5.reserve1;return new Pair(CurrencyAmount.fromRawAmount(parseToken(reserve0.token),reserve0.quotient),CurrencyAmount.fromRawAmount(parseToken(reserve1.token),reserve1.quotient));};function isV3Route(route){return route[0].type==='v3-pool';}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/routing/utils.ts"],"names":["CurrencyAmount","Token","Pair","Route","V2Route","Pool","V3Route","nativeOnChain","InterfaceTrade","computeRoutes","currencyIn","currencyOut","tradeType","quoteResult","route","undefined","length","parsedTokenIn","parseToken","tokenIn","parsedTokenOut","tokenOut","address","wrapped","parsedCurrencyIn","isNative","chainId","parsedCurrencyOut","map","Error","rawAmountIn","amountIn","rawAmountOut","amountOut","routev3","isV3Route","parsePool","routev2","parsePair","inputAmount","fromRawAmount","outputAmount","e","console","error","transformRoutesToTrade","gasUseEstimateUSD","v2Routes","filter","r","v3Routes","decimals","symbol","parseInt","toString","fee","sqrtRatioX96","liquidity","tickCurrent","reserve0","reserve1","token","quotient","type"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk'\nimport { FeeAmount, Pool, Route as V3Route } from '@uniswap/v3-sdk'\n\nimport { nativeOnChain } from '../../constants/tokens'\nimport { GetQuoteResult, InterfaceTrade, V2PoolInRoute, V3PoolInRoute } from './types'\n\n/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */\nexport function computeRoutes(\n  currencyIn: Currency | undefined,\n  currencyOut: Currency | undefined,\n  tradeType: TradeType,\n  quoteResult: Pick<GetQuoteResult, 'route'> | undefined\n) {\n  if (!quoteResult || !quoteResult.route || !currencyIn || !currencyOut) return undefined\n\n  if (quoteResult.route.length === 0) return []\n\n  const parsedTokenIn = parseToken(quoteResult.route[0][0].tokenIn)\n  const parsedTokenOut = parseToken(quoteResult.route[0][quoteResult.route[0].length - 1].tokenOut)\n\n  if (parsedTokenIn.address !== currencyIn.wrapped.address) return undefined\n  if (parsedTokenOut.address !== currencyOut.wrapped.address) return undefined\n\n  const parsedCurrencyIn = currencyIn.isNative ? nativeOnChain(currencyIn.chainId) : parsedTokenIn\n\n  const parsedCurrencyOut = currencyOut.isNative ? nativeOnChain(currencyOut.chainId) : parsedTokenOut\n\n  try {\n    return quoteResult.route.map((route) => {\n      if (route.length === 0) {\n        throw new Error('Expected route to have at least one pair or pool')\n      }\n      const rawAmountIn = route[0].amountIn\n      const rawAmountOut = route[route.length - 1].amountOut\n\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both amountIn and amountOut to be present')\n      }\n\n      return {\n        routev3: isV3Route(route) ? new V3Route(route.map(parsePool), parsedCurrencyIn, parsedCurrencyOut) : null,\n        routev2: !isV3Route(route) ? new V2Route(route.map(parsePair), parsedCurrencyIn, parsedCurrencyOut) : null,\n        inputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyIn, rawAmountIn),\n        outputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyOut, rawAmountOut),\n      }\n    })\n  } catch (e) {\n    // `Route` constructor may throw if inputs/outputs are temporarily out of sync\n    // (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n    // This is not fatal and will fix itself in future render cycles\n    console.error(e)\n    return undefined\n  }\n}\n\nexport function transformRoutesToTrade<TTradeType extends TradeType>(\n  route: ReturnType<typeof computeRoutes>,\n  tradeType: TTradeType,\n  gasUseEstimateUSD?: CurrencyAmount<Token> | null\n): InterfaceTrade<Currency, Currency, TTradeType> {\n  return new InterfaceTrade({\n    v2Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev2: NonNullable<typeof route[0]['routev2']> } => r.routev2 !== null)\n        .map(({ routev2, inputAmount, outputAmount }) => ({ routev2, inputAmount, outputAmount })) ?? [],\n    v3Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev3: NonNullable<typeof route[0]['routev3']> } => r.routev3 !== null)\n        .map(({ routev3, inputAmount, outputAmount }) => ({ routev3, inputAmount, outputAmount })) ?? [],\n    tradeType,\n    gasUseEstimateUSD,\n  })\n}\n\nconst parseToken = ({ address, chainId, decimals, symbol }: GetQuoteResult['route'][0][0]['tokenIn']): Token => {\n  return new Token(chainId, address, parseInt(decimals.toString()), symbol)\n}\n\nconst parsePool = ({ fee, sqrtRatioX96, liquidity, tickCurrent, tokenIn, tokenOut }: V3PoolInRoute): Pool =>\n  new Pool(\n    parseToken(tokenIn),\n    parseToken(tokenOut),\n    parseInt(fee) as FeeAmount,\n    sqrtRatioX96,\n    liquidity,\n    parseInt(tickCurrent)\n  )\n\nconst parsePair = ({ reserve0, reserve1 }: V2PoolInRoute): Pair =>\n  new Pair(\n    CurrencyAmount.fromRawAmount(parseToken(reserve0.token), reserve0.quotient),\n    CurrencyAmount.fromRawAmount(parseToken(reserve1.token), reserve1.quotient)\n  )\n\nfunction isV3Route(route: V3PoolInRoute[] | V2PoolInRoute[]): route is V3PoolInRoute[] {\n  return route[0].type === 'v3-pool'\n}\n"]},"metadata":{},"sourceType":"module"}