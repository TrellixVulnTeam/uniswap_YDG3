{"ast":null,"code":"/* eslint no-constant-condition: 0 */\n\n/**\n * Mnemonist StaticDisjointSet\n * ============================\n *\n * JavaScript implementation of a static disjoint set (union-find).\n *\n * Note that to remain performant, this implementation needs to know a size\n * beforehand.\n */\nvar helpers = require('./utils/typed-arrays.js');\n/**\n * StaticDisjointSet.\n *\n * @constructor\n */\n\n\nfunction StaticDisjointSet(size) {\n  // Optimizing the typed array types\n  var ParentsTypedArray = helpers.getPointerArray(size),\n      RanksTypedArray = helpers.getPointerArray(Math.log2(size)); // Properties\n\n  this.size = size;\n  this.dimension = size;\n  this.parents = new ParentsTypedArray(size);\n  this.ranks = new RanksTypedArray(size); // Initializing parents\n\n  for (var i = 0; i < size; i++) this.parents[i] = i;\n}\n/**\n * Method used to find the root of the given item.\n *\n * @param  {number} x - Target item.\n * @return {number}\n */\n\n\nStaticDisjointSet.prototype.find = function (x) {\n  var y = x;\n  var c, p;\n\n  while (true) {\n    c = this.parents[y];\n    if (y === c) break;\n    y = c;\n  } // Path compression\n\n\n  while (true) {\n    p = this.parents[x];\n    if (p === y) break;\n    this.parents[x] = y;\n    x = p;\n  }\n\n  return y;\n};\n/**\n * Method used to perform the union of two items.\n *\n * @param  {number} x - First item.\n * @param  {number} y - Second item.\n * @return {StaticDisjointSet}\n */\n\n\nStaticDisjointSet.prototype.union = function (x, y) {\n  var xRoot = this.find(x),\n      yRoot = this.find(y); // x and y are already in the same set\n\n  if (xRoot === yRoot) return this;\n  this.dimension--; // x and y are not in the same set, we merge them\n\n  var xRank = this.ranks[x],\n      yRank = this.ranks[y];\n\n  if (xRank < yRank) {\n    this.parents[xRoot] = yRoot;\n  } else if (xRank > yRank) {\n    this.parents[yRoot] = xRoot;\n  } else {\n    this.parents[yRoot] = xRoot;\n    this.ranks[xRoot]++;\n  }\n\n  return this;\n};\n/**\n * Method returning whether two items are connected.\n *\n * @param  {number} x - First item.\n * @param  {number} y - Second item.\n * @return {boolean}\n */\n\n\nStaticDisjointSet.prototype.connected = function (x, y) {\n  var xRoot = this.find(x);\n  return xRoot === this.find(y);\n};\n/**\n * Method returning the set mapping.\n *\n * @return {TypedArray}\n */\n\n\nStaticDisjointSet.prototype.mapping = function () {\n  var MappingClass = helpers.getPointerArray(this.dimension);\n  var ids = {},\n      mapping = new MappingClass(this.size),\n      c = 0;\n  var r;\n\n  for (var i = 0, l = this.parents.length; i < l; i++) {\n    r = this.find(i);\n\n    if (typeof ids[r] === 'undefined') {\n      mapping[i] = c;\n      ids[r] = c++;\n    } else {\n      mapping[i] = ids[r];\n    }\n  }\n\n  return mapping;\n};\n/**\n * Method used to compile the disjoint set into an array of arrays.\n *\n * @return {array}\n */\n\n\nStaticDisjointSet.prototype.compile = function () {\n  var ids = {},\n      result = new Array(this.dimension),\n      c = 0;\n  var r;\n\n  for (var i = 0, l = this.parents.length; i < l; i++) {\n    r = this.find(i);\n\n    if (typeof ids[r] === 'undefined') {\n      result[c] = [i];\n      ids[r] = c++;\n    } else {\n      result[ids[r]].push(i);\n    }\n  }\n\n  return result;\n};\n/**\n * Convenience known methods.\n */\n\n\nStaticDisjointSet.prototype.inspect = function () {\n  var array = this.compile(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(array, 'constructor', {\n    value: StaticDisjointSet,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') StaticDisjointSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = StaticDisjointSet.prototype.inspect;\n/**\n * Exporting.\n */\n\nmodule.exports = StaticDisjointSet;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/static-disjoint-set.js"],"names":["helpers","require","StaticDisjointSet","size","ParentsTypedArray","getPointerArray","RanksTypedArray","Math","log2","dimension","parents","ranks","i","prototype","find","x","y","c","p","union","xRoot","yRoot","xRank","yRank","connected","mapping","MappingClass","ids","r","l","length","compile","result","Array","push","inspect","array","Object","defineProperty","value","enumerable","Symbol","for","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition: 0 */\n/**\n * Mnemonist StaticDisjointSet\n * ============================\n *\n * JavaScript implementation of a static disjoint set (union-find).\n *\n * Note that to remain performant, this implementation needs to know a size\n * beforehand.\n */\nvar helpers = require('./utils/typed-arrays.js');\n\n/**\n * StaticDisjointSet.\n *\n * @constructor\n */\nfunction StaticDisjointSet(size) {\n\n  // Optimizing the typed array types\n  var ParentsTypedArray = helpers.getPointerArray(size),\n      RanksTypedArray = helpers.getPointerArray(Math.log2(size));\n\n  // Properties\n  this.size = size;\n  this.dimension = size;\n  this.parents = new ParentsTypedArray(size);\n  this.ranks = new RanksTypedArray(size);\n\n  // Initializing parents\n  for (var i = 0; i < size; i++)\n    this.parents[i] = i;\n}\n\n/**\n * Method used to find the root of the given item.\n *\n * @param  {number} x - Target item.\n * @return {number}\n */\nStaticDisjointSet.prototype.find = function(x) {\n  var y = x;\n\n  var c, p;\n\n  while (true) {\n    c = this.parents[y];\n\n    if (y === c)\n      break;\n\n    y = c;\n  }\n\n  // Path compression\n  while (true) {\n    p = this.parents[x];\n\n    if (p === y)\n      break;\n\n    this.parents[x] = y;\n    x = p;\n  }\n\n  return y;\n};\n\n/**\n * Method used to perform the union of two items.\n *\n * @param  {number} x - First item.\n * @param  {number} y - Second item.\n * @return {StaticDisjointSet}\n */\nStaticDisjointSet.prototype.union = function(x, y) {\n  var xRoot = this.find(x),\n      yRoot = this.find(y);\n\n  // x and y are already in the same set\n  if (xRoot === yRoot)\n    return this;\n\n  this.dimension--;\n\n  // x and y are not in the same set, we merge them\n  var xRank = this.ranks[x],\n      yRank = this.ranks[y];\n\n  if (xRank < yRank) {\n    this.parents[xRoot] = yRoot;\n  }\n  else if (xRank > yRank) {\n    this.parents[yRoot] = xRoot;\n  }\n  else {\n    this.parents[yRoot] = xRoot;\n    this.ranks[xRoot]++;\n  }\n\n  return this;\n};\n\n/**\n * Method returning whether two items are connected.\n *\n * @param  {number} x - First item.\n * @param  {number} y - Second item.\n * @return {boolean}\n */\nStaticDisjointSet.prototype.connected = function(x, y) {\n  var xRoot = this.find(x);\n\n  return xRoot === this.find(y);\n};\n\n/**\n * Method returning the set mapping.\n *\n * @return {TypedArray}\n */\nStaticDisjointSet.prototype.mapping = function() {\n  var MappingClass = helpers.getPointerArray(this.dimension);\n\n  var ids = {},\n      mapping = new MappingClass(this.size),\n      c = 0;\n\n  var r;\n\n  for (var i = 0, l = this.parents.length; i < l; i++) {\n    r = this.find(i);\n\n    if (typeof ids[r] === 'undefined') {\n      mapping[i] = c;\n      ids[r] = c++;\n    }\n    else {\n      mapping[i] = ids[r];\n    }\n  }\n\n  return mapping;\n};\n\n/**\n * Method used to compile the disjoint set into an array of arrays.\n *\n * @return {array}\n */\nStaticDisjointSet.prototype.compile = function() {\n  var ids = {},\n      result = new Array(this.dimension),\n      c = 0;\n\n  var r;\n\n  for (var i = 0, l = this.parents.length; i < l; i++) {\n    r = this.find(i);\n\n    if (typeof ids[r] === 'undefined') {\n      result[c] = [i];\n      ids[r] = c++;\n    }\n    else {\n      result[ids[r]].push(i);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Convenience known methods.\n */\nStaticDisjointSet.prototype.inspect = function() {\n  var array = this.compile();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: StaticDisjointSet,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  StaticDisjointSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = StaticDisjointSet.prototype.inspect;\n\n\n/**\n * Exporting.\n */\nmodule.exports = StaticDisjointSet;\n"]},"metadata":{},"sourceType":"script"}