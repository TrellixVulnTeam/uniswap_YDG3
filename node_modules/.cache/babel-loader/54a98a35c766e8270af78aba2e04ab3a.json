{"ast":null,"code":"import { useRef, useState, useEffect, useCallback, useMemo } from 'react'; // This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\n\nfunction useResolvedElement(subscriber, refOrElement) {\n  var callbackRefElement = useRef(null);\n  var lastReportRef = useRef(null);\n  var cleanupRef = useRef();\n  var callSubscriber = useCallback(function () {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refOrElement) {\n      if (refOrElement instanceof HTMLElement) {\n        element = refOrElement;\n      } else {\n        element = refOrElement.current;\n      }\n    }\n\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportRef.current = {\n      reporter: callSubscriber,\n      element: element\n    }; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  }, [refOrElement, subscriber]); // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n  useEffect(function () {\n    // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a\n    // render accompanying that change as well.\n    // To guarantee we always have the right element, one must use the ref callback provided instead, but we support\n    // RefObjects to make the hook API more convenient in certain cases.\n    callSubscriber();\n  }, [callSubscriber]);\n  return useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, [callSubscriber]);\n} // We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\n\n\nvar extractSize = function extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n};\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  } // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n\n\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(useCallback(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport { useResizeObserver as default };","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/use-resize-observer/dist/bundle.esm.js"],"names":["useRef","useState","useEffect","useCallback","useMemo","useResolvedElement","subscriber","refOrElement","callbackRefElement","lastReportRef","cleanupRef","callSubscriber","element","current","HTMLElement","reporter","extractSize","entry","boxProp","sizeType","contentRect","undefined","useResizeObserver","opts","onResize","onResizeRef","round","Math","resizeObserverRef","_useState","width","height","size","setSize","didUnmount","previous","refCallback","box","instance","ResizeObserver","entries","reportedWidth","reportedHeight","newWidth","newHeight","newSize","observe","unobserve","ref","default"],"mappings":"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","sourcesContent":["import { useRef, useState, useEffect, useCallback, useMemo } from 'react';\n\n// This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\nfunction useResolvedElement(subscriber, refOrElement) {\n  var callbackRefElement = useRef(null);\n  var lastReportRef = useRef(null);\n  var cleanupRef = useRef();\n  var callSubscriber = useCallback(function () {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refOrElement) {\n      if (refOrElement instanceof HTMLElement) {\n        element = refOrElement;\n      } else {\n        element = refOrElement.current;\n      }\n    }\n\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportRef.current = {\n      reporter: callSubscriber,\n      element: element\n    }; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  }, [refOrElement, subscriber]); // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n  useEffect(function () {\n    // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a\n    // render accompanying that change as well.\n    // To guarantee we always have the right element, one must use the ref callback provided instead, but we support\n    // RefObjects to make the hook API more convenient in certain cases.\n    callSubscriber();\n  }, [callSubscriber]);\n  return useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, [callSubscriber]);\n}\n\n// We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\nvar extractSize = function extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n};\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(useCallback(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport { useResizeObserver as default };\n"]},"metadata":{},"sourceType":"module"}