{"ast":null,"code":"/**\n * Mnemonist CircularBuffer\n * =========================\n *\n * Circular buffer implementation fit to use as a finite deque.\n */\nvar iterables = require('./utils/iterables.js'),\n    FixedDeque = require('./fixed-deque');\n/**\n * CircularBuffer.\n *\n * @constructor\n */\n\n\nfunction CircularBuffer(ArrayClass, capacity) {\n  if (arguments.length < 2) throw new Error('mnemonist/circular-buffer: expecting an Array class and a capacity.');\n  if (typeof capacity !== 'number' || capacity <= 0) throw new Error('mnemonist/circular-buffer: `capacity` should be a positive number.');\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(this.capacity);\n  this.clear();\n}\n/**\n * Pasting most of the prototype from FixedDeque.\n */\n\n\nfunction paste(name) {\n  CircularBuffer.prototype[name] = FixedDeque.prototype[name];\n}\n\nObject.keys(FixedDeque.prototype).forEach(paste);\nif (typeof Symbol !== 'undefined') Object.getOwnPropertySymbols(FixedDeque.prototype).forEach(paste);\n/**\n * Method used to append a value to the buffer.\n *\n * @param  {any}    item - Item to append.\n * @return {number}      - Returns the new size of the buffer.\n */\n\nCircularBuffer.prototype.push = function (item) {\n  var index = (this.start + this.size) % this.capacity;\n  this.items[index] = item; // Overwriting?\n\n  if (this.size === this.capacity) {\n    // If start is at the end, we wrap around the buffer\n    this.start = (index + 1) % this.capacity;\n    return this.size;\n  }\n\n  return ++this.size;\n};\n/**\n * Method used to prepend a value to the buffer.\n *\n * @param  {any}    item - Item to prepend.\n * @return {number}      - Returns the new size of the buffer.\n */\n\n\nCircularBuffer.prototype.unshift = function (item) {\n  var index = this.start - 1;\n  if (this.start === 0) index = this.capacity - 1;\n  this.items[index] = item; // Overwriting\n\n  if (this.size === this.capacity) {\n    this.start = index;\n    return this.size;\n  }\n\n  this.start = index;\n  return ++this.size;\n};\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a circular buffer.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FiniteStack}\n */\n\n\nCircularBuffer.from = function (iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n    if (typeof capacity !== 'number') throw new Error('mnemonist/circular-buffer.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var buffer = new CircularBuffer(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++) buffer.items[i] = iterable[i];\n\n    buffer.size = l;\n    return buffer;\n  }\n\n  iterables.forEach(iterable, function (value) {\n    buffer.push(value);\n  });\n  return buffer;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = CircularBuffer;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/circular-buffer.js"],"names":["iterables","require","FixedDeque","CircularBuffer","ArrayClass","capacity","arguments","length","Error","items","clear","paste","name","prototype","Object","keys","forEach","Symbol","getOwnPropertySymbols","push","item","index","start","size","unshift","from","iterable","guessLength","buffer","isArrayLike","i","l","value","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist CircularBuffer\n * =========================\n *\n * Circular buffer implementation fit to use as a finite deque.\n */\nvar iterables = require('./utils/iterables.js'),\n    FixedDeque = require('./fixed-deque');\n\n/**\n * CircularBuffer.\n *\n * @constructor\n */\nfunction CircularBuffer(ArrayClass, capacity) {\n\n  if (arguments.length < 2)\n    throw new Error('mnemonist/circular-buffer: expecting an Array class and a capacity.');\n\n  if (typeof capacity !== 'number' || capacity <= 0)\n    throw new Error('mnemonist/circular-buffer: `capacity` should be a positive number.');\n\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(this.capacity);\n  this.clear();\n}\n\n/**\n * Pasting most of the prototype from FixedDeque.\n */\nfunction paste(name) {\n  CircularBuffer.prototype[name] = FixedDeque.prototype[name];\n}\n\nObject.keys(FixedDeque.prototype).forEach(paste);\n\nif (typeof Symbol !== 'undefined')\n  Object.getOwnPropertySymbols(FixedDeque.prototype).forEach(paste);\n\n/**\n * Method used to append a value to the buffer.\n *\n * @param  {any}    item - Item to append.\n * @return {number}      - Returns the new size of the buffer.\n */\nCircularBuffer.prototype.push = function(item) {\n  var index = (this.start + this.size) % this.capacity;\n\n  this.items[index] = item;\n\n  // Overwriting?\n  if (this.size === this.capacity) {\n\n    // If start is at the end, we wrap around the buffer\n    this.start = (index + 1) % this.capacity;\n\n    return this.size;\n  }\n\n  return ++this.size;\n};\n\n/**\n * Method used to prepend a value to the buffer.\n *\n * @param  {any}    item - Item to prepend.\n * @return {number}      - Returns the new size of the buffer.\n */\nCircularBuffer.prototype.unshift = function(item) {\n  var index = this.start - 1;\n\n  if (this.start === 0)\n    index = this.capacity - 1;\n\n  this.items[index] = item;\n\n  // Overwriting\n  if (this.size === this.capacity) {\n\n    this.start = index;\n\n    return this.size;\n  }\n\n  this.start = index;\n\n  return ++this.size;\n};\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a circular buffer.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FiniteStack}\n */\nCircularBuffer.from = function(iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/circular-buffer.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var buffer = new CircularBuffer(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++)\n      buffer.items[i] = iterable[i];\n\n    buffer.size = l;\n\n    return buffer;\n  }\n\n  iterables.forEach(iterable, function(value) {\n    buffer.push(value);\n  });\n\n  return buffer;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = CircularBuffer;\n"]},"metadata":{},"sourceType":"script"}