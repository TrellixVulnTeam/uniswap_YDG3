{"ast":null,"code":"import { TradeType } from '@uniswap/sdk-core';\nimport { BigNumber } from 'ethers';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport { FixedReverseHeap, Queue } from 'mnemonist';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig) {\n  const now = Date.now(); // Build a map of percentage of the input to list of valid quotes.\n  // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n\n  const percentToQuotes = {};\n\n  for (const routeWithValidQuote of routesWithValidQuotes) {\n    if (!percentToQuotes[routeWithValidQuote.percent]) {\n      percentToQuotes[routeWithValidQuote.percent] = [];\n    }\n\n    percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n  }\n\n  metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds); // Given all the valid quotes for each percentage find the optimal route.\n\n  const swapRoute = getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, rq => rq.quoteAdjustedForGas, routingConfig); // It is possible we were unable to find any valid route given the quotes.\n\n  if (!swapRoute) {\n    return null;\n  } // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n  // route of our optimal quote may not add up exactly to exactIn or exactOut.\n  //\n  // We check this here, and if there is a mismatch\n  // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n\n\n  const {\n    routes: routeAmounts\n  } = swapRoute;\n\n  const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n\n  const missingAmount = amount.subtract(totalAmount);\n\n  if (missingAmount.greaterThan(0)) {\n    log.info({\n      missingAmount: missingAmount.quotient.toString()\n    }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n    routeAmounts[routeAmounts.length - 1].amount = routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n  }\n\n  log.info({\n    routes: routeAmountsToString(routeAmounts),\n    numSplits: routeAmounts.length,\n    amount: amount.toExact(),\n    quote: swapRoute.quote.toExact(),\n    quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(2),\n    estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(2),\n    estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(2)\n  }, `Found best swap route. ${routeAmounts.length} split.`);\n  return swapRoute;\n}\nexport function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig) {\n  // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n  const percentToSortedQuotes = _.mapValues(percentToQuotes, routeQuotes => {\n    return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n      } else {\n        return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n      }\n    });\n  });\n\n  log.info({\n    percentToTop5SortedQuotes: _.mapValues(percentToSortedQuotes, ps => _.map(ps.slice(0, 5), p => ({\n      protocol: p.protocol,\n      route: routeToString(p.route),\n      percent: p.percent,\n      quote: p.quoteAdjustedForGas.toFixed(2)\n    })))\n  }, 'Top 5 Quotes for each percentage');\n  const quoteCompFn = routeType == TradeType.EXACT_INPUT ? (a, b) => a.greaterThan(b) : (a, b) => a.lessThan(b);\n\n  const sumFn = currencyAmounts => {\n    let sum = currencyAmounts[0];\n\n    for (let i = 1; i < currencyAmounts.length; i++) {\n      sum = sum.add(currencyAmounts[i]);\n    }\n\n    return sum;\n  };\n\n  let bestQuote;\n  let bestSwap; // Min-heap for tracking the 5 best swaps given some number of splits.\n\n  const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n    return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n  }, 5);\n  const {\n    minSplits,\n    maxSplits,\n    forceCrossProtocol\n  } = routingConfig;\n\n  if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n    log.info({\n      percentToSortedQuotes: _.mapValues(percentToSortedQuotes, p => p.length)\n    }, 'Did not find a valid route without any splits. Continuing search anyway.');\n  } else {\n    bestQuote = by(percentToSortedQuotes[100][0]);\n    bestSwap = [percentToSortedQuotes[100][0]];\n\n    for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n      bestSwapsPerSplit.push({\n        quote: by(routeWithQuote),\n        routes: [routeWithQuote]\n      });\n    }\n  } // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n\n\n  const queue = new Queue(); // First we seed BFS queue with the best quotes for each percentage.\n  // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n  // We will explore the various combinations from each node.\n\n  for (let i = percents.length; i >= 0; i--) {\n    const percent = percents[i];\n\n    if (!percentToSortedQuotes[percent]) {\n      continue;\n    }\n\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][0]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: false\n    });\n\n    if (!percentToSortedQuotes[percent] || !percentToSortedQuotes[percent][1]) {\n      continue;\n    }\n\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][1]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: true\n    });\n  }\n\n  let splits = 1;\n  let startedSplit = Date.now();\n\n  while (queue.size > 0) {\n    metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n    startedSplit = Date.now();\n    log.info({\n      top5: _.map(Array.from(bestSwapsPerSplit.consume()), q => `${q.quote.toExact()} (${_(q.routes).map(r => r.toString()).join(', ')})`),\n      onQueue: queue.size\n    }, `Top 5 with ${splits} splits`);\n    bestSwapsPerSplit.clear(); // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n\n    let layer = queue.size;\n    splits++; // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n\n    if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n      break;\n    }\n\n    if (splits > maxSplits) {\n      log.info('Max splits reached. Stopping search.');\n      metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n      break;\n    }\n\n    while (layer > 0) {\n      layer--;\n      const {\n        remainingPercent,\n        curRoutes,\n        percentIndex,\n        special\n      } = queue.dequeue(); // For all other percentages, add a new potential route.\n      // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n      // 50% + new 10% route, 50% + new 20% route, etc.\n\n      for (let i = percentIndex; i >= 0; i--) {\n        const percentA = percents[i];\n\n        if (percentA > remainingPercent) {\n          continue;\n        } // At some point the amount * percentage is so small that the quoter is unable to get\n        // a quote. In this case there could be no quotes for that percentage.\n\n\n        if (!percentToSortedQuotes[percentA]) {\n          continue;\n        }\n\n        const candidateRoutesA = percentToSortedQuotes[percentA]; // Find the best route in the complimentary percentage that doesn't re-use a pool already\n        // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n        // so it would make the quotes inaccurate.\n\n        const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n\n        if (!routeWithQuoteA) {\n          continue;\n        }\n\n        const remainingPercentNew = remainingPercent - percentA;\n        const curRoutesNew = [...curRoutes, routeWithQuoteA]; // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n\n        if (remainingPercentNew == 0 && splits >= minSplits) {\n          const quotesNew = _.map(curRoutesNew, r => by(r));\n\n          const quoteNew = sumFn(quotesNew);\n          bestSwapsPerSplit.push({\n            quote: quoteNew,\n            routes: curRoutesNew\n          });\n\n          if (!bestQuote || quoteCompFn(quoteNew, bestQuote)) {\n            bestQuote = quoteNew;\n            bestSwap = curRoutesNew; // Temporary experiment.\n\n            if (special) {\n              metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n            }\n          }\n        } else {\n          queue.enqueue({\n            curRoutes: curRoutesNew,\n            remainingPercent: remainingPercentNew,\n            percentIndex: i,\n            special\n          });\n        }\n      }\n    }\n  }\n\n  if (!bestSwap) {\n    log.info(`Could not find a valid swap`);\n    return undefined;\n  }\n\n  const postSplitNow = Date.now();\n  const quoteGasAdjusted = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.quoteAdjustedForGas));\n\n  const estimatedGasUsed = _(bestSwap).map(routeWithValidQuote => routeWithValidQuote.gasEstimate).reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0)); // Each route can use a different stablecoin to account its gas costs.\n  // They should all be pegged, and this is just an estimate, so we do a merge\n  // to an arbitrary stable.\n\n\n  if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n    throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n  }\n\n  const usdToken = usdGasTokensByChain[chainId][0];\n  const usdTokenDecimals = usdToken.decimals; // For each gas estimate, normalize decimals to that of the chosen usd token.\n\n  const estimatedGasUsedUSDs = _(bestSwap).map(routeWithValidQuote => {\n    const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n\n    if (decimalsDiff == 0) {\n      return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n    }\n\n    return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n  }).value();\n\n  const estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n  log.info({\n    estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n    normalizedUsdToken: usdToken,\n    routeUSDGasEstimates: _.map(bestSwap, b => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`)\n  }, 'USD gas estimates of best route');\n  const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.gasCostInToken));\n  const quote = sumFn(_.map(bestSwap, routeWithValidQuote => routeWithValidQuote.quote));\n  const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n  metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n  return {\n    quote,\n    quoteGasAdjusted,\n    estimatedGasUsed,\n    estimatedGasUsedUSD,\n    estimatedGasUsedQuoteToken,\n    routes: routeWithQuotes\n  };\n} // We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\n\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n  const poolAddressSet = new Set();\n\n  const usedPoolAddresses = _(usedRoutes).flatMap(r => r.poolAddresses).value();\n\n  for (let poolAddress of usedPoolAddresses) {\n    poolAddressSet.add(poolAddress);\n  }\n\n  const protocolsSet = new Set();\n\n  const usedProtocols = _(usedRoutes).flatMap(r => r.protocol).uniq().value();\n\n  for (let protocol of usedProtocols) {\n    protocolsSet.add(protocol);\n  }\n\n  for (const routeQuote of candidateRouteQuotes) {\n    const {\n      poolAddresses,\n      protocol\n    } = routeQuote;\n\n    if (poolAddresses.some(poolAddress => poolAddressSet.has(poolAddress))) {\n      continue;\n    } // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n    // consideration of routes that come from the same protocol as a used route.\n\n\n    const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n\n    if (needToForce && protocolsSet.has(protocol)) {\n      continue;\n    }\n\n    return routeQuote;\n  }\n\n  return null;\n};","map":{"version":3,"sources":["../../../../../../src/routers/alpha-router/functions/best-swap-route.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,mBAA1B;AACA,SAAS,SAAT,QAA0B,QAA1B;AACA,OAAO,IAAP,MAAiB,MAAjB;AACA,OAAO,CAAP,MAAc,QAAd;AACA,SAAS,gBAAT,EAA2B,KAA3B,QAAwC,WAAxC;AAEA,SAAS,cAAT,QAA+B,uBAA/B;AACA,SAAS,GAAT,QAAoB,mBAApB;AACA,SAAS,MAAT,EAAiB,gBAAjB,QAAyC,sBAAzC;AACA,SAAS,oBAAT,EAA+B,aAA/B,QAAoD,sBAApD;AAEA,SAAS,mBAAT,QAAoC,eAApC;AAGA,OAAM,SAAU,gBAAV,CACJ,MADI,EAEJ,QAFI,EAGJ,qBAHI,EAIJ,SAJI,EAKJ,OALI,EAMJ,aANI,EAM4B;AAShC,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ,CATgC,CAWhC;AACA;;AACA,QAAM,eAAe,GAAiD,EAAtE;;AACA,OAAK,MAAM,mBAAX,IAAkC,qBAAlC,EAAyD;AACvD,QAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAApB,EAAmD;AACjD,MAAA,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAAf,GAA+C,EAA/C;AACD;;AACD,IAAA,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAAf,CAA8C,IAA9C,CAAmD,mBAAnD;AACD;;AAED,EAAA,MAAM,CAAC,SAAP,CACE,iCADF,EAEE,IAAI,CAAC,GAAL,KAAa,GAFf,EAGE,gBAAgB,CAAC,YAHnB,EArBgC,CA2BhC;;AACA,QAAM,SAAS,GAAG,kBAAkB,CAClC,SADkC,EAElC,eAFkC,EAGlC,QAHkC,EAIlC,OAJkC,EAKjC,EAAD,IAA6B,EAAE,CAAC,mBALE,EAMlC,aANkC,CAApC,CA5BgC,CAqChC;;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,WAAO,IAAP;AACD,GAxC+B,CA0ChC;AACA;AACA;AACA;AACA;;;AACA,QAAM;AAAE,IAAA,MAAM,EAAE;AAAV,MAA2B,SAAjC;;AACA,QAAM,WAAW,GAAG,CAAC,CAAC,MAAF,CAClB,YADkB,EAElB,CAAC,KAAD,EAAQ,WAAR,KAAwB,KAAK,CAAC,GAAN,CAAU,WAAW,CAAC,MAAtB,CAFN,EAGlB,cAAc,CAAC,aAAf,CAA6B,YAAY,CAAC,CAAD,CAAZ,CAAiB,MAAjB,CAAwB,QAArD,EAA+D,CAA/D,CAHkB,CAApB;;AAMA,QAAM,aAAa,GAAG,MAAM,CAAC,QAAP,CAAgB,WAAhB,CAAtB;;AACA,MAAI,aAAa,CAAC,WAAd,CAA0B,CAA1B,CAAJ,EAAkC;AAChC,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,aAAa,EAAE,aAAa,CAAC,QAAd,CAAuB,QAAvB;AADjB,KADF,EAIE,6GAJF;AAOA,IAAA,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAZ,CAAuC,MAAvC,GACE,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAZ,CAAuC,MAAvC,CAA8C,GAA9C,CAAkD,aAAlD,CADF;AAED;;AAED,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,MAAM,EAAE,oBAAoB,CAAC,YAAD,CAD9B;AAEE,IAAA,SAAS,EAAE,YAAY,CAAC,MAF1B;AAGE,IAAA,MAAM,EAAE,MAAM,CAAC,OAAP,EAHV;AAIE,IAAA,KAAK,EAAE,SAAS,CAAC,KAAV,CAAgB,OAAhB,EAJT;AAKE,IAAA,gBAAgB,EAAE,SAAS,CAAC,gBAAV,CAA2B,OAA3B,CAAmC,CAAnC,CALpB;AAME,IAAA,eAAe,EAAE,SAAS,CAAC,mBAAV,CAA8B,OAA9B,CAAsC,CAAtC,CANnB;AAOE,IAAA,iBAAiB,EAAE,SAAS,CAAC,0BAAV,CAAqC,OAArC,CAA6C,CAA7C;AAPrB,GADF,EAUE,0BAA0B,YAAY,CAAC,MAAM,SAV/C;AAaA,SAAO,SAAP;AACD;AAED,OAAM,SAAU,kBAAV,CACJ,SADI,EAEJ,eAFI,EAGJ,QAHI,EAIJ,OAJI,EAKJ,EALI,EAMJ,aANI,EAM4B;AAWhC;AACA,QAAM,qBAAqB,GAAG,CAAC,CAAC,SAAF,CAC5B,eAD4B,EAE3B,WAAD,IAAuC;AACrC,WAAO,WAAW,CAAC,IAAZ,CAAiB,CAAC,WAAD,EAAc,WAAd,KAA6B;AACnD,UAAI,SAAS,IAAI,SAAS,CAAC,WAA3B,EAAwC;AACtC,eAAO,EAAE,CAAC,WAAD,CAAF,CAAgB,WAAhB,CAA4B,EAAE,CAAC,WAAD,CAA9B,IAA+C,CAAC,CAAhD,GAAoD,CAA3D;AACD,OAFD,MAEO;AACL,eAAO,EAAE,CAAC,WAAD,CAAF,CAAgB,QAAhB,CAAyB,EAAE,CAAC,WAAD,CAA3B,IAA4C,CAAC,CAA7C,GAAiD,CAAxD;AACD;AACF,KANM,CAAP;AAOD,GAV2B,CAA9B;;AAaA,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,yBAAyB,EAAE,CAAC,CAAC,SAAF,CAAY,qBAAZ,EAAoC,EAAD,IAC5D,CAAC,CAAC,GAAF,CAAM,EAAE,CAAC,KAAH,CAAS,CAAT,EAAY,CAAZ,CAAN,EAAuB,CAAD,KAAQ;AAC5B,MAAA,QAAQ,EAAE,CAAC,CAAC,QADgB;AAE5B,MAAA,KAAK,EAAE,aAAa,CAAC,CAAC,CAAC,KAAH,CAFQ;AAG5B,MAAA,OAAO,EAAE,CAAC,CAAC,OAHiB;AAI5B,MAAA,KAAK,EAAE,CAAC,CAAC,mBAAF,CAAsB,OAAtB,CAA8B,CAA9B;AAJqB,KAAR,CAAtB,CADyB;AAD7B,GADF,EAWE,kCAXF;AAcA,QAAM,WAAW,GACf,SAAS,IAAI,SAAS,CAAC,WAAvB,GACI,CAAC,CAAD,EAAoB,CAApB,KAA0C,CAAC,CAAC,WAAF,CAAc,CAAd,CAD9C,GAEI,CAAC,CAAD,EAAoB,CAApB,KAA0C,CAAC,CAAC,QAAF,CAAW,CAAX,CAHhD;;AAKA,QAAM,KAAK,GAAI,eAAD,IAAsD;AAClE,QAAI,GAAG,GAAG,eAAe,CAAC,CAAD,CAAzB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,eAAe,CAAC,MAApC,EAA4C,CAAC,EAA7C,EAAiD;AAC/C,MAAA,GAAG,GAAG,GAAG,CAAC,GAAJ,CAAQ,eAAe,CAAC,CAAD,CAAvB,CAAN;AACD;;AACD,WAAO,GAAP;AACD,GAND;;AAQA,MAAI,SAAJ;AACA,MAAI,QAAJ,CArDgC,CAuDhC;;AACA,QAAM,iBAAiB,GAAG,IAAI,gBAAJ,CAIxB,KAJwB,EAKxB,CAAC,CAAD,EAAI,CAAJ,KAAS;AACP,WAAO,WAAW,CAAC,CAAC,CAAC,KAAH,EAAU,CAAC,CAAC,KAAZ,CAAX,GAAgC,CAAC,CAAjC,GAAqC,CAA5C;AACD,GAPuB,EAQxB,CARwB,CAA1B;AAWA,QAAM;AAAE,IAAA,SAAF;AAAa,IAAA,SAAb;AAAwB,IAAA;AAAxB,MAA+C,aAArD;;AAEA,MAAI,CAAC,qBAAqB,CAAC,GAAD,CAAtB,IAA+B,SAAS,GAAG,CAA3C,IAAgD,kBAApD,EAAwE;AACtE,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,qBAAqB,EAAE,CAAC,CAAC,SAAF,CACrB,qBADqB,EAEpB,CAAD,IAAO,CAAC,CAAC,MAFY;AADzB,KADF,EAOE,0EAPF;AASD,GAVD,MAUO;AACL,IAAA,SAAS,GAAG,EAAE,CAAC,qBAAqB,CAAC,GAAD,CAArB,CAA2B,CAA3B,CAAD,CAAd;AACA,IAAA,QAAQ,GAAG,CAAC,qBAAqB,CAAC,GAAD,CAArB,CAA2B,CAA3B,CAAD,CAAX;;AAEA,SAAK,MAAM,cAAX,IAA6B,qBAAqB,CAAC,GAAD,CAArB,CAA2B,KAA3B,CAAiC,CAAjC,EAAoC,CAApC,CAA7B,EAAqE;AACnE,MAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,QAAA,KAAK,EAAE,EAAE,CAAC,cAAD,CADY;AAErB,QAAA,MAAM,EAAE,CAAC,cAAD;AAFa,OAAvB;AAID;AACF,GAzF+B,CA2FhC;;;AACA,QAAM,KAAK,GAAG,IAAI,KAAJ,EAAd,CA5FgC,CAmGhC;AACA;AACA;;AACA,OAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAtB,EAA8B,CAAC,IAAI,CAAnC,EAAsC,CAAC,EAAvC,EAA2C;AACzC,UAAM,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAxB;;AAEA,QAAI,CAAC,qBAAqB,CAAC,OAAD,CAA1B,EAAqC;AACnC;AACD;;AAED,IAAA,KAAK,CAAC,OAAN,CAAc;AACZ,MAAA,SAAS,EAAE,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAAD,CADC;AAEZ,MAAA,YAAY,EAAE,CAFF;AAGZ,MAAA,gBAAgB,EAAE,MAAM,OAHZ;AAIZ,MAAA,OAAO,EAAE;AAJG,KAAd;;AAOA,QACE,CAAC,qBAAqB,CAAC,OAAD,CAAtB,IACA,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAFH,EAGE;AACA;AACD;;AAED,IAAA,KAAK,CAAC,OAAN,CAAc;AACZ,MAAA,SAAS,EAAE,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAAD,CADC;AAEZ,MAAA,YAAY,EAAE,CAFF;AAGZ,MAAA,gBAAgB,EAAE,MAAM,OAHZ;AAIZ,MAAA,OAAO,EAAE;AAJG,KAAd;AAMD;;AAED,MAAI,MAAM,GAAG,CAAb;AACA,MAAI,YAAY,GAAG,IAAI,CAAC,GAAL,EAAnB;;AAEA,SAAO,KAAK,CAAC,IAAN,GAAa,CAApB,EAAuB;AACrB,IAAA,MAAM,CAAC,SAAP,CACE,QAAQ,MAAM,MADhB,EAEE,IAAI,CAAC,GAAL,KAAa,YAFf,EAGE,gBAAgB,CAAC,YAHnB;AAMA,IAAA,YAAY,GAAG,IAAI,CAAC,GAAL,EAAf;AAEA,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,IAAI,EAAE,CAAC,CAAC,GAAF,CACJ,KAAK,CAAC,IAAN,CAAW,iBAAiB,CAAC,OAAlB,EAAX,CADI,EAEH,CAAD,IACE,GAAG,CAAC,CAAC,KAAF,CAAQ,OAAR,EAAiB,KAAK,CAAC,CAAC,CAAC,CAAC,MAAH,CAAD,CACtB,GADsB,CACjB,CAAD,IAAO,CAAC,CAAC,QAAF,EADW,EAEtB,IAFsB,CAEjB,IAFiB,CAEZ,GALX,CADR;AAQE,MAAA,OAAO,EAAE,KAAK,CAAC;AARjB,KADF,EAWE,cAAc,MAAM,SAXtB;AAcA,IAAA,iBAAiB,CAAC,KAAlB,GAvBqB,CAyBrB;;AACA,QAAI,KAAK,GAAG,KAAK,CAAC,IAAlB;AACA,IAAA,MAAM,GA3Be,CA6BrB;;AACA,QAAI,MAAM,IAAI,CAAV,IAAe,QAAf,IAA2B,QAAQ,CAAC,MAAT,GAAkB,MAAM,GAAG,CAA1D,EAA6D;AAC3D;AACD;;AAED,QAAI,MAAM,GAAG,SAAb,EAAwB;AACtB,MAAA,GAAG,CAAC,IAAJ,CAAS,sCAAT;AACA,MAAA,MAAM,CAAC,SAAP,CAAiB,qBAAjB,EAAwC,CAAxC,EAA2C,gBAAgB,CAAC,KAA5D;AACA;AACD;;AAED,WAAO,KAAK,GAAG,CAAf,EAAkB;AAChB,MAAA,KAAK;AAEL,YAAM;AAAE,QAAA,gBAAF;AAAoB,QAAA,SAApB;AAA+B,QAAA,YAA/B;AAA6C,QAAA;AAA7C,UACJ,KAAK,CAAC,OAAN,EADF,CAHgB,CAMhB;AACA;AACA;;AACA,WAAK,IAAI,CAAC,GAAG,YAAb,EAA2B,CAAC,IAAI,CAAhC,EAAmC,CAAC,EAApC,EAAwC;AACtC,cAAM,QAAQ,GAAG,QAAQ,CAAC,CAAD,CAAzB;;AAEA,YAAI,QAAQ,GAAG,gBAAf,EAAiC;AAC/B;AACD,SALqC,CAOtC;AACA;;;AACA,YAAI,CAAC,qBAAqB,CAAC,QAAD,CAA1B,EAAsC;AACpC;AACD;;AAED,cAAM,gBAAgB,GAAG,qBAAqB,CAAC,QAAD,CAA9C,CAbsC,CAetC;AACA;AACA;;AACA,cAAM,eAAe,GAAG,+BAA+B,CACrD,SADqD,EAErD,gBAFqD,EAGrD,kBAHqD,CAAvD;;AAMA,YAAI,CAAC,eAAL,EAAsB;AACpB;AACD;;AAED,cAAM,mBAAmB,GAAG,gBAAgB,GAAG,QAA/C;AACA,cAAM,YAAY,GAAG,CAAC,GAAG,SAAJ,EAAe,eAAf,CAArB,CA7BsC,CA+BtC;;AACA,YAAI,mBAAmB,IAAI,CAAvB,IAA4B,MAAM,IAAI,SAA1C,EAAqD;AACnD,gBAAM,SAAS,GAAG,CAAC,CAAC,GAAF,CAAM,YAAN,EAAqB,CAAD,IAAO,EAAE,CAAC,CAAD,CAA7B,CAAlB;;AACA,gBAAM,QAAQ,GAAG,KAAK,CAAC,SAAD,CAAtB;AAEA,UAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,YAAA,KAAK,EAAE,QADc;AAErB,YAAA,MAAM,EAAE;AAFa,WAAvB;;AAKA,cAAI,CAAC,SAAD,IAAc,WAAW,CAAC,QAAD,EAAW,SAAX,CAA7B,EAAoD;AAClD,YAAA,SAAS,GAAG,QAAZ;AACA,YAAA,QAAQ,GAAG,YAAX,CAFkD,CAIlD;;AACA,gBAAI,OAAJ,EAAa;AACX,cAAA,MAAM,CAAC,SAAP,CACE,kCADF,EAEE,CAFF,EAGE,gBAAgB,CAAC,KAHnB;AAKD;AACF;AACF,SAtBD,MAsBO;AACL,UAAA,KAAK,CAAC,OAAN,CAAc;AACZ,YAAA,SAAS,EAAE,YADC;AAEZ,YAAA,gBAAgB,EAAE,mBAFN;AAGZ,YAAA,YAAY,EAAE,CAHF;AAIZ,YAAA;AAJY,WAAd;AAMD;AACF;AACF;AACF;;AAED,MAAI,CAAC,QAAL,EAAe;AACb,IAAA,GAAG,CAAC,IAAJ,CAAS,6BAAT;AACA,WAAO,SAAP;AACD;;AAED,QAAM,YAAY,GAAG,IAAI,CAAC,GAAL,EAArB;AAEA,QAAM,gBAAgB,GAAG,KAAK,CAC5B,CAAC,CAAC,GAAF,CACE,QADF,EAEG,mBAAD,IAAyB,mBAAmB,CAAC,mBAF/C,CAD4B,CAA9B;;AAOA,QAAM,gBAAgB,GAAG,CAAC,CAAC,QAAD,CAAD,CACtB,GADsB,CACjB,mBAAD,IAAyB,mBAAmB,CAAC,WAD3B,EAEtB,MAFsB,CAGrB,CAAC,GAAD,EAAM,mBAAN,KAA8B,GAAG,CAAC,GAAJ,CAAQ,mBAAR,CAHT,EAIrB,SAAS,CAAC,IAAV,CAAe,CAAf,CAJqB,CAAzB,CAvQgC,CA8QhC;AACA;AACA;;;AACA,MAAI,CAAC,mBAAmB,CAAC,OAAD,CAApB,IAAiC,CAAC,mBAAmB,CAAC,OAAD,CAAnB,CAA8B,CAA9B,CAAtC,EAAwE;AACtE,UAAM,IAAI,KAAJ,CACJ,yDAAyD,OAAO,EAD5D,CAAN;AAGD;;AACD,QAAM,QAAQ,GAAG,mBAAmB,CAAC,OAAD,CAAnB,CAA8B,CAA9B,CAAjB;AACA,QAAM,gBAAgB,GAAG,QAAQ,CAAC,QAAlC,CAvRgC,CAyRhC;;AACA,QAAM,oBAAoB,GAAG,CAAC,CAAC,QAAD,CAAD,CAC1B,GAD0B,CACrB,mBAAD,IAAwB;AAC3B,UAAM,YAAY,GAChB,gBAAgB,GAAG,mBAAmB,CAAC,YAApB,CAAiC,QAAjC,CAA0C,QAD/D;;AAGA,QAAI,YAAY,IAAI,CAApB,EAAuB;AACrB,aAAO,cAAc,CAAC,aAAf,CACL,QADK,EAEL,mBAAmB,CAAC,YAApB,CAAiC,QAF5B,CAAP;AAID;;AAED,WAAO,cAAc,CAAC,aAAf,CACL,QADK,EAEL,IAAI,CAAC,QAAL,CACE,mBAAmB,CAAC,YAApB,CAAiC,QADnC,EAEE,IAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAlB,EAAmC,IAAI,CAAC,MAAL,CAAY,YAAZ,CAAnC,CAFF,CAFK,CAAP;AAOD,GAnB0B,EAoB1B,KApB0B,EAA7B;;AAsBA,QAAM,mBAAmB,GAAG,KAAK,CAAC,oBAAD,CAAjC;AACA,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,mBAAmB,EAAE,mBAAmB,CAAC,OAApB,EADvB;AAEE,IAAA,kBAAkB,EAAE,QAFtB;AAGE,IAAA,oBAAoB,EAAE,CAAC,CAAC,GAAF,CACpB,QADoB,EAEnB,CAAD,IACE,GAAG,CAAC,CAAC,OAAO,KAAK,aAAa,CAAC,CAAC,CAAC,KAAH,CAAS,IAAI,CAAC,CAAC,YAAF,CAAe,OAAf,EAAwB,EAHjD;AAHxB,GADF,EAUE,iCAVF;AAaA,QAAM,0BAA0B,GAAG,KAAK,CACtC,CAAC,CAAC,GAAF,CAAM,QAAN,EAAiB,mBAAD,IAAyB,mBAAmB,CAAC,cAA7D,CADsC,CAAxC;AAIA,QAAM,KAAK,GAAG,KAAK,CACjB,CAAC,CAAC,GAAF,CAAM,QAAN,EAAiB,mBAAD,IAAyB,mBAAmB,CAAC,KAA7D,CADiB,CAAnB;AAIA,QAAM,eAAe,GAAG,QAAQ,CAAC,IAAT,CAAc,CAAC,YAAD,EAAe,YAAf,KACpC,YAAY,CAAC,MAAb,CAAoB,WAApB,CAAgC,YAAY,CAAC,MAA7C,IAAuD,CAAvD,GAA2D,CAAC,CADtC,CAAxB;AAIA,EAAA,MAAM,CAAC,SAAP,CACE,eADF,EAEE,IAAI,CAAC,GAAL,KAAa,YAFf,EAGE,gBAAgB,CAAC,YAHnB;AAMA,SAAO;AACL,IAAA,KADK;AAEL,IAAA,gBAFK;AAGL,IAAA,gBAHK;AAIL,IAAA,mBAJK;AAKL,IAAA,0BALK;AAML,IAAA,MAAM,EAAE;AANH,GAAP;AAQD,C,CAED;AACA;;AACA,MAAM,+BAA+B,GAAG,CACtC,UADsC,EAEtC,oBAFsC,EAGtC,kBAHsC,KAIR;AAC9B,QAAM,cAAc,GAAG,IAAI,GAAJ,EAAvB;;AACA,QAAM,iBAAiB,GAAG,CAAC,CAAC,UAAD,CAAD,CACvB,OADuB,CACd,CAAD,IAAO,CAAC,CAAC,aADM,EAEvB,KAFuB,EAA1B;;AAIA,OAAK,IAAI,WAAT,IAAwB,iBAAxB,EAA2C;AACzC,IAAA,cAAc,CAAC,GAAf,CAAmB,WAAnB;AACD;;AAED,QAAM,YAAY,GAAG,IAAI,GAAJ,EAArB;;AACA,QAAM,aAAa,GAAG,CAAC,CAAC,UAAD,CAAD,CACnB,OADmB,CACV,CAAD,IAAO,CAAC,CAAC,QADE,EAEnB,IAFmB,GAGnB,KAHmB,EAAtB;;AAKA,OAAK,IAAI,QAAT,IAAqB,aAArB,EAAoC;AAClC,IAAA,YAAY,CAAC,GAAb,CAAiB,QAAjB;AACD;;AAED,OAAK,MAAM,UAAX,IAAyB,oBAAzB,EAA+C;AAC7C,UAAM;AAAE,MAAA,aAAF;AAAiB,MAAA;AAAjB,QAA8B,UAApC;;AAEA,QAAI,aAAa,CAAC,IAAd,CAAoB,WAAD,IAAiB,cAAc,CAAC,GAAf,CAAmB,WAAnB,CAApC,CAAJ,EAA0E;AACxE;AACD,KAL4C,CAO7C;AACA;;;AACA,UAAM,WAAW,GAAG,kBAAkB,IAAI,YAAY,CAAC,IAAb,IAAqB,CAA/D;;AACA,QAAI,WAAW,IAAI,YAAY,CAAC,GAAb,CAAiB,QAAjB,CAAnB,EAA+C;AAC7C;AACD;;AAED,WAAO,UAAP;AACD;;AAED,SAAO,IAAP;AACD,CA1CD","sourceRoot":"","sourcesContent":["import { TradeType } from '@uniswap/sdk-core';\nimport { BigNumber } from 'ethers';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport { FixedReverseHeap, Queue } from 'mnemonist';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig) {\n    const now = Date.now();\n    // Build a map of percentage of the input to list of valid quotes.\n    // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n    const percentToQuotes = {};\n    for (const routeWithValidQuote of routesWithValidQuotes) {\n        if (!percentToQuotes[routeWithValidQuote.percent]) {\n            percentToQuotes[routeWithValidQuote.percent] = [];\n        }\n        percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n    }\n    metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n    // Given all the valid quotes for each percentage find the optimal route.\n    const swapRoute = getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, (rq) => rq.quoteAdjustedForGas, routingConfig);\n    // It is possible we were unable to find any valid route given the quotes.\n    if (!swapRoute) {\n        return null;\n    }\n    // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n    // route of our optimal quote may not add up exactly to exactIn or exactOut.\n    //\n    // We check this here, and if there is a mismatch\n    // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n    const { routes: routeAmounts } = swapRoute;\n    const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n    const missingAmount = amount.subtract(totalAmount);\n    if (missingAmount.greaterThan(0)) {\n        log.info({\n            missingAmount: missingAmount.quotient.toString(),\n        }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n        routeAmounts[routeAmounts.length - 1].amount =\n            routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n    }\n    log.info({\n        routes: routeAmountsToString(routeAmounts),\n        numSplits: routeAmounts.length,\n        amount: amount.toExact(),\n        quote: swapRoute.quote.toExact(),\n        quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(2),\n        estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(2),\n        estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(2),\n    }, `Found best swap route. ${routeAmounts.length} split.`);\n    return swapRoute;\n}\nexport function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig) {\n    // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n    const percentToSortedQuotes = _.mapValues(percentToQuotes, (routeQuotes) => {\n        return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n            }\n            else {\n                return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n            }\n        });\n    });\n    log.info({\n        percentToTop5SortedQuotes: _.mapValues(percentToSortedQuotes, (ps) => _.map(ps.slice(0, 5), (p) => ({\n            protocol: p.protocol,\n            route: routeToString(p.route),\n            percent: p.percent,\n            quote: p.quoteAdjustedForGas.toFixed(2),\n        }))),\n    }, 'Top 5 Quotes for each percentage');\n    const quoteCompFn = routeType == TradeType.EXACT_INPUT\n        ? (a, b) => a.greaterThan(b)\n        : (a, b) => a.lessThan(b);\n    const sumFn = (currencyAmounts) => {\n        let sum = currencyAmounts[0];\n        for (let i = 1; i < currencyAmounts.length; i++) {\n            sum = sum.add(currencyAmounts[i]);\n        }\n        return sum;\n    };\n    let bestQuote;\n    let bestSwap;\n    // Min-heap for tracking the 5 best swaps given some number of splits.\n    const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n        return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n    }, 5);\n    const { minSplits, maxSplits, forceCrossProtocol } = routingConfig;\n    if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n        log.info({\n            percentToSortedQuotes: _.mapValues(percentToSortedQuotes, (p) => p.length),\n        }, 'Did not find a valid route without any splits. Continuing search anyway.');\n    }\n    else {\n        bestQuote = by(percentToSortedQuotes[100][0]);\n        bestSwap = [percentToSortedQuotes[100][0]];\n        for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n            bestSwapsPerSplit.push({\n                quote: by(routeWithQuote),\n                routes: [routeWithQuote],\n            });\n        }\n    }\n    // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n    const queue = new Queue();\n    // First we seed BFS queue with the best quotes for each percentage.\n    // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n    // We will explore the various combinations from each node.\n    for (let i = percents.length; i >= 0; i--) {\n        const percent = percents[i];\n        if (!percentToSortedQuotes[percent]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][0]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: false,\n        });\n        if (!percentToSortedQuotes[percent] ||\n            !percentToSortedQuotes[percent][1]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][1]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: true,\n        });\n    }\n    let splits = 1;\n    let startedSplit = Date.now();\n    while (queue.size > 0) {\n        metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n        startedSplit = Date.now();\n        log.info({\n            top5: _.map(Array.from(bestSwapsPerSplit.consume()), (q) => `${q.quote.toExact()} (${_(q.routes)\n                .map((r) => r.toString())\n                .join(', ')})`),\n            onQueue: queue.size,\n        }, `Top 5 with ${splits} splits`);\n        bestSwapsPerSplit.clear();\n        // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n        let layer = queue.size;\n        splits++;\n        // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n        if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n            break;\n        }\n        if (splits > maxSplits) {\n            log.info('Max splits reached. Stopping search.');\n            metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n            break;\n        }\n        while (layer > 0) {\n            layer--;\n            const { remainingPercent, curRoutes, percentIndex, special } = queue.dequeue();\n            // For all other percentages, add a new potential route.\n            // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n            // 50% + new 10% route, 50% + new 20% route, etc.\n            for (let i = percentIndex; i >= 0; i--) {\n                const percentA = percents[i];\n                if (percentA > remainingPercent) {\n                    continue;\n                }\n                // At some point the amount * percentage is so small that the quoter is unable to get\n                // a quote. In this case there could be no quotes for that percentage.\n                if (!percentToSortedQuotes[percentA]) {\n                    continue;\n                }\n                const candidateRoutesA = percentToSortedQuotes[percentA];\n                // Find the best route in the complimentary percentage that doesn't re-use a pool already\n                // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n                // so it would make the quotes inaccurate.\n                const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n                if (!routeWithQuoteA) {\n                    continue;\n                }\n                const remainingPercentNew = remainingPercent - percentA;\n                const curRoutesNew = [...curRoutes, routeWithQuoteA];\n                // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n                if (remainingPercentNew == 0 && splits >= minSplits) {\n                    const quotesNew = _.map(curRoutesNew, (r) => by(r));\n                    const quoteNew = sumFn(quotesNew);\n                    bestSwapsPerSplit.push({\n                        quote: quoteNew,\n                        routes: curRoutesNew,\n                    });\n                    if (!bestQuote || quoteCompFn(quoteNew, bestQuote)) {\n                        bestQuote = quoteNew;\n                        bestSwap = curRoutesNew;\n                        // Temporary experiment.\n                        if (special) {\n                            metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n                        }\n                    }\n                }\n                else {\n                    queue.enqueue({\n                        curRoutes: curRoutesNew,\n                        remainingPercent: remainingPercentNew,\n                        percentIndex: i,\n                        special,\n                    });\n                }\n            }\n        }\n    }\n    if (!bestSwap) {\n        log.info(`Could not find a valid swap`);\n        return undefined;\n    }\n    const postSplitNow = Date.now();\n    const quoteGasAdjusted = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quoteAdjustedForGas));\n    const estimatedGasUsed = _(bestSwap)\n        .map((routeWithValidQuote) => routeWithValidQuote.gasEstimate)\n        .reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0));\n    // Each route can use a different stablecoin to account its gas costs.\n    // They should all be pegged, and this is just an estimate, so we do a merge\n    // to an arbitrary stable.\n    if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n        throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n    const usdToken = usdGasTokensByChain[chainId][0];\n    const usdTokenDecimals = usdToken.decimals;\n    // For each gas estimate, normalize decimals to that of the chosen usd token.\n    const estimatedGasUsedUSDs = _(bestSwap)\n        .map((routeWithValidQuote) => {\n        const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n        if (decimalsDiff == 0) {\n            return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n        }\n        return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n    })\n        .value();\n    const estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n    log.info({\n        estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n        normalizedUsdToken: usdToken,\n        routeUSDGasEstimates: _.map(bestSwap, (b) => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`),\n    }, 'USD gas estimates of best route');\n    const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.gasCostInToken));\n    const quote = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quote));\n    const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n    metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n    return {\n        quote,\n        quoteGasAdjusted,\n        estimatedGasUsed,\n        estimatedGasUsedUSD,\n        estimatedGasUsedQuoteToken,\n        routes: routeWithQuotes,\n    };\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n    const poolAddressSet = new Set();\n    const usedPoolAddresses = _(usedRoutes)\n        .flatMap((r) => r.poolAddresses)\n        .value();\n    for (let poolAddress of usedPoolAddresses) {\n        poolAddressSet.add(poolAddress);\n    }\n    const protocolsSet = new Set();\n    const usedProtocols = _(usedRoutes)\n        .flatMap((r) => r.protocol)\n        .uniq()\n        .value();\n    for (let protocol of usedProtocols) {\n        protocolsSet.add(protocol);\n    }\n    for (const routeQuote of candidateRouteQuotes) {\n        const { poolAddresses, protocol } = routeQuote;\n        if (poolAddresses.some((poolAddress) => poolAddressSet.has(poolAddress))) {\n            continue;\n        }\n        // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n        // consideration of routes that come from the same protocol as a used route.\n        const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n        if (needToForce && protocolsSet.has(protocol)) {\n            continue;\n        }\n        return routeQuote;\n    }\n    return null;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVzdC1zd2FwLXJvdXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3JvdXRlcnMvYWxwaGEtcm91dGVyL2Z1bmN0aW9ucy9iZXN0LXN3YXAtcm91dGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDbkMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXBELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDeEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUUzRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHcEQsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixNQUFzQixFQUN0QixRQUFrQixFQUNsQixxQkFBNEMsRUFDNUMsU0FBb0IsRUFDcEIsT0FBZ0IsRUFDaEIsYUFBZ0M7SUFTaEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRXZCLGtFQUFrRTtJQUNsRSxvR0FBb0c7SUFDcEcsTUFBTSxlQUFlLEdBQWlELEVBQUUsQ0FBQztJQUN6RSxLQUFLLE1BQU0sbUJBQW1CLElBQUkscUJBQXFCLEVBQUU7UUFDdkQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNqRCxlQUFlLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ25EO1FBQ0QsZUFBZSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0tBQ3pFO0lBRUQsTUFBTSxDQUFDLFNBQVMsQ0FDZCxpQ0FBaUMsRUFDakMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsRUFDaEIsZ0JBQWdCLENBQUMsWUFBWSxDQUM5QixDQUFDO0lBRUYseUVBQXlFO0lBQ3pFLE1BQU0sU0FBUyxHQUFHLGtCQUFrQixDQUNsQyxTQUFTLEVBQ1QsZUFBZSxFQUNmLFFBQVEsRUFDUixPQUFPLEVBQ1AsQ0FBQyxFQUF1QixFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLEVBQ25ELGFBQWEsQ0FDZCxDQUFDO0lBRUYsMEVBQTBFO0lBQzFFLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDZCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsNkhBQTZIO0lBQzdILDRFQUE0RTtJQUM1RSxFQUFFO0lBQ0YsaURBQWlEO0lBQ2pELHFJQUFxSTtJQUNySSxNQUFNLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxHQUFHLFNBQVMsQ0FBQztJQUMzQyxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUMxQixZQUFZLEVBQ1osQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFDckQsY0FBYyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FDbEUsQ0FBQztJQUVGLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbkQsSUFBSSxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2hDLEdBQUcsQ0FBQyxJQUFJLENBQ047WUFDRSxhQUFhLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUU7U0FDakQsRUFDRCw2R0FBNkcsQ0FDOUcsQ0FBQztRQUVGLFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBRSxDQUFDLE1BQU07WUFDM0MsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUNwRTtJQUVELEdBQUcsQ0FBQyxJQUFJLENBQ047UUFDRSxNQUFNLEVBQUUsb0JBQW9CLENBQUMsWUFBWSxDQUFDO1FBQzFDLFNBQVMsRUFBRSxZQUFZLENBQUMsTUFBTTtRQUM5QixNQUFNLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRTtRQUN4QixLQUFLLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDaEMsZ0JBQWdCLEVBQUUsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDdkQsZUFBZSxFQUFFLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ3pELGlCQUFpQixFQUFFLFNBQVMsQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ25FLEVBQ0QsMEJBQTBCLFlBQVksQ0FBQyxNQUFNLFNBQVMsQ0FDdkQsQ0FBQztJQUVGLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLFNBQW9CLEVBQ3BCLGVBQTZELEVBQzdELFFBQWtCLEVBQ2xCLE9BQWdCLEVBQ2hCLEVBQXVELEVBQ3ZELGFBQWdDO0lBV2hDLHNHQUFzRztJQUN0RyxNQUFNLHFCQUFxQixHQUFHLENBQUMsQ0FBQyxTQUFTLENBQ3ZDLGVBQWUsRUFDZixDQUFDLFdBQWtDLEVBQUUsRUFBRTtRQUNyQyxPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUU7WUFDbkQsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLFdBQVcsRUFBRTtnQkFDdEMsT0FBTyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzlEO2lCQUFNO2dCQUNMLE9BQU8sRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMzRDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUNGLENBQUM7SUFFRixHQUFHLENBQUMsSUFBSSxDQUNOO1FBQ0UseUJBQXlCLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQ25FLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDNUIsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRO1lBQ3BCLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUM3QixPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU87WUFDbEIsS0FBSyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3hDLENBQUMsQ0FBQyxDQUNKO0tBQ0YsRUFDRCxrQ0FBa0MsQ0FDbkMsQ0FBQztJQUVGLE1BQU0sV0FBVyxHQUNmLFNBQVMsSUFBSSxTQUFTLENBQUMsV0FBVztRQUNoQyxDQUFDLENBQUMsQ0FBQyxDQUFpQixFQUFFLENBQWlCLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQzVELENBQUMsQ0FBQyxDQUFDLENBQWlCLEVBQUUsQ0FBaUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5RCxNQUFNLEtBQUssR0FBRyxDQUFDLGVBQWlDLEVBQWtCLEVBQUU7UUFDbEUsSUFBSSxHQUFHLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBRSxDQUFDO1FBQzlCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9DLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDLENBQUM7SUFFRixJQUFJLFNBQXFDLENBQUM7SUFDMUMsSUFBSSxRQUEyQyxDQUFDO0lBRWhELHNFQUFzRTtJQUN0RSxNQUFNLGlCQUFpQixHQUFHLElBQUksZ0JBQWdCLENBSTVDLEtBQUssRUFDTCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNQLE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUMsRUFDRCxDQUFDLENBQ0YsQ0FBQztJQUVGLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFDO0lBRW5FLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLGtCQUFrQixFQUFFO1FBQ3RFLEdBQUcsQ0FBQyxJQUFJLENBQ047WUFDRSxxQkFBcUIsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUNoQyxxQkFBcUIsRUFDckIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQ2hCO1NBQ0YsRUFDRCwwRUFBMEUsQ0FDM0UsQ0FBQztLQUNIO1NBQU07UUFDTCxTQUFTLEdBQUcsRUFBRSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFDLENBQUM7UUFDL0MsUUFBUSxHQUFHLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUMsQ0FBQztRQUU1QyxLQUFLLE1BQU0sY0FBYyxJQUFJLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7WUFDbkUsaUJBQWlCLENBQUMsSUFBSSxDQUFDO2dCQUNyQixLQUFLLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FBQztnQkFDekIsTUFBTSxFQUFFLENBQUMsY0FBYyxDQUFDO2FBQ3pCLENBQUMsQ0FBQztTQUNKO0tBQ0Y7SUFFRCxxR0FBcUc7SUFDckcsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBS25CLENBQUM7SUFFTCxvRUFBb0U7SUFDcEUsMkZBQTJGO0lBQzNGLDJEQUEyRDtJQUMzRCxLQUFLLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN6QyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFFLENBQUM7UUFFN0IsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ25DLFNBQVM7U0FDVjtRQUVELEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDWixTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUUsQ0FBQyxDQUFDLENBQUUsQ0FBQztZQUNoRCxZQUFZLEVBQUUsQ0FBQztZQUNmLGdCQUFnQixFQUFFLEdBQUcsR0FBRyxPQUFPO1lBQy9CLE9BQU8sRUFBRSxLQUFLO1NBQ2YsQ0FBQyxDQUFDO1FBRUgsSUFDRSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQztZQUMvQixDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBRSxDQUFDLENBQUMsQ0FBQyxFQUNuQztZQUNBLFNBQVM7U0FDVjtRQUVELEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDWixTQUFTLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUUsQ0FBQyxDQUFDLENBQUUsQ0FBQztZQUNoRCxZQUFZLEVBQUUsQ0FBQztZQUNmLGdCQUFnQixFQUFFLEdBQUcsR0FBRyxPQUFPO1lBQy9CLE9BQU8sRUFBRSxJQUFJO1NBQ2QsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDZixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFOUIsT0FBTyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtRQUNyQixNQUFNLENBQUMsU0FBUyxDQUNkLFFBQVEsTUFBTSxNQUFNLEVBQ3BCLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxZQUFZLEVBQ3pCLGdCQUFnQixDQUFDLFlBQVksQ0FDOUIsQ0FBQztRQUVGLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFMUIsR0FBRyxDQUFDLElBQUksQ0FDTjtZQUNFLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUNULEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLENBQUMsRUFDdkMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztpQkFDakMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNuQjtZQUNELE9BQU8sRUFBRSxLQUFLLENBQUMsSUFBSTtTQUNwQixFQUNELGNBQWMsTUFBTSxTQUFTLENBQzlCLENBQUM7UUFFRixpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUUxQix5SEFBeUg7UUFDekgsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztRQUN2QixNQUFNLEVBQUUsQ0FBQztRQUVULG9IQUFvSDtRQUNwSCxJQUFJLE1BQU0sSUFBSSxDQUFDLElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMzRCxNQUFNO1NBQ1A7UUFFRCxJQUFJLE1BQU0sR0FBRyxTQUFTLEVBQUU7WUFDdEIsR0FBRyxDQUFDLElBQUksQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxTQUFTLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25FLE1BQU07U0FDUDtRQUVELE9BQU8sS0FBSyxHQUFHLENBQUMsRUFBRTtZQUNoQixLQUFLLEVBQUUsQ0FBQztZQUVSLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxHQUMxRCxLQUFLLENBQUMsT0FBTyxFQUFHLENBQUM7WUFFbkIsd0RBQXdEO1lBQ3hELDBHQUEwRztZQUMxRyxpREFBaUQ7WUFDakQsS0FBSyxJQUFJLENBQUMsR0FBRyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBRSxDQUFDO2dCQUU5QixJQUFJLFFBQVEsR0FBRyxnQkFBZ0IsRUFBRTtvQkFDL0IsU0FBUztpQkFDVjtnQkFFRCxxRkFBcUY7Z0JBQ3JGLHNFQUFzRTtnQkFDdEUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxFQUFFO29CQUNwQyxTQUFTO2lCQUNWO2dCQUVELE1BQU0sZ0JBQWdCLEdBQUcscUJBQXFCLENBQUMsUUFBUSxDQUFFLENBQUM7Z0JBRTFELHlGQUF5RjtnQkFDekYsOEdBQThHO2dCQUM5RywwQ0FBMEM7Z0JBQzFDLE1BQU0sZUFBZSxHQUFHLCtCQUErQixDQUNyRCxTQUFTLEVBQ1QsZ0JBQWdCLEVBQ2hCLGtCQUFrQixDQUNuQixDQUFDO2dCQUVGLElBQUksQ0FBQyxlQUFlLEVBQUU7b0JBQ3BCLFNBQVM7aUJBQ1Y7Z0JBRUQsTUFBTSxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxRQUFRLENBQUM7Z0JBQ3hELE1BQU0sWUFBWSxHQUFHLENBQUMsR0FBRyxTQUFTLEVBQUUsZUFBZSxDQUFDLENBQUM7Z0JBRXJELCtHQUErRztnQkFDL0csSUFBSSxtQkFBbUIsSUFBSSxDQUFDLElBQUksTUFBTSxJQUFJLFNBQVMsRUFBRTtvQkFDbkQsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNwRCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBRWxDLGlCQUFpQixDQUFDLElBQUksQ0FBQzt3QkFDckIsS0FBSyxFQUFFLFFBQVE7d0JBQ2YsTUFBTSxFQUFFLFlBQVk7cUJBQ3JCLENBQUMsQ0FBQztvQkFFSCxJQUFJLENBQUMsU0FBUyxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEVBQUU7d0JBQ2xELFNBQVMsR0FBRyxRQUFRLENBQUM7d0JBQ3JCLFFBQVEsR0FBRyxZQUFZLENBQUM7d0JBRXhCLHdCQUF3Qjt3QkFDeEIsSUFBSSxPQUFPLEVBQUU7NEJBQ1gsTUFBTSxDQUFDLFNBQVMsQ0FDZCxrQ0FBa0MsRUFDbEMsQ0FBQyxFQUNELGdCQUFnQixDQUFDLEtBQUssQ0FDdkIsQ0FBQzt5QkFDSDtxQkFDRjtpQkFDRjtxQkFBTTtvQkFDTCxLQUFLLENBQUMsT0FBTyxDQUFDO3dCQUNaLFNBQVMsRUFBRSxZQUFZO3dCQUN2QixnQkFBZ0IsRUFBRSxtQkFBbUI7d0JBQ3JDLFlBQVksRUFBRSxDQUFDO3dCQUNmLE9BQU87cUJBQ1IsQ0FBQyxDQUFDO2lCQUNKO2FBQ0Y7U0FDRjtLQUNGO0lBRUQsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNiLEdBQUcsQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUN4QyxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUVELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUVoQyxNQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FDNUIsQ0FBQyxDQUFDLEdBQUcsQ0FDSCxRQUFRLEVBQ1IsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsbUJBQW1CLENBQ2pFLENBQ0YsQ0FBQztJQUVGLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztTQUNqQyxHQUFHLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsV0FBVyxDQUFDO1NBQzdELE1BQU0sQ0FDTCxDQUFDLEdBQUcsRUFBRSxtQkFBbUIsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxFQUMxRCxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNsQixDQUFDO0lBRUosc0VBQXNFO0lBQ3RFLDRFQUE0RTtJQUM1RSwwQkFBMEI7SUFDMUIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDdEUsTUFBTSxJQUFJLEtBQUssQ0FDYix5REFBeUQsT0FBTyxFQUFFLENBQ25FLENBQUM7S0FDSDtJQUNELE1BQU0sUUFBUSxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBRSxDQUFDLENBQUMsQ0FBRSxDQUFDO0lBQ25ELE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztJQUUzQyw2RUFBNkU7SUFDN0UsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO1NBQ3JDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLEVBQUU7UUFDM0IsTUFBTSxZQUFZLEdBQ2hCLGdCQUFnQixHQUFHLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBRXhFLElBQUksWUFBWSxJQUFJLENBQUMsRUFBRTtZQUNyQixPQUFPLGNBQWMsQ0FBQyxhQUFhLENBQ2pDLFFBQVEsRUFDUixtQkFBbUIsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUMxQyxDQUFDO1NBQ0g7UUFFRCxPQUFPLGNBQWMsQ0FBQyxhQUFhLENBQ2pDLFFBQVEsRUFDUixJQUFJLENBQUMsUUFBUSxDQUNYLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQ3pDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQzlELENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQztTQUNELEtBQUssRUFBRSxDQUFDO0lBRVgsTUFBTSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUN4RCxHQUFHLENBQUMsSUFBSSxDQUNOO1FBQ0UsbUJBQW1CLEVBQUUsbUJBQW1CLENBQUMsT0FBTyxFQUFFO1FBQ2xELGtCQUFrQixFQUFFLFFBQVE7UUFDNUIsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDekIsUUFBUSxFQUNSLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDSixHQUFHLENBQUMsQ0FBQyxPQUFPLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQ3hFO0tBQ0YsRUFDRCxpQ0FBaUMsQ0FDbEMsQ0FBQztJQUVGLE1BQU0sMEJBQTBCLEdBQUcsS0FBSyxDQUN0QyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLG1CQUFtQixFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLENBQUMsQ0FDN0UsQ0FBQztJQUVGLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FDakIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQ3BFLENBQUM7SUFFRixNQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxFQUFFLENBQ25FLFlBQVksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDOUQsQ0FBQztJQUVGLE1BQU0sQ0FBQyxTQUFTLENBQ2QsZUFBZSxFQUNmLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxZQUFZLEVBQ3pCLGdCQUFnQixDQUFDLFlBQVksQ0FDOUIsQ0FBQztJQUVGLE9BQU87UUFDTCxLQUFLO1FBQ0wsZ0JBQWdCO1FBQ2hCLGdCQUFnQjtRQUNoQixtQkFBbUI7UUFDbkIsMEJBQTBCO1FBQzFCLE1BQU0sRUFBRSxlQUFlO0tBQ3hCLENBQUM7QUFDSixDQUFDO0FBRUQsK0dBQStHO0FBQy9HLDhJQUE4STtBQUM5SSxNQUFNLCtCQUErQixHQUFHLENBQ3RDLFVBQWlDLEVBQ2pDLG9CQUEyQyxFQUMzQyxrQkFBMkIsRUFDQyxFQUFFO0lBQzlCLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFDakMsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDO1NBQ3BDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztTQUMvQixLQUFLLEVBQUUsQ0FBQztJQUVYLEtBQUssSUFBSSxXQUFXLElBQUksaUJBQWlCLEVBQUU7UUFDekMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUNqQztJQUVELE1BQU0sWUFBWSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFDL0IsTUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQztTQUNoQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7U0FDMUIsSUFBSSxFQUFFO1NBQ04sS0FBSyxFQUFFLENBQUM7SUFFWCxLQUFLLElBQUksUUFBUSxJQUFJLGFBQWEsRUFBRTtRQUNsQyxZQUFZLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsS0FBSyxNQUFNLFVBQVUsSUFBSSxvQkFBb0IsRUFBRTtRQUM3QyxNQUFNLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxHQUFHLFVBQVUsQ0FBQztRQUUvQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRTtZQUN4RSxTQUFTO1NBQ1Y7UUFFRCwrRkFBK0Y7UUFDL0YsNEVBQTRFO1FBQzVFLE1BQU0sV0FBVyxHQUFHLGtCQUFrQixJQUFJLFlBQVksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ2pFLElBQUksV0FBVyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDN0MsU0FBUztTQUNWO1FBRUQsT0FBTyxVQUFVLENBQUM7S0FDbkI7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQyJ9"]},"metadata":{},"sourceType":"module"}