{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { log } from '../../../../util/log';\nimport { IV3GasModelFactory, usdGasTokensByChain } from '../gas-model'; // Constant cost for doing any swap regardless of pools.\n\nconst BASE_SWAP_COST = BigNumber.from(2000); // Cost for crossing an initialized tick.\n\nconst COST_PER_INIT_TICK = BigNumber.from(31000); // Cost for crossing an uninitialized tick.\n\nconst COST_PER_UNINIT_TICK = BigNumber.from(0); // Constant per pool swap in the route.\n\nconst COST_PER_HOP = BigNumber.from(80000);\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\n\nexport class V3HeuristicGasModelFactory extends IV3GasModelFactory {\n  constructor() {\n    super();\n  }\n\n  async buildGasModel(chainId, gasPriceWei, poolProvider, token // this is the quoteToken\n  ) {\n    // If our quote token is WETH, we don't need to convert our gas use to be in terms\n    // of the quote token in order to produce a gas adjusted amount.\n    // We do return a gas use in USD however, so we still convert to usd.\n    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n\n    if (token.equals(nativeCurrency)) {\n      const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n\n      const estimateGasCost = routeWithValidQuote => {\n        const {\n          gasCostNativeCurrency,\n          gasUse\n        } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n        const token0 = usdPool.token0.address == nativeCurrency.address;\n        const nativeTokenPrice = token0 ? usdPool.token0Price : usdPool.token1Price;\n        const gasCostInTermsOfUSD = nativeTokenPrice.quote(gasCostNativeCurrency);\n        return {\n          gasEstimate: gasUse,\n          gasCostInToken: gasCostNativeCurrency,\n          gasCostInUSD: gasCostInTermsOfUSD\n        };\n      };\n\n      return {\n        estimateGasCost\n      };\n    } // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n    // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n\n\n    const nativePool = await this.getHighestLiquidityNativePool(chainId, token, poolProvider);\n    const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n    const usdToken = usdPool.token0.address == nativeCurrency.address ? usdPool.token1 : usdPool.token0;\n\n    const estimateGasCost = routeWithValidQuote => {\n      const {\n        gasCostNativeCurrency,\n        gasUse\n      } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n\n      if (!nativePool) {\n        log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n        return {\n          gasEstimate: gasUse,\n          gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n          gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n        };\n      }\n\n      const token0 = nativePool.token0.address == nativeCurrency.address; // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n\n      const nativeTokenPrice = token0 ? nativePool.token0Price : nativePool.token1Price;\n      let gasCostInTermsOfQuoteToken;\n\n      try {\n        // native token is base currency\n        gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(gasCostNativeCurrency);\n      } catch (err) {\n        log.info({\n          nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n          nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n          gasCostInEth: gasCostNativeCurrency.currency\n        }, 'Debug eth price token issue');\n        throw err;\n      } // true if token0 is the native currency\n\n\n      const token0USDPool = usdPool.token0.address == nativeCurrency.address; // gets the mid price of the pool in terms of the native token\n\n      const nativeTokenPriceUSDPool = token0USDPool ? usdPool.token0Price : usdPool.token1Price;\n      let gasCostInTermsOfUSD;\n\n      try {\n        gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(gasCostNativeCurrency);\n      } catch (err) {\n        log.info({\n          usdT1: usdPool.token0.symbol,\n          usdT2: usdPool.token1.symbol,\n          gasCostInNativeToken: gasCostNativeCurrency.currency.symbol\n        }, 'Failed to compute USD gas price');\n        throw err;\n      }\n\n      return {\n        gasEstimate: gasUse,\n        gasCostInToken: gasCostInTermsOfQuoteToken,\n        gasCostInUSD: gasCostInTermsOfUSD\n      };\n    };\n\n    return {\n      estimateGasCost: estimateGasCost.bind(this)\n    };\n  }\n\n  estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n    const totalInitializedTicksCrossed = Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList));\n    const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n    const hopsGasUse = COST_PER_HOP.mul(totalHops);\n    const tickGasUse = COST_PER_INIT_TICK.mul(totalInitializedTicksCrossed);\n    const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n    const gasUse = BASE_SWAP_COST.add(hopsGasUse).add(tickGasUse).add(uninitializedTickGasUse);\n    const totalGasCostWei = gasPriceWei.mul(gasUse);\n    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n    const gasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, totalGasCostWei.toString());\n    return {\n      gasCostNativeCurrency,\n      gasUse\n    };\n  }\n\n  async getHighestLiquidityNativePool(chainId, token, poolProvider) {\n    const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n\n    const nativePools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW]).map(feeAmount => {\n      return [nativeCurrency, token, feeAmount];\n    }).value();\n\n    const poolAccessor = await poolProvider.getPools(nativePools);\n\n    const pools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW]).map(feeAmount => {\n      return poolAccessor.getPool(nativeCurrency, token, feeAmount);\n    }).compact().value();\n\n    if (pools.length == 0) {\n      log.error({\n        pools\n      }, `Could not find a ${nativeCurrency.symbol} pool with ${token.symbol} for computing gas costs.`);\n      return null;\n    }\n\n    const maxPool = _.maxBy(pools, pool => pool.liquidity);\n\n    return maxPool;\n  }\n\n  async getHighestLiquidityUSDPool(chainId, poolProvider) {\n    const usdTokens = usdGasTokensByChain[chainId];\n    const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n\n    if (!usdTokens) {\n      throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n\n    const usdPools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST]).flatMap(feeAmount => {\n      return _.map(usdTokens, usdToken => [wrappedCurrency, usdToken, feeAmount]);\n    }).value();\n\n    const poolAccessor = await poolProvider.getPools(usdPools);\n\n    const pools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW, FeeAmount.LOWEST]).flatMap(feeAmount => {\n      const pools = [];\n\n      for (const usdToken of usdTokens) {\n        const pool = poolAccessor.getPool(wrappedCurrency, usdToken, feeAmount);\n\n        if (pool) {\n          pools.push(pool);\n        }\n      }\n\n      return pools;\n    }).compact().value();\n\n    if (pools.length == 0) {\n      log.error({\n        pools\n      }, `Could not find a USD/${wrappedCurrency.symbol} pool for computing gas costs.`);\n      throw new Error(`Can't find USD/${wrappedCurrency.symbol} pool for computing gas costs.`);\n    }\n\n    const maxPool = _.maxBy(pools, pool => pool.liquidity);\n\n    return maxPool;\n  }\n\n}","map":{"version":3,"sources":["../../../../../../../src/routers/alpha-router/gas-models/v3/v3-heuristic-gas-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport { FeeAmount } from '@uniswap/v3-sdk';\nimport _ from 'lodash';\nimport { WRAPPED_NATIVE_CURRENCY } from '../../../..';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { log } from '../../../../util/log';\nimport { IV3GasModelFactory, usdGasTokensByChain, } from '../gas-model';\n// Constant cost for doing any swap regardless of pools.\nconst BASE_SWAP_COST = BigNumber.from(2000);\n// Cost for crossing an initialized tick.\nconst COST_PER_INIT_TICK = BigNumber.from(31000);\n// Cost for crossing an uninitialized tick.\nconst COST_PER_UNINIT_TICK = BigNumber.from(0);\n// Constant per pool swap in the route.\nconst COST_PER_HOP = BigNumber.from(80000);\n/**\n * Computes a gas estimate for a V3 swap using heuristics.\n * Considers number of hops in the route, number of ticks crossed\n * and the typical base cost for a swap.\n *\n * We get the number of ticks crossed in a swap from the QuoterV2\n * contract.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * @export\n * @class V3HeuristicGasModelFactory\n */\nexport class V3HeuristicGasModelFactory extends IV3GasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel(chainId, gasPriceWei, poolProvider, token\n    // this is the quoteToken\n    ) {\n        // If our quote token is WETH, we don't need to convert our gas use to be in terms\n        // of the quote token in order to produce a gas adjusted amount.\n        // We do return a gas use in USD however, so we still convert to usd.\n        const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        if (token.equals(nativeCurrency)) {\n            const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n            const estimateGasCost = (routeWithValidQuote) => {\n                const { gasCostNativeCurrency, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                const token0 = usdPool.token0.address == nativeCurrency.address;\n                const nativeTokenPrice = token0\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                const gasCostInTermsOfUSD = nativeTokenPrice.quote(gasCostNativeCurrency);\n                return {\n                    gasEstimate: gasUse,\n                    gasCostInToken: gasCostNativeCurrency,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            };\n            return {\n                estimateGasCost,\n            };\n        }\n        // If the quote token is not in the native currency, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <quoteToken>/<nativeCurrency> pool. eg. <quoteToken>/ETH pool.\n        const nativePool = await this.getHighestLiquidityNativePool(chainId, token, poolProvider);\n        const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n        const usdToken = usdPool.token0.address == nativeCurrency.address\n            ? usdPool.token1\n            : usdPool.token0;\n        const estimateGasCost = (routeWithValidQuote) => {\n            const { gasCostNativeCurrency, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n            if (!nativePool) {\n                log.info(`Unable to find ${nativeCurrency.symbol} pool with the quote token, ${token.symbol} to produce gas adjusted costs. Route will not account for gas.`);\n                return {\n                    gasEstimate: gasUse,\n                    gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                    gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                };\n            }\n            const token0 = nativePool.token0.address == nativeCurrency.address;\n            // returns mid price in terms of the native currency (the ratio of quoteToken/nativeToken)\n            const nativeTokenPrice = token0\n                ? nativePool.token0Price\n                : nativePool.token1Price;\n            let gasCostInTermsOfQuoteToken;\n            try {\n                // native token is base currency\n                gasCostInTermsOfQuoteToken = nativeTokenPrice.quote(gasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    nativeTokenPriceBase: nativeTokenPrice.baseCurrency,\n                    nativeTokenPriceQuote: nativeTokenPrice.quoteCurrency,\n                    gasCostInEth: gasCostNativeCurrency.currency,\n                }, 'Debug eth price token issue');\n                throw err;\n            }\n            // true if token0 is the native currency\n            const token0USDPool = usdPool.token0.address == nativeCurrency.address;\n            // gets the mid price of the pool in terms of the native token\n            const nativeTokenPriceUSDPool = token0USDPool\n                ? usdPool.token0Price\n                : usdPool.token1Price;\n            let gasCostInTermsOfUSD;\n            try {\n                gasCostInTermsOfUSD = nativeTokenPriceUSDPool.quote(gasCostNativeCurrency);\n            }\n            catch (err) {\n                log.info({\n                    usdT1: usdPool.token0.symbol,\n                    usdT2: usdPool.token1.symbol,\n                    gasCostInNativeToken: gasCostNativeCurrency.currency.symbol,\n                }, 'Failed to compute USD gas price');\n                throw err;\n            }\n            return {\n                gasEstimate: gasUse,\n                gasCostInToken: gasCostInTermsOfQuoteToken,\n                gasCostInUSD: gasCostInTermsOfUSD,\n            };\n        };\n        return {\n            estimateGasCost: estimateGasCost.bind(this),\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const totalInitializedTicksCrossed = Math.max(1, _.sum(routeWithValidQuote.initializedTicksCrossedList));\n        const totalHops = BigNumber.from(routeWithValidQuote.route.pools.length);\n        const hopsGasUse = COST_PER_HOP.mul(totalHops);\n        const tickGasUse = COST_PER_INIT_TICK.mul(totalInitializedTicksCrossed);\n        const uninitializedTickGasUse = COST_PER_UNINIT_TICK.mul(0);\n        const gasUse = BASE_SWAP_COST.add(hopsGasUse)\n            .add(tickGasUse)\n            .add(uninitializedTickGasUse);\n        const totalGasCostWei = gasPriceWei.mul(gasUse);\n        const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        const gasCostNativeCurrency = CurrencyAmount.fromRawAmount(wrappedCurrency, totalGasCostWei.toString());\n        return { gasCostNativeCurrency, gasUse };\n    }\n    async getHighestLiquidityNativePool(chainId, token, poolProvider) {\n        const nativeCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        const nativePools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW])\n            .map((feeAmount) => {\n            return [nativeCurrency, token, feeAmount];\n        })\n            .value();\n        const poolAccessor = await poolProvider.getPools(nativePools);\n        const pools = _([FeeAmount.HIGH, FeeAmount.MEDIUM, FeeAmount.LOW])\n            .map((feeAmount) => {\n            return poolAccessor.getPool(nativeCurrency, token, feeAmount);\n        })\n            .compact()\n            .value();\n        if (pools.length == 0) {\n            log.error({ pools }, `Could not find a ${nativeCurrency.symbol} pool with ${token.symbol} for computing gas costs.`);\n            return null;\n        }\n        const maxPool = _.maxBy(pools, (pool) => pool.liquidity);\n        return maxPool;\n    }\n    async getHighestLiquidityUSDPool(chainId, poolProvider) {\n        const usdTokens = usdGasTokensByChain[chainId];\n        const wrappedCurrency = WRAPPED_NATIVE_CURRENCY[chainId];\n        if (!usdTokens) {\n            throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n        }\n        const usdPools = _([\n            FeeAmount.HIGH,\n            FeeAmount.MEDIUM,\n            FeeAmount.LOW,\n            FeeAmount.LOWEST,\n        ])\n            .flatMap((feeAmount) => {\n            return _.map(usdTokens, (usdToken) => [wrappedCurrency, usdToken, feeAmount]);\n        })\n            .value();\n        const poolAccessor = await poolProvider.getPools(usdPools);\n        const pools = _([\n            FeeAmount.HIGH,\n            FeeAmount.MEDIUM,\n            FeeAmount.LOW,\n            FeeAmount.LOWEST,\n        ])\n            .flatMap((feeAmount) => {\n            const pools = [];\n            for (const usdToken of usdTokens) {\n                const pool = poolAccessor.getPool(wrappedCurrency, usdToken, feeAmount);\n                if (pool) {\n                    pools.push(pool);\n                }\n            }\n            return pools;\n        })\n            .compact()\n            .value();\n        if (pools.length == 0) {\n            log.error({ pools }, `Could not find a USD/${wrappedCurrency.symbol} pool for computing gas costs.`);\n            throw new Error(`Can't find USD/${wrappedCurrency.symbol} pool for computing gas costs.`);\n        }\n        const maxPool = _.maxBy(pools, (pool) => pool.liquidity);\n        return maxPool;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjMtaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YzL3YzLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXJELE9BQU8sRUFBRSxTQUFTLEVBQVEsTUFBTSxpQkFBaUIsQ0FBQztBQUNsRCxPQUFPLENBQUMsTUFBTSxRQUFRLENBQUM7QUFDdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBR3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFM0MsT0FBTyxFQUVMLGtCQUFrQixFQUNsQixtQkFBbUIsR0FDcEIsTUFBTSxjQUFjLENBQUM7QUFFdEIsd0RBQXdEO0FBQ3hELE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFNUMseUNBQXlDO0FBQ3pDLE1BQU0sa0JBQWtCLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUVqRCwyQ0FBMkM7QUFDM0MsTUFBTSxvQkFBb0IsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRS9DLHVDQUF1QztBQUN2QyxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBRTNDOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUNILE1BQU0sT0FBTywwQkFBMkIsU0FBUSxrQkFBa0I7SUFDaEU7UUFDRSxLQUFLLEVBQUUsQ0FBQztJQUNWLENBQUM7SUFFTSxLQUFLLENBQUMsYUFBYSxDQUN4QixPQUFnQixF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"]},"metadata":{},"sourceType":"module"}