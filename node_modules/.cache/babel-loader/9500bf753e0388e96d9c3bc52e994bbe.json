{"ast":null,"code":"/**\n * Mnemonist BitVector\n * ====================\n *\n * JavaScript implementation of a dynamic BitSet based upon a Uint32Array.\n *\n * Notes:\n *   - (i >> 5) is the same as ((i / 32) | 0)\n *   - (i & 0x0000001f) is the same as (i % 32)\n *   - I could use a Float64Array to store more in less blocks but I would lose\n *     the benefits of byte comparison to keep track of size without popcounts.\n */\nvar Iterator = require('obliterator/iterator'),\n    bitwise = require('./utils/bitwise.js');\n/**\n * Constants.\n */\n\n\nvar DEFAULT_GROWING_POLICY = function DEFAULT_GROWING_POLICY(capacity) {\n  return Math.max(1, Math.ceil(capacity * 1.5));\n};\n/**\n * Helpers.\n */\n\n\nfunction createByteArray(capacity) {\n  return new Uint32Array(Math.ceil(capacity / 32));\n}\n/**\n * BitVector.\n *\n * @constructor\n */\n\n\nfunction BitVector(initialLengthOrOptions) {\n  var initialLength = initialLengthOrOptions || 0,\n      policy = DEFAULT_GROWING_POLICY;\n\n  if (typeof initialLengthOrOptions === 'object') {\n    initialLength = initialLengthOrOptions.initialLength || initialLengthOrOptions.initialCapacity || 0;\n    policy = initialLengthOrOptions.policy || policy;\n  }\n\n  this.size = 0;\n  this.length = initialLength;\n  this.capacity = Math.ceil(this.length / 32) * 32;\n  this.policy = policy;\n  this.array = createByteArray(this.capacity);\n}\n/**\n * Method used to set the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @param  {number|boolean} value - Value to set.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.set = function (index, value) {\n  // Out of bounds?\n  if (this.length < index) throw new Error('BitVector.set: index out of bounds.');\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n  if (value === 0 || value === false) newBytes = this.array[byteIndex] &= ~(1 << pos);else newBytes = this.array[byteIndex] |= 1 << pos; // Get unsigned representation.\n\n  newBytes = newBytes >>> 0; // Updating size\n\n  if (newBytes > oldBytes) this.size++;else if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n* Method used to reset the given bit's value.\n*\n* @param  {number} index - Target bit index.\n* @return {BitVector}\n*/\n\n\nBitVector.prototype.reset = function (index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n  newBytes = this.array[byteIndex] &= ~(1 << pos); // Updating size\n\n  if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n * Method used to flip the value of the given bit.\n *\n * @param  {number} index - Target bit index.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.flip = function (index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex];\n  var newBytes = this.array[byteIndex] ^= 1 << pos; // Get unsigned representation.\n\n  newBytes = newBytes >>> 0; // Updating size\n\n  if (newBytes > oldBytes) this.size++;else if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n * Method used to apply the growing policy.\n *\n * @param  {number} [override] - Override capacity.\n * @return {number}\n */\n\n\nBitVector.prototype.applyPolicy = function (override) {\n  var newCapacity = this.policy(override || this.capacity);\n  if (typeof newCapacity !== 'number' || newCapacity < 0) throw new Error('mnemonist/bit-vector.applyPolicy: policy returned an invalid value (expecting a positive integer).');\n  if (newCapacity <= this.capacity) throw new Error('mnemonist/bit-vector.applyPolicy: policy returned a less or equal capacity to allocate.'); // TODO: we should probably check that the returned number is an integer\n  // Ceil to nearest 32\n\n  return Math.ceil(newCapacity / 32) * 32;\n};\n/**\n * Method used to reallocate the underlying array.\n *\n * @param  {number}       capacity - Target capacity.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.reallocate = function (capacity) {\n  var virtualCapacity = capacity;\n  capacity = Math.ceil(capacity / 32) * 32;\n  if (virtualCapacity < this.length) this.length = virtualCapacity;\n  if (capacity === this.capacity) return this;\n  var oldArray = this.array;\n  var storageLength = capacity / 32;\n  if (storageLength === this.array.length) return this;\n\n  if (storageLength > this.array.length) {\n    this.array = new Uint32Array(storageLength);\n    this.array.set(oldArray, 0);\n  } else {\n    this.array = oldArray.slice(0, storageLength);\n  }\n\n  this.capacity = capacity;\n  return this;\n};\n/**\n * Method used to grow the array.\n *\n * @param  {number}       [capacity] - Optional capacity to match.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.grow = function (capacity) {\n  var newCapacity;\n\n  if (typeof capacity === 'number') {\n    if (this.capacity >= capacity) return this; // We need to match the given capacity\n\n    newCapacity = this.capacity;\n\n    while (newCapacity < capacity) {\n      newCapacity = this.applyPolicy(newCapacity);\n    }\n\n    this.reallocate(newCapacity);\n    return this;\n  } // We need to run the policy once\n\n\n  newCapacity = this.applyPolicy();\n  this.reallocate(newCapacity);\n  return this;\n};\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.resize = function (length) {\n  if (length === this.length) return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.reallocate(length);\n  return this;\n};\n/**\n * Method used to push a value in the set.\n *\n * @param  {number|boolean} value\n * @return {BitVector}\n */\n\n\nBitVector.prototype.push = function (value) {\n  if (this.capacity === this.length) this.grow();\n  if (value === 0 || value === false) return ++this.length;\n  this.size++;\n  var index = this.length++,\n      byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n  this.array[byteIndex] |= 1 << pos;\n  return this.length;\n};\n/**\n * Method used to pop the last value of the set.\n *\n * @return {number} - The popped value.\n */\n\n\nBitVector.prototype.pop = function () {\n  if (this.length === 0) return;\n  var index = --this.length;\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n  return this.array[byteIndex] >> pos & 1;\n};\n/**\n * Method used to get the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {number}\n */\n\n\nBitVector.prototype.get = function (index) {\n  if (this.length < index) return undefined;\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n  return this.array[byteIndex] >> pos & 1;\n};\n/**\n * Method used to test the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {BitVector}\n */\n\n\nBitVector.prototype.test = function (index) {\n  if (this.length < index) return false;\n  return Boolean(this.get(index));\n};\n/**\n * Method used to return the number of 1 from the beginning of the set up to\n * the ith index.\n *\n * @param  {number} i - Ith index (cannot be > length).\n * @return {number}\n */\n\n\nBitVector.prototype.rank = function (i) {\n  if (this.size === 0) return 0;\n  var byteIndex = i >> 5,\n      pos = i & 0x0000001f,\n      r = 0; // Accessing the bytes before the last one\n\n  for (var j = 0; j < byteIndex; j++) {\n    r += bitwise.table8Popcount(this.array[j]);\n  } // Handling masked last byte\n\n\n  var maskedByte = this.array[byteIndex] & (1 << pos) - 1;\n  r += bitwise.table8Popcount(maskedByte);\n  return r;\n};\n/**\n * Method used to return the position of the rth 1 in the set or -1 if the\n * set is empty.\n *\n * Note: usually select is implemented using binary search over rank but I\n * tend to think the following linear implementation is faster since here\n * rank is O(n) anyway.\n *\n * @param  {number} r - Rth 1 to select (should be < length).\n * @return {number}\n */\n\n\nBitVector.prototype.select = function (r) {\n  if (this.size === 0) return -1; // TODO: throw?\n\n  if (r >= this.length) return -1;\n  var byte,\n      b = 32,\n      p = 0,\n      c = 0;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i]; // The byte is empty, let's continue\n\n    if (byte === 0) continue; // TODO: This branching might not be useful here\n\n    if (i === l - 1) b = this.length % 32 || 32; // TODO: popcount should speed things up here\n\n    for (var j = 0; j < b; j++, p++) {\n      c += byte >> j & 1;\n      if (c === r) return p;\n    }\n  }\n};\n/**\n * Method used to iterate over the bit set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nBitVector.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var length = this.length,\n      byte,\n      bit,\n      b = 32;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n    if (i === l - 1) b = length % 32 || 32;\n\n    for (var j = 0; j < b; j++) {\n      bit = byte >> j & 1;\n      callback.call(scope, bit, i * 32 + j);\n    }\n  }\n};\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\n\n\nBitVector.prototype.values = function () {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n  return new Iterator(function next() {\n    if (!inner) {\n      if (i >= l) return {\n        done: true\n      };\n      if (i === l - 1) b = length % 32 || 32;\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = byte >> j & 1;\n    return {\n      value: bit\n    };\n  });\n};\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\n\n\nBitVector.prototype.entries = function () {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      index,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n  return new Iterator(function next() {\n    if (!inner) {\n      if (i >= l) return {\n        done: true\n      };\n      if (i === l - 1) b = length % 32 || 32;\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n    index = ~-i * 32 + j;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = byte >> j & 1;\n    return {\n      value: [index, bit]\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') BitVector.prototype[Symbol.iterator] = BitVector.prototype.values;\n/**\n * Convenience known methods.\n */\n\nBitVector.prototype.inspect = function () {\n  var proxy = new Uint8Array(this.length);\n  this.forEach(function (bit, i) {\n    proxy[i] = bit;\n  }); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: BitVector,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') BitVector.prototype[Symbol.for('nodejs.util.inspect.custom')] = BitVector.prototype.inspect;\n\nBitVector.prototype.toJSON = function () {\n  return Array.from(this.array.slice(0, (this.length >> 5) + 1));\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = BitVector;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/bit-vector.js"],"names":["Iterator","require","bitwise","DEFAULT_GROWING_POLICY","capacity","Math","max","ceil","createByteArray","Uint32Array","BitVector","initialLengthOrOptions","initialLength","policy","initialCapacity","size","length","array","prototype","set","index","value","Error","byteIndex","pos","oldBytes","newBytes","reset","flip","applyPolicy","override","newCapacity","reallocate","virtualCapacity","oldArray","storageLength","slice","grow","resize","push","pop","get","undefined","test","Boolean","rank","i","r","j","table8Popcount","maskedByte","select","byte","b","p","c","l","forEach","callback","scope","arguments","bit","call","values","inner","next","done","entries","Symbol","iterator","inspect","proxy","Uint8Array","Object","defineProperty","enumerable","for","toJSON","Array","from","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist BitVector\n * ====================\n *\n * JavaScript implementation of a dynamic BitSet based upon a Uint32Array.\n *\n * Notes:\n *   - (i >> 5) is the same as ((i / 32) | 0)\n *   - (i & 0x0000001f) is the same as (i % 32)\n *   - I could use a Float64Array to store more in less blocks but I would lose\n *     the benefits of byte comparison to keep track of size without popcounts.\n */\nvar Iterator = require('obliterator/iterator'),\n    bitwise = require('./utils/bitwise.js');\n\n/**\n * Constants.\n */\nvar DEFAULT_GROWING_POLICY = function(capacity) {\n  return Math.max(1, Math.ceil(capacity * 1.5));\n};\n\n/**\n * Helpers.\n */\nfunction createByteArray(capacity) {\n  return new Uint32Array(Math.ceil(capacity / 32));\n}\n\n/**\n * BitVector.\n *\n * @constructor\n */\nfunction BitVector(initialLengthOrOptions) {\n  var initialLength = initialLengthOrOptions || 0,\n      policy = DEFAULT_GROWING_POLICY;\n\n  if (typeof initialLengthOrOptions === 'object') {\n    initialLength = (\n      initialLengthOrOptions.initialLength ||\n      initialLengthOrOptions.initialCapacity ||\n      0\n    );\n    policy = initialLengthOrOptions.policy || policy;\n  }\n\n  this.size = 0;\n  this.length = initialLength;\n  this.capacity = Math.ceil(this.length / 32) * 32;\n  this.policy = policy;\n  this.array = createByteArray(this.capacity);\n}\n\n/**\n * Method used to set the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @param  {number|boolean} value - Value to set.\n * @return {BitVector}\n */\nBitVector.prototype.set = function(index, value) {\n\n  // Out of bounds?\n  if (this.length < index)\n    throw new Error('BitVector.set: index out of bounds.');\n\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n\n  if (value === 0 || value === false)\n    newBytes = this.array[byteIndex] &= ~(1 << pos);\n  else\n    newBytes = this.array[byteIndex] |= (1 << pos);\n\n  // Get unsigned representation.\n  newBytes = newBytes >>> 0;\n\n  // Updating size\n  if (newBytes > oldBytes)\n    this.size++;\n  else if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n* Method used to reset the given bit's value.\n*\n* @param  {number} index - Target bit index.\n* @return {BitVector}\n*/\nBitVector.prototype.reset = function(index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n\n  newBytes = this.array[byteIndex] &= ~(1 << pos);\n\n  // Updating size\n  if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n * Method used to flip the value of the given bit.\n *\n * @param  {number} index - Target bit index.\n * @return {BitVector}\n */\nBitVector.prototype.flip = function(index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex];\n\n  var newBytes = this.array[byteIndex] ^= (1 << pos);\n\n  // Get unsigned representation.\n  newBytes = newBytes >>> 0;\n\n  // Updating size\n  if (newBytes > oldBytes)\n    this.size++;\n  else if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n * Method used to apply the growing policy.\n *\n * @param  {number} [override] - Override capacity.\n * @return {number}\n */\nBitVector.prototype.applyPolicy = function(override) {\n  var newCapacity = this.policy(override || this.capacity);\n\n  if (typeof newCapacity !== 'number' || newCapacity < 0)\n    throw new Error('mnemonist/bit-vector.applyPolicy: policy returned an invalid value (expecting a positive integer).');\n\n  if (newCapacity <= this.capacity)\n    throw new Error('mnemonist/bit-vector.applyPolicy: policy returned a less or equal capacity to allocate.');\n\n  // TODO: we should probably check that the returned number is an integer\n\n  // Ceil to nearest 32\n  return Math.ceil(newCapacity / 32) * 32;\n};\n\n/**\n * Method used to reallocate the underlying array.\n *\n * @param  {number}       capacity - Target capacity.\n * @return {BitVector}\n */\nBitVector.prototype.reallocate = function(capacity) {\n  var virtualCapacity = capacity;\n\n  capacity = Math.ceil(capacity / 32) * 32;\n\n  if (virtualCapacity < this.length)\n    this.length = virtualCapacity;\n\n  if (capacity === this.capacity)\n    return this;\n\n  var oldArray = this.array;\n\n  var storageLength = capacity / 32;\n\n  if (storageLength === this.array.length)\n    return this;\n\n  if (storageLength > this.array.length) {\n    this.array = new Uint32Array(storageLength);\n    this.array.set(oldArray, 0);\n  }\n  else {\n    this.array = oldArray.slice(0, storageLength);\n  }\n\n  this.capacity = capacity;\n\n  return this;\n};\n\n/**\n * Method used to grow the array.\n *\n * @param  {number}       [capacity] - Optional capacity to match.\n * @return {BitVector}\n */\nBitVector.prototype.grow = function(capacity) {\n  var newCapacity;\n\n  if (typeof capacity === 'number') {\n\n    if (this.capacity >= capacity)\n      return this;\n\n    // We need to match the given capacity\n    newCapacity = this.capacity;\n\n    while (newCapacity < capacity)\n      newCapacity = this.applyPolicy(newCapacity);\n\n    this.reallocate(newCapacity);\n\n    return this;\n  }\n\n  // We need to run the policy once\n  newCapacity = this.applyPolicy();\n  this.reallocate(newCapacity);\n\n  return this;\n};\n\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {BitVector}\n */\nBitVector.prototype.resize = function(length) {\n  if (length === this.length)\n    return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.reallocate(length);\n\n  return this;\n};\n\n/**\n * Method used to push a value in the set.\n *\n * @param  {number|boolean} value\n * @return {BitVector}\n */\nBitVector.prototype.push = function(value) {\n  if (this.capacity === this.length)\n    this.grow();\n\n  if (value === 0 || value === false)\n    return ++this.length;\n\n  this.size++;\n\n  var index = this.length++,\n      byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n\n  this.array[byteIndex] |= (1 << pos);\n\n  return this.length;\n};\n\n/**\n * Method used to pop the last value of the set.\n *\n * @return {number} - The popped value.\n */\nBitVector.prototype.pop = function() {\n  if (this.length === 0)\n    return;\n\n  var index = --this.length;\n\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n\n  return (this.array[byteIndex] >> pos) & 1;\n};\n\n/**\n * Method used to get the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {number}\n */\nBitVector.prototype.get = function(index) {\n  if (this.length < index)\n    return undefined;\n\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n\n  return (this.array[byteIndex] >> pos) & 1;\n};\n\n/**\n * Method used to test the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {BitVector}\n */\nBitVector.prototype.test = function(index) {\n  if (this.length < index)\n    return false;\n\n  return Boolean(this.get(index));\n};\n\n/**\n * Method used to return the number of 1 from the beginning of the set up to\n * the ith index.\n *\n * @param  {number} i - Ith index (cannot be > length).\n * @return {number}\n */\nBitVector.prototype.rank = function(i) {\n  if (this.size === 0)\n    return 0;\n\n  var byteIndex = i >> 5,\n      pos = i & 0x0000001f,\n      r = 0;\n\n  // Accessing the bytes before the last one\n  for (var j = 0; j < byteIndex; j++)\n    r += bitwise.table8Popcount(this.array[j]);\n\n  // Handling masked last byte\n  var maskedByte = this.array[byteIndex] & ((1 << pos) - 1);\n\n  r += bitwise.table8Popcount(maskedByte);\n\n  return r;\n};\n\n/**\n * Method used to return the position of the rth 1 in the set or -1 if the\n * set is empty.\n *\n * Note: usually select is implemented using binary search over rank but I\n * tend to think the following linear implementation is faster since here\n * rank is O(n) anyway.\n *\n * @param  {number} r - Rth 1 to select (should be < length).\n * @return {number}\n */\nBitVector.prototype.select = function(r) {\n  if (this.size === 0)\n    return -1;\n\n  // TODO: throw?\n  if (r >= this.length)\n    return -1;\n\n  var byte,\n      b = 32,\n      p = 0,\n      c = 0;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n\n    // The byte is empty, let's continue\n    if (byte === 0)\n      continue;\n\n    // TODO: This branching might not be useful here\n    if (i === l - 1)\n      b = this.length % 32 || 32;\n\n    // TODO: popcount should speed things up here\n\n    for (var j = 0; j < b; j++, p++) {\n      c += (byte >> j) & 1;\n\n      if (c === r)\n        return p;\n    }\n  }\n};\n\n/**\n * Method used to iterate over the bit set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nBitVector.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var length = this.length,\n      byte,\n      bit,\n      b = 32;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n\n    if (i === l - 1)\n      b = length % 32 || 32;\n\n    for (var j = 0; j < b; j++) {\n      bit = (byte >> j) & 1;\n\n      callback.call(scope, bit, i * 32 + j);\n    }\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nBitVector.prototype.values = function() {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n\n  return new Iterator(function next() {\n    if (!inner) {\n\n      if (i >= l)\n        return {\n          done: true\n        };\n\n      if (i === l - 1)\n        b = length % 32 || 32;\n\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = (byte >> j) & 1;\n\n    return {\n      value: bit\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\nBitVector.prototype.entries = function() {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      index,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n\n  return new Iterator(function next() {\n    if (!inner) {\n\n      if (i >= l)\n        return {\n          done: true\n        };\n\n      if (i === l - 1)\n        b = length % 32 || 32;\n\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n    index = (~-i) * 32 + j;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = (byte >> j) & 1;\n\n    return {\n      value: [index, bit]\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  BitVector.prototype[Symbol.iterator] = BitVector.prototype.values;\n\n/**\n * Convenience known methods.\n */\nBitVector.prototype.inspect = function() {\n  var proxy = new Uint8Array(this.length);\n\n  this.forEach(function(bit, i) {\n    proxy[i] = bit;\n  });\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: BitVector,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  BitVector.prototype[Symbol.for('nodejs.util.inspect.custom')] = BitVector.prototype.inspect;\n\nBitVector.prototype.toJSON = function() {\n  return Array.from(this.array.slice(0, (this.length >> 5) + 1));\n};\n\n/**\n * Exporting.\n */\nmodule.exports = BitVector;\n"]},"metadata":{},"sourceType":"script"}