{"ast":null,"code":"/**\n * Mnemonist KDTree\n * =================\n *\n * Low-level JavaScript implementation of a k-dimensional tree.\n */\nvar iterables = require('./utils/iterables.js');\n\nvar typed = require('./utils/typed-arrays.js');\n\nvar createTupleComparator = require('./utils/comparators.js').createTupleComparator;\n\nvar FixedReverseHeap = require('./fixed-reverse-heap.js');\n\nvar inplaceQuickSortIndices = require('./sort/quick.js').inplaceQuickSortIndices;\n/**\n * Helper function used to compute the squared distance between a query point\n * and an indexed points whose values are stored in a tree's axes.\n *\n * Note that squared distance is used instead of euclidean to avoid\n * costly sqrt computations.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  axes       - Axes data.\n * @param  {number} pivot      - Pivot.\n * @param  {array}  point      - Query point.\n * @return {number}\n */\n\n\nfunction squaredDistanceAxes(dimensions, axes, pivot, b) {\n  var d;\n  var dist = 0,\n      step;\n\n  for (d = 0; d < dimensions; d++) {\n    step = axes[d][pivot] - b[d];\n    dist += step * step;\n  }\n\n  return dist;\n}\n/**\n * Helper function used to reshape input data into low-level axes data.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  data       - Data in the shape [label, [x, y, z...]]\n * @return {object}\n */\n\n\nfunction reshapeIntoAxes(dimensions, data) {\n  var l = data.length;\n  var axes = new Array(dimensions),\n      labels = new Array(l),\n      axis;\n  var PointerArray = typed.getPointerArray(l);\n  var ids = new PointerArray(l);\n  var d, i, row;\n  var f = true;\n\n  for (d = 0; d < dimensions; d++) {\n    axis = new Float64Array(l);\n\n    for (i = 0; i < l; i++) {\n      row = data[i];\n      axis[i] = row[1][d];\n\n      if (f) {\n        labels[i] = row[0];\n        ids[i] = i;\n      }\n    }\n\n    f = false;\n    axes[d] = axis;\n  }\n\n  return {\n    axes: axes,\n    ids: ids,\n    labels: labels\n  };\n}\n/**\n * Helper function used to build a kd-tree from axes data.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  axes       - Axes.\n * @param  {array}  ids        - Indices to sort.\n * @param  {array}  labels     - Point labels.\n * @return {object}\n */\n\n\nfunction buildTree(dimensions, axes, ids, labels) {\n  var l = labels.length; // NOTE: +1 because we need to keep 0 as null pointer\n\n  var PointerArray = typed.getPointerArray(l + 1); // Building the tree\n\n  var pivots = new PointerArray(l),\n      lefts = new PointerArray(l),\n      rights = new PointerArray(l);\n  var stack = [[0, 0, ids.length, -1, 0]],\n      step,\n      parent,\n      direction,\n      median,\n      pivot,\n      lo,\n      hi;\n  var d,\n      i = 0;\n\n  while (stack.length !== 0) {\n    step = stack.pop();\n    d = step[0];\n    lo = step[1];\n    hi = step[2];\n    parent = step[3];\n    direction = step[4];\n    inplaceQuickSortIndices(axes[d], ids, lo, hi);\n    l = hi - lo;\n    median = lo + (l >>> 1); // Fancy floor(l / 2)\n\n    pivot = ids[median];\n    pivots[i] = pivot;\n\n    if (parent > -1) {\n      if (direction === 0) lefts[parent] = i + 1;else rights[parent] = i + 1;\n    }\n\n    d = (d + 1) % dimensions; // Right\n\n    if (median !== lo && median !== hi - 1) {\n      stack.push([d, median + 1, hi, i, 1]);\n    } // Left\n\n\n    if (median !== lo) {\n      stack.push([d, lo, median, i, 0]);\n    }\n\n    i++;\n  }\n\n  return {\n    axes: axes,\n    labels: labels,\n    pivots: pivots,\n    lefts: lefts,\n    rights: rights\n  };\n}\n/**\n * KDTree.\n *\n * @constructor\n */\n\n\nfunction KDTree(dimensions, build) {\n  this.dimensions = dimensions;\n  this.visited = 0;\n  this.axes = build.axes;\n  this.labels = build.labels;\n  this.pivots = build.pivots;\n  this.lefts = build.lefts;\n  this.rights = build.rights;\n  this.size = this.labels.length;\n}\n/**\n * Method returning the query's nearest neighbor.\n *\n * @param  {array}  query - Query point.\n * @return {any}\n */\n\n\nKDTree.prototype.nearestNeighbor = function (query) {\n  var bestDistance = Infinity,\n      best = null;\n  var dimensions = this.dimensions,\n      axes = this.axes,\n      pivots = this.pivots,\n      lefts = this.lefts,\n      rights = this.rights;\n  var visited = 0;\n\n  function recurse(d, node) {\n    visited++;\n    var left = lefts[node],\n        right = rights[node],\n        pivot = pivots[node];\n    var dist = squaredDistanceAxes(dimensions, axes, pivot, query);\n\n    if (dist < bestDistance) {\n      best = pivot;\n      bestDistance = dist;\n      if (dist === 0) return;\n    }\n\n    var dx = axes[d][pivot] - query[d];\n    d = (d + 1) % dimensions; // Going the correct way?\n\n    if (dx > 0) {\n      if (left !== 0) recurse(d, left - 1);\n    } else {\n      if (right !== 0) recurse(d, right - 1);\n    } // Going the other way?\n\n\n    if (dx * dx < bestDistance) {\n      if (dx > 0) {\n        if (right !== 0) recurse(d, right - 1);\n      } else {\n        if (left !== 0) recurse(d, left - 1);\n      }\n    }\n  }\n\n  recurse(0, 0);\n  this.visited = visited;\n  return this.labels[best];\n};\n\nvar KNN_HEAP_COMPARATOR_3 = createTupleComparator(3);\nvar KNN_HEAP_COMPARATOR_2 = createTupleComparator(2);\n/**\n * Method returning the query's k nearest neighbors.\n *\n * @param  {number} k     - Number of nearest neighbor to retrieve.\n * @param  {array}  query - Query point.\n * @return {array}\n */\n// TODO: can do better by improving upon static-kdtree here\n\nKDTree.prototype.kNearestNeighbors = function (k, query) {\n  if (k <= 0) throw new Error('mnemonist/kd-tree.kNearestNeighbors: k should be a positive number.');\n  k = Math.min(k, this.size);\n  if (k === 1) return [this.nearestNeighbor(query)];\n  var heap = new FixedReverseHeap(Array, KNN_HEAP_COMPARATOR_3, k);\n  var dimensions = this.dimensions,\n      axes = this.axes,\n      pivots = this.pivots,\n      lefts = this.lefts,\n      rights = this.rights;\n  var visited = 0;\n\n  function recurse(d, node) {\n    var left = lefts[node],\n        right = rights[node],\n        pivot = pivots[node];\n    var dist = squaredDistanceAxes(dimensions, axes, pivot, query);\n    heap.push([dist, visited++, pivot]);\n    var point = query[d],\n        split = axes[d][pivot],\n        dx = point - split;\n    d = (d + 1) % dimensions; // Going the correct way?\n\n    if (point < split) {\n      if (left !== 0) {\n        recurse(d, left - 1);\n      }\n    } else {\n      if (right !== 0) {\n        recurse(d, right - 1);\n      }\n    } // Going the other way?\n\n\n    if (dx * dx < heap.peek()[0] || heap.size < k) {\n      if (point < split) {\n        if (right !== 0) {\n          recurse(d, right - 1);\n        }\n      } else {\n        if (left !== 0) {\n          recurse(d, left - 1);\n        }\n      }\n    }\n  }\n\n  recurse(0, 0);\n  this.visited = visited;\n  var best = heap.consume();\n\n  for (var i = 0; i < best.length; i++) best[i] = this.labels[best[i][2]];\n\n  return best;\n};\n/**\n * Method returning the query's k nearest neighbors by linear search.\n *\n * @param  {number} k     - Number of nearest neighbor to retrieve.\n * @param  {array}  query - Query point.\n * @return {array}\n */\n\n\nKDTree.prototype.linearKNearestNeighbors = function (k, query) {\n  if (k <= 0) throw new Error('mnemonist/kd-tree.kNearestNeighbors: k should be a positive number.');\n  k = Math.min(k, this.size);\n  var heap = new FixedReverseHeap(Array, KNN_HEAP_COMPARATOR_2, k);\n  var i, l, dist;\n\n  for (i = 0, l = this.size; i < l; i++) {\n    dist = squaredDistanceAxes(this.dimensions, this.axes, this.pivots[i], query);\n    heap.push([dist, i]);\n  }\n\n  var best = heap.consume();\n\n  for (i = 0; i < best.length; i++) best[i] = this.labels[this.pivots[best[i][1]]];\n\n  return best;\n};\n/**\n * Convenience known methods.\n */\n\n\nKDTree.prototype.inspect = function () {\n  var dummy = new Map();\n  dummy.dimensions = this.dimensions;\n  Object.defineProperty(dummy, 'constructor', {\n    value: KDTree,\n    enumerable: false\n  });\n  var i, j, point;\n\n  for (i = 0; i < this.size; i++) {\n    point = new Array(this.dimensions);\n\n    for (j = 0; j < this.dimensions; j++) point[j] = this.axes[j][i];\n\n    dummy.set(this.labels[i], point);\n  }\n\n  return dummy;\n};\n\nif (typeof Symbol !== 'undefined') KDTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = KDTree.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {number}   dimensions - Space dimensions.\n * @return {KDTree}\n */\n\nKDTree.from = function (iterable, dimensions) {\n  var data = iterables.toArray(iterable);\n  var reshaped = reshapeIntoAxes(dimensions, data);\n  var result = buildTree(dimensions, reshaped.axes, reshaped.ids, reshaped.labels);\n  return new KDTree(dimensions, result);\n};\n/**\n * Static @.from function building a KDTree from given axes.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {number}   dimensions - Space dimensions.\n * @return {KDTree}\n */\n\n\nKDTree.fromAxes = function (axes, labels) {\n  if (!labels) labels = typed.indices(axes[0].length);\n  var dimensions = axes.length;\n  var result = buildTree(axes.length, axes, typed.indices(labels.length), labels);\n  return new KDTree(dimensions, result);\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = KDTree;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/kd-tree.js"],"names":["iterables","require","typed","createTupleComparator","FixedReverseHeap","inplaceQuickSortIndices","squaredDistanceAxes","dimensions","axes","pivot","b","d","dist","step","reshapeIntoAxes","data","l","length","Array","labels","axis","PointerArray","getPointerArray","ids","i","row","f","Float64Array","buildTree","pivots","lefts","rights","stack","parent","direction","median","lo","hi","pop","push","KDTree","build","visited","size","prototype","nearestNeighbor","query","bestDistance","Infinity","best","recurse","node","left","right","dx","KNN_HEAP_COMPARATOR_3","KNN_HEAP_COMPARATOR_2","kNearestNeighbors","k","Error","Math","min","heap","point","split","peek","consume","linearKNearestNeighbors","inspect","dummy","Map","Object","defineProperty","value","enumerable","j","set","Symbol","for","from","iterable","toArray","reshaped","result","fromAxes","indices","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist KDTree\n * =================\n *\n * Low-level JavaScript implementation of a k-dimensional tree.\n */\nvar iterables = require('./utils/iterables.js');\nvar typed = require('./utils/typed-arrays.js');\nvar createTupleComparator = require('./utils/comparators.js').createTupleComparator;\nvar FixedReverseHeap = require('./fixed-reverse-heap.js');\nvar inplaceQuickSortIndices = require('./sort/quick.js').inplaceQuickSortIndices;\n\n/**\n * Helper function used to compute the squared distance between a query point\n * and an indexed points whose values are stored in a tree's axes.\n *\n * Note that squared distance is used instead of euclidean to avoid\n * costly sqrt computations.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  axes       - Axes data.\n * @param  {number} pivot      - Pivot.\n * @param  {array}  point      - Query point.\n * @return {number}\n */\nfunction squaredDistanceAxes(dimensions, axes, pivot, b) {\n  var d;\n\n  var dist = 0,\n      step;\n\n  for (d = 0; d < dimensions; d++) {\n    step = axes[d][pivot] - b[d];\n    dist += step * step;\n  }\n\n  return dist;\n}\n\n/**\n * Helper function used to reshape input data into low-level axes data.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  data       - Data in the shape [label, [x, y, z...]]\n * @return {object}\n */\nfunction reshapeIntoAxes(dimensions, data) {\n  var l = data.length;\n\n  var axes = new Array(dimensions),\n      labels = new Array(l),\n      axis;\n\n  var PointerArray = typed.getPointerArray(l);\n\n  var ids = new PointerArray(l);\n\n  var d, i, row;\n\n  var f = true;\n\n  for (d = 0; d < dimensions; d++) {\n    axis = new Float64Array(l);\n\n    for (i = 0; i < l; i++) {\n      row = data[i];\n      axis[i] = row[1][d];\n\n      if (f) {\n        labels[i] = row[0];\n        ids[i] = i;\n      }\n    }\n\n    f = false;\n    axes[d] = axis;\n  }\n\n  return {axes: axes, ids: ids, labels: labels};\n}\n\n/**\n * Helper function used to build a kd-tree from axes data.\n *\n * @param  {number} dimensions - Number of dimensions.\n * @param  {array}  axes       - Axes.\n * @param  {array}  ids        - Indices to sort.\n * @param  {array}  labels     - Point labels.\n * @return {object}\n */\nfunction buildTree(dimensions, axes, ids, labels) {\n  var l = labels.length;\n\n  // NOTE: +1 because we need to keep 0 as null pointer\n  var PointerArray = typed.getPointerArray(l + 1);\n\n  // Building the tree\n  var pivots = new PointerArray(l),\n      lefts = new PointerArray(l),\n      rights = new PointerArray(l);\n\n  var stack = [[0, 0, ids.length, -1, 0]],\n      step,\n      parent,\n      direction,\n      median,\n      pivot,\n      lo,\n      hi;\n\n  var d, i = 0;\n\n  while (stack.length !== 0) {\n    step = stack.pop();\n\n    d = step[0];\n    lo = step[1];\n    hi = step[2];\n    parent = step[3];\n    direction = step[4];\n\n    inplaceQuickSortIndices(axes[d], ids, lo, hi);\n\n    l = hi - lo;\n    median = lo + (l >>> 1); // Fancy floor(l / 2)\n    pivot = ids[median];\n    pivots[i] = pivot;\n\n    if (parent > -1) {\n      if (direction === 0)\n        lefts[parent] = i + 1;\n      else\n        rights[parent] = i + 1;\n    }\n\n    d = (d + 1) % dimensions;\n\n    // Right\n    if (median !== lo && median !== hi - 1) {\n      stack.push([d, median + 1, hi, i, 1]);\n    }\n\n    // Left\n    if (median !== lo) {\n      stack.push([d, lo, median, i, 0]);\n    }\n\n    i++;\n  }\n\n  return {\n    axes: axes,\n    labels: labels,\n    pivots: pivots,\n    lefts: lefts,\n    rights: rights\n  };\n}\n\n/**\n * KDTree.\n *\n * @constructor\n */\nfunction KDTree(dimensions, build) {\n  this.dimensions = dimensions;\n  this.visited = 0;\n\n  this.axes = build.axes;\n  this.labels = build.labels;\n\n  this.pivots = build.pivots;\n  this.lefts = build.lefts;\n  this.rights = build.rights;\n\n  this.size = this.labels.length;\n}\n\n/**\n * Method returning the query's nearest neighbor.\n *\n * @param  {array}  query - Query point.\n * @return {any}\n */\nKDTree.prototype.nearestNeighbor = function(query) {\n  var bestDistance = Infinity,\n      best = null;\n\n  var dimensions = this.dimensions,\n      axes = this.axes,\n      pivots = this.pivots,\n      lefts = this.lefts,\n      rights = this.rights;\n\n  var visited = 0;\n\n  function recurse(d, node) {\n    visited++;\n\n    var left = lefts[node],\n        right = rights[node],\n        pivot = pivots[node];\n\n    var dist = squaredDistanceAxes(\n      dimensions,\n      axes,\n      pivot,\n      query\n    );\n\n    if (dist < bestDistance) {\n      best = pivot;\n      bestDistance = dist;\n\n      if (dist === 0)\n        return;\n    }\n\n    var dx = axes[d][pivot] - query[d];\n\n    d = (d + 1) % dimensions;\n\n    // Going the correct way?\n    if (dx > 0) {\n      if (left !== 0)\n        recurse(d, left - 1);\n    }\n    else {\n      if (right !== 0)\n        recurse(d, right - 1);\n    }\n\n    // Going the other way?\n    if (dx * dx < bestDistance) {\n      if (dx > 0) {\n        if (right !== 0)\n          recurse(d, right - 1);\n      }\n      else {\n        if (left !== 0)\n          recurse(d, left - 1);\n      }\n    }\n  }\n\n  recurse(0, 0);\n\n  this.visited = visited;\n  return this.labels[best];\n};\n\nvar KNN_HEAP_COMPARATOR_3 = createTupleComparator(3);\nvar KNN_HEAP_COMPARATOR_2 = createTupleComparator(2);\n\n/**\n * Method returning the query's k nearest neighbors.\n *\n * @param  {number} k     - Number of nearest neighbor to retrieve.\n * @param  {array}  query - Query point.\n * @return {array}\n */\n\n// TODO: can do better by improving upon static-kdtree here\nKDTree.prototype.kNearestNeighbors = function(k, query) {\n  if (k <= 0)\n    throw new Error('mnemonist/kd-tree.kNearestNeighbors: k should be a positive number.');\n\n  k = Math.min(k, this.size);\n\n  if (k === 1)\n    return [this.nearestNeighbor(query)];\n\n  var heap = new FixedReverseHeap(Array, KNN_HEAP_COMPARATOR_3, k);\n\n  var dimensions = this.dimensions,\n      axes = this.axes,\n      pivots = this.pivots,\n      lefts = this.lefts,\n      rights = this.rights;\n\n  var visited = 0;\n\n  function recurse(d, node) {\n    var left = lefts[node],\n        right = rights[node],\n        pivot = pivots[node];\n\n    var dist = squaredDistanceAxes(\n      dimensions,\n      axes,\n      pivot,\n      query\n    );\n\n    heap.push([dist, visited++, pivot]);\n\n    var point = query[d],\n        split = axes[d][pivot],\n        dx = point - split;\n\n    d = (d + 1) % dimensions;\n\n    // Going the correct way?\n    if (point < split) {\n      if (left !== 0) {\n        recurse(d, left - 1);\n      }\n    }\n    else {\n      if (right !== 0) {\n        recurse(d, right - 1);\n      }\n    }\n\n    // Going the other way?\n    if (dx * dx < heap.peek()[0] || heap.size < k) {\n      if (point < split) {\n        if (right !== 0) {\n          recurse(d, right - 1);\n        }\n      }\n      else {\n        if (left !== 0) {\n          recurse(d, left - 1);\n        }\n      }\n    }\n  }\n\n  recurse(0, 0);\n\n  this.visited = visited;\n\n  var best = heap.consume();\n\n  for (var i = 0; i < best.length; i++)\n    best[i] = this.labels[best[i][2]];\n\n  return best;\n};\n\n/**\n * Method returning the query's k nearest neighbors by linear search.\n *\n * @param  {number} k     - Number of nearest neighbor to retrieve.\n * @param  {array}  query - Query point.\n * @return {array}\n */\nKDTree.prototype.linearKNearestNeighbors = function(k, query) {\n  if (k <= 0)\n    throw new Error('mnemonist/kd-tree.kNearestNeighbors: k should be a positive number.');\n\n  k = Math.min(k, this.size);\n\n  var heap = new FixedReverseHeap(Array, KNN_HEAP_COMPARATOR_2, k);\n\n  var i, l, dist;\n\n  for (i = 0, l = this.size; i < l; i++) {\n    dist = squaredDistanceAxes(\n      this.dimensions,\n      this.axes,\n      this.pivots[i],\n      query\n    );\n\n    heap.push([dist, i]);\n  }\n\n  var best = heap.consume();\n\n  for (i = 0; i < best.length; i++)\n    best[i] = this.labels[this.pivots[best[i][1]]];\n\n  return best;\n};\n\n/**\n * Convenience known methods.\n */\nKDTree.prototype.inspect = function() {\n  var dummy = new Map();\n\n  dummy.dimensions = this.dimensions;\n\n  Object.defineProperty(dummy, 'constructor', {\n    value: KDTree,\n    enumerable: false\n  });\n\n  var i, j, point;\n\n  for (i = 0; i < this.size; i++) {\n    point = new Array(this.dimensions);\n\n    for (j = 0; j < this.dimensions; j++)\n      point[j] = this.axes[j][i];\n\n    dummy.set(this.labels[i], point);\n  }\n\n  return dummy;\n};\n\nif (typeof Symbol !== 'undefined')\n  KDTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = KDTree.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {number}   dimensions - Space dimensions.\n * @return {KDTree}\n */\nKDTree.from = function(iterable, dimensions) {\n  var data = iterables.toArray(iterable);\n\n  var reshaped = reshapeIntoAxes(dimensions, data);\n\n  var result = buildTree(dimensions, reshaped.axes, reshaped.ids, reshaped.labels);\n\n  return new KDTree(dimensions, result);\n};\n\n/**\n * Static @.from function building a KDTree from given axes.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {number}   dimensions - Space dimensions.\n * @return {KDTree}\n */\nKDTree.fromAxes = function(axes, labels) {\n  if (!labels)\n    labels = typed.indices(axes[0].length);\n\n  var dimensions = axes.length;\n\n  var result = buildTree(axes.length, axes, typed.indices(labels.length), labels);\n\n  return new KDTree(dimensions, result);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = KDTree;\n"]},"metadata":{},"sourceType":"script"}