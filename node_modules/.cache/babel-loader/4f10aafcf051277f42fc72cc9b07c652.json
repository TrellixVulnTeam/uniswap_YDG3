{"ast":null,"code":"import { CurrencyAmount, Token } from '@uniswap/sdk-core';\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk';\nimport { Pool, Route as V3Route } from '@uniswap/v3-sdk';\nimport { nativeOnChain } from '../../constants/tokens';\nimport { InterfaceTrade } from './types';\n/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */\n\nexport function computeRoutes(currencyIn, currencyOut, tradeType, quoteResult) {\n  if (!quoteResult || !quoteResult.route || !currencyIn || !currencyOut) return undefined;\n  if (quoteResult.route.length === 0) return [];\n  const parsedTokenIn = parseToken(quoteResult.route[0][0].tokenIn);\n  const parsedTokenOut = parseToken(quoteResult.route[0][quoteResult.route[0].length - 1].tokenOut);\n  if (parsedTokenIn.address !== currencyIn.wrapped.address) return undefined;\n  if (parsedTokenOut.address !== currencyOut.wrapped.address) return undefined;\n  const parsedCurrencyIn = currencyIn.isNative ? nativeOnChain(currencyIn.chainId) : parsedTokenIn;\n  const parsedCurrencyOut = currencyOut.isNative ? nativeOnChain(currencyOut.chainId) : parsedTokenOut;\n\n  try {\n    return quoteResult.route.map(route => {\n      if (route.length === 0) {\n        throw new Error('Expected route to have at least one pair or pool');\n      }\n\n      const rawAmountIn = route[0].amountIn;\n      const rawAmountOut = route[route.length - 1].amountOut;\n\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both amountIn and amountOut to be present');\n      }\n\n      return {\n        routev3: isV3Route(route) ? new V3Route(route.map(parsePool), parsedCurrencyIn, parsedCurrencyOut) : null,\n        routev2: !isV3Route(route) ? new V2Route(route.map(parsePair), parsedCurrencyIn, parsedCurrencyOut) : null,\n        inputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyIn, rawAmountIn),\n        outputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyOut, rawAmountOut)\n      };\n    });\n  } catch (e) {\n    // `Route` constructor may throw if inputs/outputs are temporarily out of sync\n    // (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n    // This is not fatal and will fix itself in future render cycles\n    console.error(e);\n    return undefined;\n  }\n}\nexport function transformRoutesToTrade(route, tradeType, gasUseEstimateUSD) {\n  var _route$filter$map, _route$filter$map2;\n\n  return new InterfaceTrade({\n    v2Routes: (_route$filter$map = route === null || route === void 0 ? void 0 : route.filter(r => r.routev2 !== null).map(({\n      routev2,\n      inputAmount,\n      outputAmount\n    }) => ({\n      routev2,\n      inputAmount,\n      outputAmount\n    }))) !== null && _route$filter$map !== void 0 ? _route$filter$map : [],\n    v3Routes: (_route$filter$map2 = route === null || route === void 0 ? void 0 : route.filter(r => r.routev3 !== null).map(({\n      routev3,\n      inputAmount,\n      outputAmount\n    }) => ({\n      routev3,\n      inputAmount,\n      outputAmount\n    }))) !== null && _route$filter$map2 !== void 0 ? _route$filter$map2 : [],\n    tradeType,\n    gasUseEstimateUSD\n  });\n}\n\nconst parseToken = ({\n  address,\n  chainId,\n  decimals,\n  symbol\n}) => {\n  return new Token(chainId, address, parseInt(decimals.toString()), symbol);\n};\n\nconst parsePool = ({\n  fee,\n  sqrtRatioX96,\n  liquidity,\n  tickCurrent,\n  tokenIn,\n  tokenOut\n}) => new Pool(parseToken(tokenIn), parseToken(tokenOut), parseInt(fee), sqrtRatioX96, liquidity, parseInt(tickCurrent));\n\nconst parsePair = ({\n  reserve0,\n  reserve1\n}) => new Pair(CurrencyAmount.fromRawAmount(parseToken(reserve0.token), reserve0.quotient), CurrencyAmount.fromRawAmount(parseToken(reserve1.token), reserve1.quotient));\n\nfunction isV3Route(route) {\n  return route[0].type === 'v3-pool';\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/routing/utils.ts"],"names":["CurrencyAmount","Token","Pair","Route","V2Route","Pool","V3Route","nativeOnChain","InterfaceTrade","computeRoutes","currencyIn","currencyOut","tradeType","quoteResult","route","undefined","length","parsedTokenIn","parseToken","tokenIn","parsedTokenOut","tokenOut","address","wrapped","parsedCurrencyIn","isNative","chainId","parsedCurrencyOut","map","Error","rawAmountIn","amountIn","rawAmountOut","amountOut","routev3","isV3Route","parsePool","routev2","parsePair","inputAmount","fromRawAmount","outputAmount","e","console","error","transformRoutesToTrade","gasUseEstimateUSD","v2Routes","filter","r","v3Routes","decimals","symbol","parseInt","toString","fee","sqrtRatioX96","liquidity","tickCurrent","reserve0","reserve1","token","quotient","type"],"mappings":"AAAA,SAAmBA,cAAnB,EAAmCC,KAAnC,QAA2D,mBAA3D;AACA,SAASC,IAAT,EAAeC,KAAK,IAAIC,OAAxB,QAAuC,iBAAvC;AACA,SAAoBC,IAApB,EAA0BF,KAAK,IAAIG,OAAnC,QAAkD,iBAAlD;AAEA,SAASC,aAAT,QAA8B,wBAA9B;AACA,SAAyBC,cAAzB,QAA6E,SAA7E;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CACLC,UADK,EAELC,WAFK,EAGLC,SAHK,EAILC,WAJK,EAKL;AACA,MAAI,CAACA,WAAD,IAAgB,CAACA,WAAW,CAACC,KAA7B,IAAsC,CAACJ,UAAvC,IAAqD,CAACC,WAA1D,EAAuE,OAAOI,SAAP;AAEvE,MAAIF,WAAW,CAACC,KAAZ,CAAkBE,MAAlB,KAA6B,CAAjC,EAAoC,OAAO,EAAP;AAEpC,QAAMC,aAAa,GAAGC,UAAU,CAACL,WAAW,CAACC,KAAZ,CAAkB,CAAlB,EAAqB,CAArB,EAAwBK,OAAzB,CAAhC;AACA,QAAMC,cAAc,GAAGF,UAAU,CAACL,WAAW,CAACC,KAAZ,CAAkB,CAAlB,EAAqBD,WAAW,CAACC,KAAZ,CAAkB,CAAlB,EAAqBE,MAArB,GAA8B,CAAnD,EAAsDK,QAAvD,CAAjC;AAEA,MAAIJ,aAAa,CAACK,OAAd,KAA0BZ,UAAU,CAACa,OAAX,CAAmBD,OAAjD,EAA0D,OAAOP,SAAP;AAC1D,MAAIK,cAAc,CAACE,OAAf,KAA2BX,WAAW,CAACY,OAAZ,CAAoBD,OAAnD,EAA4D,OAAOP,SAAP;AAE5D,QAAMS,gBAAgB,GAAGd,UAAU,CAACe,QAAX,GAAsBlB,aAAa,CAACG,UAAU,CAACgB,OAAZ,CAAnC,GAA0DT,aAAnF;AAEA,QAAMU,iBAAiB,GAAGhB,WAAW,CAACc,QAAZ,GAAuBlB,aAAa,CAACI,WAAW,CAACe,OAAb,CAApC,GAA4DN,cAAtF;;AAEA,MAAI;AACF,WAAOP,WAAW,CAACC,KAAZ,CAAkBc,GAAlB,CAAuBd,KAAD,IAAW;AACtC,UAAIA,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACtB,cAAM,IAAIa,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACD,YAAMC,WAAW,GAAGhB,KAAK,CAAC,CAAD,CAAL,CAASiB,QAA7B;AACA,YAAMC,YAAY,GAAGlB,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAAL,CAAwBiB,SAA7C;;AAEA,UAAI,CAACH,WAAD,IAAgB,CAACE,YAArB,EAAmC;AACjC,cAAM,IAAIH,KAAJ,CAAU,oDAAV,CAAN;AACD;;AAED,aAAO;AACLK,QAAAA,OAAO,EAAEC,SAAS,CAACrB,KAAD,CAAT,GAAmB,IAAIR,OAAJ,CAAYQ,KAAK,CAACc,GAAN,CAAUQ,SAAV,CAAZ,EAAkCZ,gBAAlC,EAAoDG,iBAApD,CAAnB,GAA4F,IADhG;AAELU,QAAAA,OAAO,EAAE,CAACF,SAAS,CAACrB,KAAD,CAAV,GAAoB,IAAIV,OAAJ,CAAYU,KAAK,CAACc,GAAN,CAAUU,SAAV,CAAZ,EAAkCd,gBAAlC,EAAoDG,iBAApD,CAApB,GAA6F,IAFjG;AAGLY,QAAAA,WAAW,EAAEvC,cAAc,CAACwC,aAAf,CAA6BhB,gBAA7B,EAA+CM,WAA/C,CAHR;AAILW,QAAAA,YAAY,EAAEzC,cAAc,CAACwC,aAAf,CAA6Bb,iBAA7B,EAAgDK,YAAhD;AAJT,OAAP;AAMD,KAjBM,CAAP;AAkBD,GAnBD,CAmBE,OAAOU,CAAP,EAAU;AACV;AACA;AACA;AACAC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACA,WAAO3B,SAAP;AACD;AACF;AAED,OAAO,SAAS8B,sBAAT,CACL/B,KADK,EAELF,SAFK,EAGLkC,iBAHK,EAI2C;AAAA;;AAChD,SAAO,IAAItC,cAAJ,CAAmB;AACxBuC,IAAAA,QAAQ,uBACNjC,KADM,aACNA,KADM,uBACNA,KAAK,CACDkC,MADJ,CACYC,CAAD,IAAoFA,CAAC,CAACZ,OAAF,KAAc,IAD7G,EAEGT,GAFH,CAEO,CAAC;AAAES,MAAAA,OAAF;AAAWE,MAAAA,WAAX;AAAwBE,MAAAA;AAAxB,KAAD,MAA6C;AAAEJ,MAAAA,OAAF;AAAWE,MAAAA,WAAX;AAAwBE,MAAAA;AAAxB,KAA7C,CAFP,CADM,iEAG0F,EAJ1E;AAKxBS,IAAAA,QAAQ,wBACNpC,KADM,aACNA,KADM,uBACNA,KAAK,CACDkC,MADJ,CACYC,CAAD,IAAoFA,CAAC,CAACf,OAAF,KAAc,IAD7G,EAEGN,GAFH,CAEO,CAAC;AAAEM,MAAAA,OAAF;AAAWK,MAAAA,WAAX;AAAwBE,MAAAA;AAAxB,KAAD,MAA6C;AAAEP,MAAAA,OAAF;AAAWK,MAAAA,WAAX;AAAwBE,MAAAA;AAAxB,KAA7C,CAFP,CADM,mEAG0F,EAR1E;AASxB7B,IAAAA,SATwB;AAUxBkC,IAAAA;AAVwB,GAAnB,CAAP;AAYD;;AAED,MAAM5B,UAAU,GAAG,CAAC;AAAEI,EAAAA,OAAF;AAAWI,EAAAA,OAAX;AAAoByB,EAAAA,QAApB;AAA8BC,EAAAA;AAA9B,CAAD,KAA6F;AAC9G,SAAO,IAAInD,KAAJ,CAAUyB,OAAV,EAAmBJ,OAAnB,EAA4B+B,QAAQ,CAACF,QAAQ,CAACG,QAAT,EAAD,CAApC,EAA2DF,MAA3D,CAAP;AACD,CAFD;;AAIA,MAAMhB,SAAS,GAAG,CAAC;AAAEmB,EAAAA,GAAF;AAAOC,EAAAA,YAAP;AAAqBC,EAAAA,SAArB;AAAgCC,EAAAA,WAAhC;AAA6CvC,EAAAA,OAA7C;AAAsDE,EAAAA;AAAtD,CAAD,KAChB,IAAIhB,IAAJ,CACEa,UAAU,CAACC,OAAD,CADZ,EAEED,UAAU,CAACG,QAAD,CAFZ,EAGEgC,QAAQ,CAACE,GAAD,CAHV,EAIEC,YAJF,EAKEC,SALF,EAMEJ,QAAQ,CAACK,WAAD,CANV,CADF;;AAUA,MAAMpB,SAAS,GAAG,CAAC;AAAEqB,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAAD,KAChB,IAAI1D,IAAJ,CACEF,cAAc,CAACwC,aAAf,CAA6BtB,UAAU,CAACyC,QAAQ,CAACE,KAAV,CAAvC,EAAyDF,QAAQ,CAACG,QAAlE,CADF,EAEE9D,cAAc,CAACwC,aAAf,CAA6BtB,UAAU,CAAC0C,QAAQ,CAACC,KAAV,CAAvC,EAAyDD,QAAQ,CAACE,QAAlE,CAFF,CADF;;AAMA,SAAS3B,SAAT,CAAmBrB,KAAnB,EAAuF;AACrF,SAAOA,KAAK,CAAC,CAAD,CAAL,CAASiD,IAAT,KAAkB,SAAzB;AACD","sourcesContent":["import { Currency, CurrencyAmount, Token, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2Route } from '@uniswap/v2-sdk'\nimport { FeeAmount, Pool, Route as V3Route } from '@uniswap/v3-sdk'\n\nimport { nativeOnChain } from '../../constants/tokens'\nimport { GetQuoteResult, InterfaceTrade, V2PoolInRoute, V3PoolInRoute } from './types'\n\n/**\n * Transforms a Routing API quote into an array of routes that can be used to create\n * a `Trade`.\n */\nexport function computeRoutes(\n  currencyIn: Currency | undefined,\n  currencyOut: Currency | undefined,\n  tradeType: TradeType,\n  quoteResult: Pick<GetQuoteResult, 'route'> | undefined\n) {\n  if (!quoteResult || !quoteResult.route || !currencyIn || !currencyOut) return undefined\n\n  if (quoteResult.route.length === 0) return []\n\n  const parsedTokenIn = parseToken(quoteResult.route[0][0].tokenIn)\n  const parsedTokenOut = parseToken(quoteResult.route[0][quoteResult.route[0].length - 1].tokenOut)\n\n  if (parsedTokenIn.address !== currencyIn.wrapped.address) return undefined\n  if (parsedTokenOut.address !== currencyOut.wrapped.address) return undefined\n\n  const parsedCurrencyIn = currencyIn.isNative ? nativeOnChain(currencyIn.chainId) : parsedTokenIn\n\n  const parsedCurrencyOut = currencyOut.isNative ? nativeOnChain(currencyOut.chainId) : parsedTokenOut\n\n  try {\n    return quoteResult.route.map((route) => {\n      if (route.length === 0) {\n        throw new Error('Expected route to have at least one pair or pool')\n      }\n      const rawAmountIn = route[0].amountIn\n      const rawAmountOut = route[route.length - 1].amountOut\n\n      if (!rawAmountIn || !rawAmountOut) {\n        throw new Error('Expected both amountIn and amountOut to be present')\n      }\n\n      return {\n        routev3: isV3Route(route) ? new V3Route(route.map(parsePool), parsedCurrencyIn, parsedCurrencyOut) : null,\n        routev2: !isV3Route(route) ? new V2Route(route.map(parsePair), parsedCurrencyIn, parsedCurrencyOut) : null,\n        inputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyIn, rawAmountIn),\n        outputAmount: CurrencyAmount.fromRawAmount(parsedCurrencyOut, rawAmountOut),\n      }\n    })\n  } catch (e) {\n    // `Route` constructor may throw if inputs/outputs are temporarily out of sync\n    // (RTK-Query always returns the latest data which may not be the right inputs/outputs)\n    // This is not fatal and will fix itself in future render cycles\n    console.error(e)\n    return undefined\n  }\n}\n\nexport function transformRoutesToTrade<TTradeType extends TradeType>(\n  route: ReturnType<typeof computeRoutes>,\n  tradeType: TTradeType,\n  gasUseEstimateUSD?: CurrencyAmount<Token> | null\n): InterfaceTrade<Currency, Currency, TTradeType> {\n  return new InterfaceTrade({\n    v2Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev2: NonNullable<typeof route[0]['routev2']> } => r.routev2 !== null)\n        .map(({ routev2, inputAmount, outputAmount }) => ({ routev2, inputAmount, outputAmount })) ?? [],\n    v3Routes:\n      route\n        ?.filter((r): r is typeof route[0] & { routev3: NonNullable<typeof route[0]['routev3']> } => r.routev3 !== null)\n        .map(({ routev3, inputAmount, outputAmount }) => ({ routev3, inputAmount, outputAmount })) ?? [],\n    tradeType,\n    gasUseEstimateUSD,\n  })\n}\n\nconst parseToken = ({ address, chainId, decimals, symbol }: GetQuoteResult['route'][0][0]['tokenIn']): Token => {\n  return new Token(chainId, address, parseInt(decimals.toString()), symbol)\n}\n\nconst parsePool = ({ fee, sqrtRatioX96, liquidity, tickCurrent, tokenIn, tokenOut }: V3PoolInRoute): Pool =>\n  new Pool(\n    parseToken(tokenIn),\n    parseToken(tokenOut),\n    parseInt(fee) as FeeAmount,\n    sqrtRatioX96,\n    liquidity,\n    parseInt(tickCurrent)\n  )\n\nconst parsePair = ({ reserve0, reserve1 }: V2PoolInRoute): Pair =>\n  new Pair(\n    CurrencyAmount.fromRawAmount(parseToken(reserve0.token), reserve0.quotient),\n    CurrencyAmount.fromRawAmount(parseToken(reserve1.token), reserve1.quotient)\n  )\n\nfunction isV3Route(route: V3PoolInRoute[] | V2PoolInRoute[]): route is V3PoolInRoute[] {\n  return route[0].type === 'v3-pool'\n}\n"]},"metadata":{},"sourceType":"module"}