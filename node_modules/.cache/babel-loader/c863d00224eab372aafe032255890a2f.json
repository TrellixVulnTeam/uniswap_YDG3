{"ast":null,"code":"/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function (size) {\n  var maxIndex = size - 1;\n  if (maxIndex <= MAX_8BIT_INTEGER) return Uint8Array;\n  if (maxIndex <= MAX_16BIT_INTEGER) return Uint16Array;\n  if (maxIndex <= MAX_32BIT_INTEGER) return Uint32Array;\n  return Float64Array;\n};\n\nexports.getSignedPointerArray = function (size) {\n  var maxIndex = size - 1;\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER) return Int8Array;\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER) return Int16Array;\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER) return Int32Array;\n  return Float64Array;\n};\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\n\n\nexports.getNumberType = function (value) {\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128) return Int8Array;\n      if (value <= 32767 && value >= -32768) return Int16Array;\n      return Int32Array;\n    } else {\n      if (value <= 255) return Uint8Array;\n      if (value <= 65535) return Uint16Array;\n      return Uint32Array;\n    }\n  } // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n\n\n  return Float64Array;\n};\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\n\n\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n}; // TODO: make this a one-shot for one value\n\nexports.getMinimalRepresentation = function (array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\n\n\nexports.isTypedArray = function (value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\n\n\nexports.concat = function () {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++) length += arguments[i].length;\n\n  var array = new arguments[0].constructor(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\n\n\nexports.indices = function (length) {\n  var PointerArray = exports.getPointerArray(length);\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++) array[i] = i;\n\n  return array;\n};","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/utils/typed-arrays.js"],"names":["MAX_8BIT_INTEGER","Math","pow","MAX_16BIT_INTEGER","MAX_32BIT_INTEGER","MAX_SIGNED_8BIT_INTEGER","MAX_SIGNED_16BIT_INTEGER","MAX_SIGNED_32BIT_INTEGER","exports","getPointerArray","size","maxIndex","Uint8Array","Uint16Array","Uint32Array","Float64Array","getSignedPointerArray","Int8Array","Int16Array","Int32Array","getNumberType","value","sign","TYPE_PRIORITY","Float32Array","getMinimalRepresentation","array","getter","maxType","maxPriority","p","t","v","i","l","length","name","isTypedArray","ArrayBuffer","isView","concat","o","arguments","constructor","set","indices","PointerArray"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  return Float64Array;\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n"]},"metadata":{},"sourceType":"script"}