{"ast":null,"code":"/**\n * Mnemonist BitSet\n * =================\n *\n * JavaScript implementation of a fixed-size BitSet based upon a Uint32Array.\n *\n * Notes:\n *   - (i >> 5) is the same as ((i / 32) | 0)\n *   - (i & 0x0000001f) is the same as (i % 32)\n *   - I could use a Float64Array to store more in less blocks but I would lose\n *     the benefits of byte comparison to keep track of size without popcounts.\n */\nvar Iterator = require('obliterator/iterator'),\n    bitwise = require('./utils/bitwise.js');\n/**\n * BitSet.\n *\n * @constructor\n */\n\n\nfunction BitSet(length) {\n  // Properties\n  this.length = length;\n  this.clear(); // Methods\n  // Statics\n}\n/**\n * Method used to clear the bit set.\n *\n * @return {undefined}\n */\n\n\nBitSet.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n  this.array = new Uint32Array(Math.ceil(this.length / 32));\n};\n/**\n * Method used to set the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @param  {number} value - Value to set.\n * @return {BitSet}\n */\n\n\nBitSet.prototype.set = function (index, value) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n  if (value === 0 || value === false) newBytes = this.array[byteIndex] &= ~(1 << pos);else newBytes = this.array[byteIndex] |= 1 << pos; // The operands of all bitwise operators are converted to *signed* 32-bit integers.\n  // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n  // Shifting by 31 changes the sign (i.e. 1 << 31 = -2147483648).\n  // Therefore, get unsigned representation by applying '>>> 0'.\n\n  newBytes = newBytes >>> 0; // Updating size\n\n  if (newBytes > oldBytes) this.size++;else if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n* Method used to reset the given bit's value.\n*\n* @param  {number} index - Target bit index.\n* @return {BitSet}\n*/\n\n\nBitSet.prototype.reset = function (index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n  newBytes = this.array[byteIndex] &= ~(1 << pos); // Updating size\n\n  if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n * Method used to flip the value of the given bit.\n *\n * @param  {number} index - Target bit index.\n * @return {BitSet}\n */\n\n\nBitSet.prototype.flip = function (index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex];\n  var newBytes = this.array[byteIndex] ^= 1 << pos; // Get unsigned representation.\n\n  newBytes = newBytes >>> 0; // Updating size\n\n  if (newBytes > oldBytes) this.size++;else if (newBytes < oldBytes) this.size--;\n  return this;\n};\n/**\n * Method used to get the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {number}\n */\n\n\nBitSet.prototype.get = function (index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n  return this.array[byteIndex] >> pos & 1;\n};\n/**\n * Method used to test the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {BitSet}\n */\n\n\nBitSet.prototype.test = function (index) {\n  return Boolean(this.get(index));\n};\n/**\n * Method used to return the number of 1 from the beginning of the set up to\n * the ith index.\n *\n * @param  {number} i - Ith index (cannot be > length).\n * @return {number}\n */\n\n\nBitSet.prototype.rank = function (i) {\n  if (this.size === 0) return 0;\n  var byteIndex = i >> 5,\n      pos = i & 0x0000001f,\n      r = 0; // Accessing the bytes before the last one\n\n  for (var j = 0; j < byteIndex; j++) r += bitwise.table8Popcount(this.array[j]); // Handling masked last byte\n\n\n  var maskedByte = this.array[byteIndex] & (1 << pos) - 1;\n  r += bitwise.table8Popcount(maskedByte);\n  return r;\n};\n/**\n * Method used to return the position of the rth 1 in the set or -1 if the\n * set is empty.\n *\n * Note: usually select is implemented using binary search over rank but I\n * tend to think the following linear implementation is faster since here\n * rank is O(n) anyway.\n *\n * @param  {number} r - Rth 1 to select (should be < length).\n * @return {number}\n */\n\n\nBitSet.prototype.select = function (r) {\n  if (this.size === 0) return -1; // TODO: throw?\n\n  if (r >= this.length) return -1;\n  var byte,\n      b = 32,\n      p = 0,\n      c = 0;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i]; // The byte is empty, let's continue\n\n    if (byte === 0) continue; // TODO: This branching might not be useful here\n\n    if (i === l - 1) b = this.length % 32 || 32; // TODO: popcount should speed things up here\n\n    for (var j = 0; j < b; j++, p++) {\n      c += byte >> j & 1;\n      if (c === r) return p;\n    }\n  }\n};\n/**\n * Method used to iterate over the bit set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nBitSet.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var length = this.length,\n      byte,\n      bit,\n      b = 32;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n    if (i === l - 1) b = length % 32 || 32;\n\n    for (var j = 0; j < b; j++) {\n      bit = byte >> j & 1;\n      callback.call(scope, bit, i * 32 + j);\n    }\n  }\n};\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\n\n\nBitSet.prototype.values = function () {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n  return new Iterator(function next() {\n    if (!inner) {\n      if (i >= l) return {\n        done: true\n      };\n      if (i === l - 1) b = length % 32 || 32;\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = byte >> j & 1;\n    return {\n      value: bit\n    };\n  });\n};\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\n\n\nBitSet.prototype.entries = function () {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      index,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n  return new Iterator(function next() {\n    if (!inner) {\n      if (i >= l) return {\n        done: true\n      };\n      if (i === l - 1) b = length % 32 || 32;\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n    index = ~-i * 32 + j;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = byte >> j & 1;\n    return {\n      value: [index, bit]\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') BitSet.prototype[Symbol.iterator] = BitSet.prototype.values;\n/**\n * Convenience known methods.\n */\n\nBitSet.prototype.inspect = function () {\n  var proxy = new Uint8Array(this.length);\n  this.forEach(function (bit, i) {\n    proxy[i] = bit;\n  }); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: BitSet,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') BitSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = BitSet.prototype.inspect;\n\nBitSet.prototype.toJSON = function () {\n  return Array.from(this.array);\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = BitSet;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/bit-set.js"],"names":["Iterator","require","bitwise","BitSet","length","clear","prototype","size","array","Uint32Array","Math","ceil","set","index","value","byteIndex","pos","oldBytes","newBytes","reset","flip","get","test","Boolean","rank","i","r","j","table8Popcount","maskedByte","select","byte","b","p","c","l","forEach","callback","scope","arguments","bit","call","values","inner","next","done","entries","Symbol","iterator","inspect","proxy","Uint8Array","Object","defineProperty","enumerable","for","toJSON","Array","from","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist BitSet\n * =================\n *\n * JavaScript implementation of a fixed-size BitSet based upon a Uint32Array.\n *\n * Notes:\n *   - (i >> 5) is the same as ((i / 32) | 0)\n *   - (i & 0x0000001f) is the same as (i % 32)\n *   - I could use a Float64Array to store more in less blocks but I would lose\n *     the benefits of byte comparison to keep track of size without popcounts.\n */\nvar Iterator = require('obliterator/iterator'),\n    bitwise = require('./utils/bitwise.js');\n\n/**\n * BitSet.\n *\n * @constructor\n */\nfunction BitSet(length) {\n\n  // Properties\n  this.length = length;\n  this.clear();\n\n  // Methods\n\n  // Statics\n}\n\n/**\n * Method used to clear the bit set.\n *\n * @return {undefined}\n */\nBitSet.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n  this.array = new Uint32Array(Math.ceil(this.length / 32));\n};\n\n/**\n * Method used to set the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @param  {number} value - Value to set.\n * @return {BitSet}\n */\nBitSet.prototype.set = function(index, value) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n\n  if (value === 0 || value === false)\n    newBytes = this.array[byteIndex] &= ~(1 << pos);\n  else\n    newBytes = this.array[byteIndex] |= (1 << pos);\n\n  // The operands of all bitwise operators are converted to *signed* 32-bit integers.\n  // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n  // Shifting by 31 changes the sign (i.e. 1 << 31 = -2147483648).\n  // Therefore, get unsigned representation by applying '>>> 0'.\n  newBytes = newBytes >>> 0;\n\n  // Updating size\n  if (newBytes > oldBytes)\n    this.size++;\n  else if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n* Method used to reset the given bit's value.\n*\n* @param  {number} index - Target bit index.\n* @return {BitSet}\n*/\nBitSet.prototype.reset = function(index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex],\n      newBytes;\n\n  newBytes = this.array[byteIndex] &= ~(1 << pos);\n\n  // Updating size\n  if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n * Method used to flip the value of the given bit.\n *\n * @param  {number} index - Target bit index.\n * @return {BitSet}\n */\nBitSet.prototype.flip = function(index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f,\n      oldBytes = this.array[byteIndex];\n\n  var newBytes = this.array[byteIndex] ^= (1 << pos);\n\n  // Get unsigned representation.\n  newBytes = newBytes >>> 0;\n\n  // Updating size\n  if (newBytes > oldBytes)\n    this.size++;\n  else if (newBytes < oldBytes)\n    this.size--;\n\n  return this;\n};\n\n/**\n * Method used to get the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {number}\n */\nBitSet.prototype.get = function(index) {\n  var byteIndex = index >> 5,\n      pos = index & 0x0000001f;\n\n  return (this.array[byteIndex] >> pos) & 1;\n};\n\n/**\n * Method used to test the given bit's value.\n *\n * @param  {number} index - Target bit index.\n * @return {BitSet}\n */\nBitSet.prototype.test = function(index) {\n  return Boolean(this.get(index));\n};\n\n/**\n * Method used to return the number of 1 from the beginning of the set up to\n * the ith index.\n *\n * @param  {number} i - Ith index (cannot be > length).\n * @return {number}\n */\nBitSet.prototype.rank = function(i) {\n  if (this.size === 0)\n    return 0;\n\n  var byteIndex = i >> 5,\n      pos = i & 0x0000001f,\n      r = 0;\n\n  // Accessing the bytes before the last one\n  for (var j = 0; j < byteIndex; j++)\n    r += bitwise.table8Popcount(this.array[j]);\n\n  // Handling masked last byte\n  var maskedByte = this.array[byteIndex] & ((1 << pos) - 1);\n\n  r += bitwise.table8Popcount(maskedByte);\n\n  return r;\n};\n\n/**\n * Method used to return the position of the rth 1 in the set or -1 if the\n * set is empty.\n *\n * Note: usually select is implemented using binary search over rank but I\n * tend to think the following linear implementation is faster since here\n * rank is O(n) anyway.\n *\n * @param  {number} r - Rth 1 to select (should be < length).\n * @return {number}\n */\nBitSet.prototype.select = function(r) {\n  if (this.size === 0)\n    return -1;\n\n  // TODO: throw?\n  if (r >= this.length)\n    return -1;\n\n  var byte,\n      b = 32,\n      p = 0,\n      c = 0;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n\n    // The byte is empty, let's continue\n    if (byte === 0)\n      continue;\n\n    // TODO: This branching might not be useful here\n    if (i === l - 1)\n      b = this.length % 32 || 32;\n\n    // TODO: popcount should speed things up here\n\n    for (var j = 0; j < b; j++, p++) {\n      c += (byte >> j) & 1;\n\n      if (c === r)\n        return p;\n    }\n  }\n};\n\n/**\n * Method used to iterate over the bit set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nBitSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var length = this.length,\n      byte,\n      bit,\n      b = 32;\n\n  for (var i = 0, l = this.array.length; i < l; i++) {\n    byte = this.array[i];\n\n    if (i === l - 1)\n      b = length % 32 || 32;\n\n    for (var j = 0; j < b; j++) {\n      bit = (byte >> j) & 1;\n\n      callback.call(scope, bit, i * 32 + j);\n    }\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nBitSet.prototype.values = function() {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n\n  return new Iterator(function next() {\n    if (!inner) {\n\n      if (i >= l)\n        return {\n          done: true\n        };\n\n      if (i === l - 1)\n        b = length % 32 || 32;\n\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = (byte >> j) & 1;\n\n    return {\n      value: bit\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a set's entries.\n *\n * @return {Iterator}\n */\nBitSet.prototype.entries = function() {\n  var length = this.length,\n      inner = false,\n      byte,\n      bit,\n      array = this.array,\n      index,\n      l = array.length,\n      i = 0,\n      j = -1,\n      b = 32;\n\n  return new Iterator(function next() {\n    if (!inner) {\n\n      if (i >= l)\n        return {\n          done: true\n        };\n\n      if (i === l - 1)\n        b = length % 32 || 32;\n\n      byte = array[i++];\n      inner = true;\n      j = -1;\n    }\n\n    j++;\n    index = (~-i) * 32 + j;\n\n    if (j >= b) {\n      inner = false;\n      return next();\n    }\n\n    bit = (byte >> j) & 1;\n\n    return {\n      value: [index, bit]\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  BitSet.prototype[Symbol.iterator] = BitSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nBitSet.prototype.inspect = function() {\n  var proxy = new Uint8Array(this.length);\n\n  this.forEach(function(bit, i) {\n    proxy[i] = bit;\n  });\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: BitSet,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  BitSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = BitSet.prototype.inspect;\n\nBitSet.prototype.toJSON = function() {\n  return Array.from(this.array);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = BitSet;\n"]},"metadata":{},"sourceType":"script"}