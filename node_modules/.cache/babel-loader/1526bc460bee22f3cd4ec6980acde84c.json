{"ast":null,"code":"/**\n * Mnemonist SparseQueueSet\n * =========================\n *\n * JavaScript sparse queue set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n/**\n * SparseQueueSet.\n *\n * @constructor\n */\n\n\nfunction SparseQueueSet(capacity) {\n  var ByteArray = getPointerArray(capacity); // Properties\n\n  this.start = 0;\n  this.size = 0;\n  this.capacity = capacity;\n  this.dense = new ByteArray(capacity);\n  this.sparse = new ByteArray(capacity);\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nSparseQueueSet.prototype.clear = function () {\n  this.start = 0;\n  this.size = 0;\n};\n/**\n * Method used to check the existence of a member in the queue.\n *\n * @param  {number} member - Member to test.\n * @return {SparseQueueSet}\n */\n\n\nSparseQueueSet.prototype.has = function (member) {\n  if (this.size === 0) return false;\n  var index = this.sparse[member];\n  var inBounds = index < this.capacity && index >= this.start && index < this.start + this.size || index < (this.start + this.size) % this.capacity;\n  return inBounds && this.dense[index] === member;\n};\n/**\n * Method used to add a member to the queue.\n *\n * @param  {number} member - Member to add.\n * @return {SparseQueueSet}\n */\n\n\nSparseQueueSet.prototype.enqueue = function (member) {\n  var index = this.sparse[member];\n\n  if (this.size !== 0) {\n    var inBounds = index < this.capacity && index >= this.start && index < this.start + this.size || index < (this.start + this.size) % this.capacity;\n    if (inBounds && this.dense[index] === member) return this;\n  }\n\n  index = (this.start + this.size) % this.capacity;\n  this.dense[index] = member;\n  this.sparse[member] = index;\n  this.size++;\n  return this;\n};\n/**\n * Method used to remove the next member from the queue.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\n\n\nSparseQueueSet.prototype.dequeue = function () {\n  if (this.size === 0) return;\n  var index = this.start;\n  this.size--;\n  this.start++;\n  if (this.start === this.capacity) this.start = 0;\n  var member = this.dense[index];\n  this.sparse[member] = this.capacity;\n  return member;\n};\n/**\n * Method used to iterate over the queue's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nSparseQueueSet.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.dense[i], j, this);\n    i++;\n    j++;\n    if (i === c) i = 0;\n  }\n};\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\n\n\nSparseQueueSet.prototype.values = function () {\n  var dense = this.dense,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n  return new Iterator(function () {\n    if (j >= l) return {\n      done: true\n    };\n    var value = dense[i];\n    i++;\n    j++;\n    if (i === c) i = 0;\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') SparseQueueSet.prototype[Symbol.iterator] = SparseQueueSet.prototype.values;\n/**\n * Convenience known methods.\n */\n\nSparseQueueSet.prototype.inspect = function () {\n  var proxy = [];\n  this.forEach(function (member) {\n    proxy.push(member);\n  }); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseQueueSet,\n    enumerable: false\n  });\n  proxy.capacity = this.capacity;\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') SparseQueueSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseQueueSet.prototype.inspect;\n/**\n * Exporting.\n */\n\nmodule.exports = SparseQueueSet;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/sparse-queue-set.js"],"names":["Iterator","require","getPointerArray","SparseQueueSet","capacity","ByteArray","start","size","dense","sparse","prototype","clear","has","member","index","inBounds","enqueue","dequeue","forEach","callback","scope","arguments","length","c","l","i","j","call","values","done","value","Symbol","iterator","inspect","proxy","push","Object","defineProperty","enumerable","for","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAtB;AAAA,IACIC,eAAe,GAAGD,OAAO,CAAC,yBAAD,CAAP,CAAmCC,eADzD;AAGA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AAEhC,MAAIC,SAAS,GAAGH,eAAe,CAACE,QAAD,CAA/B,CAFgC,CAIhC;;AACA,OAAKE,KAAL,GAAa,CAAb;AACA,OAAKC,IAAL,GAAY,CAAZ;AACA,OAAKH,QAAL,GAAgBA,QAAhB;AACA,OAAKI,KAAL,GAAa,IAAIH,SAAJ,CAAcD,QAAd,CAAb;AACA,OAAKK,MAAL,GAAc,IAAIJ,SAAJ,CAAcD,QAAd,CAAd;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAD,cAAc,CAACO,SAAf,CAAyBC,KAAzB,GAAiC,YAAW;AAC1C,OAAKL,KAAL,GAAa,CAAb;AACA,OAAKC,IAAL,GAAY,CAAZ;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,cAAc,CAACO,SAAf,CAAyBE,GAAzB,GAA+B,UAASC,MAAT,EAAiB;AAC9C,MAAI,KAAKN,IAAL,KAAc,CAAlB,EACE,OAAO,KAAP;AAEF,MAAIO,KAAK,GAAG,KAAKL,MAAL,CAAYI,MAAZ,CAAZ;AAEA,MAAIE,QAAQ,GACVD,KAAK,GAAG,KAAKV,QAAb,IAEEU,KAAK,IAAI,KAAKR,KAAd,IACAQ,KAAK,GAAG,KAAKR,KAAL,GAAa,KAAKC,IAH5B,IAMEO,KAAK,GAAI,CAAC,KAAKR,KAAL,GAAa,KAAKC,IAAnB,IAA2B,KAAKH,QAP7C;AAWA,SACEW,QAAQ,IACR,KAAKP,KAAL,CAAWM,KAAX,MAAsBD,MAFxB;AAID,CArBD;AAuBA;AACA;AACA;AACA;AACA;AACA;;;AACAV,cAAc,CAACO,SAAf,CAAyBM,OAAzB,GAAmC,UAASH,MAAT,EAAiB;AAClD,MAAIC,KAAK,GAAG,KAAKL,MAAL,CAAYI,MAAZ,CAAZ;;AAEA,MAAI,KAAKN,IAAL,KAAc,CAAlB,EAAqB;AACnB,QAAIQ,QAAQ,GACVD,KAAK,GAAG,KAAKV,QAAb,IAEEU,KAAK,IAAI,KAAKR,KAAd,IACAQ,KAAK,GAAG,KAAKR,KAAL,GAAa,KAAKC,IAH5B,IAMEO,KAAK,GAAI,CAAC,KAAKR,KAAL,GAAa,KAAKC,IAAnB,IAA2B,KAAKH,QAP7C;AAWA,QAAIW,QAAQ,IAAI,KAAKP,KAAL,CAAWM,KAAX,MAAsBD,MAAtC,EACE,OAAO,IAAP;AACH;;AAEDC,EAAAA,KAAK,GAAG,CAAC,KAAKR,KAAL,GAAa,KAAKC,IAAnB,IAA2B,KAAKH,QAAxC;AAEA,OAAKI,KAAL,CAAWM,KAAX,IAAoBD,MAApB;AACA,OAAKJ,MAAL,CAAYI,MAAZ,IAAsBC,KAAtB;AACA,OAAKP,IAAL;AAEA,SAAO,IAAP;AACD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,cAAc,CAACO,SAAf,CAAyBO,OAAzB,GAAmC,YAAW;AAC5C,MAAI,KAAKV,IAAL,KAAc,CAAlB,EACE;AAEF,MAAIO,KAAK,GAAG,KAAKR,KAAjB;AAEA,OAAKC,IAAL;AACA,OAAKD,KAAL;AAEA,MAAI,KAAKA,KAAL,KAAe,KAAKF,QAAxB,EACE,KAAKE,KAAL,GAAa,CAAb;AAEF,MAAIO,MAAM,GAAG,KAAKL,KAAL,CAAWM,KAAX,CAAb;AAEA,OAAKL,MAAL,CAAYI,MAAZ,IAAsB,KAAKT,QAA3B;AAEA,SAAOS,MAAP;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAV,cAAc,CAACO,SAAf,CAAyBQ,OAAzB,GAAmC,UAASC,QAAT,EAAmBC,KAAnB,EAA0B;AAC3DA,EAAAA,KAAK,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,GAAuBF,KAAvB,GAA+B,IAAvC;AAEA,MAAIG,CAAC,GAAG,KAAKnB,QAAb;AAAA,MACIoB,CAAC,GAAG,KAAKjB,IADb;AAAA,MAEIkB,CAAC,GAAG,KAAKnB,KAFb;AAAA,MAGIoB,CAAC,GAAG,CAHR;;AAKA,SAAOA,CAAC,GAAGF,CAAX,EAAc;AACZL,IAAAA,QAAQ,CAACQ,IAAT,CAAcP,KAAd,EAAqB,KAAKZ,KAAL,CAAWiB,CAAX,CAArB,EAAoCC,CAApC,EAAuC,IAAvC;AACAD,IAAAA,CAAC;AACDC,IAAAA,CAAC;AAED,QAAID,CAAC,KAAKF,CAAV,EACEE,CAAC,GAAG,CAAJ;AACH;AACF,CAhBD;AAkBA;AACA;AACA;AACA;AACA;;;AACAtB,cAAc,CAACO,SAAf,CAAyBkB,MAAzB,GAAkC,YAAW;AAC3C,MAAIpB,KAAK,GAAG,KAAKA,KAAjB;AAAA,MACIe,CAAC,GAAG,KAAKnB,QADb;AAAA,MAEIoB,CAAC,GAAG,KAAKjB,IAFb;AAAA,MAGIkB,CAAC,GAAG,KAAKnB,KAHb;AAAA,MAIIoB,CAAC,GAAG,CAJR;AAMA,SAAO,IAAI1B,QAAJ,CAAa,YAAW;AAC7B,QAAI0B,CAAC,IAAIF,CAAT,EACE,OAAO;AACLK,MAAAA,IAAI,EAAE;AADD,KAAP;AAIF,QAAIC,KAAK,GAAGtB,KAAK,CAACiB,CAAD,CAAjB;AAEAA,IAAAA,CAAC;AACDC,IAAAA,CAAC;AAED,QAAID,CAAC,KAAKF,CAAV,EACEE,CAAC,GAAG,CAAJ;AAEF,WAAO;AACLK,MAAAA,KAAK,EAAEA,KADF;AAELD,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID,GAlBM,CAAP;AAmBD,CA1BD;AA4BA;AACA;AACA;;;AACA,IAAI,OAAOE,MAAP,KAAkB,WAAtB,EACE5B,cAAc,CAACO,SAAf,CAAyBqB,MAAM,CAACC,QAAhC,IAA4C7B,cAAc,CAACO,SAAf,CAAyBkB,MAArE;AAEF;AACA;AACA;;AACAzB,cAAc,CAACO,SAAf,CAAyBuB,OAAzB,GAAmC,YAAW;AAC5C,MAAIC,KAAK,GAAG,EAAZ;AAEA,OAAKhB,OAAL,CAAa,UAASL,MAAT,EAAiB;AAC5BqB,IAAAA,KAAK,CAACC,IAAN,CAAWtB,MAAX;AACD,GAFD,EAH4C,CAO5C;;AACAuB,EAAAA,MAAM,CAACC,cAAP,CAAsBH,KAAtB,EAA6B,aAA7B,EAA4C;AAC1CJ,IAAAA,KAAK,EAAE3B,cADmC;AAE1CmC,IAAAA,UAAU,EAAE;AAF8B,GAA5C;AAKAJ,EAAAA,KAAK,CAAC9B,QAAN,GAAiB,KAAKA,QAAtB;AAEA,SAAO8B,KAAP;AACD,CAhBD;;AAkBA,IAAI,OAAOH,MAAP,KAAkB,WAAtB,EACE5B,cAAc,CAACO,SAAf,CAAyBqB,MAAM,CAACQ,GAAP,CAAW,4BAAX,CAAzB,IAAqEpC,cAAc,CAACO,SAAf,CAAyBuB,OAA9F;AAEF;AACA;AACA;;AACAO,MAAM,CAACC,OAAP,GAAiBtC,cAAjB","sourcesContent":["/**\n * Mnemonist SparseQueueSet\n * =========================\n *\n * JavaScript sparse queue set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseQueueSet.\n *\n * @constructor\n */\nfunction SparseQueueSet(capacity) {\n\n  var ByteArray = getPointerArray(capacity);\n\n  // Properties\n  this.start = 0;\n  this.size = 0;\n  this.capacity = capacity;\n  this.dense = new ByteArray(capacity);\n  this.sparse = new ByteArray(capacity);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseQueueSet.prototype.clear = function() {\n  this.start = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the queue.\n *\n * @param  {number} member - Member to test.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.has = function(member) {\n  if (this.size === 0)\n    return false;\n\n  var index = this.sparse[member];\n\n  var inBounds = (\n    index < this.capacity &&\n    (\n      index >= this.start &&\n      index < this.start + this.size\n    ) ||\n    (\n      index < ((this.start + this.size) % this.capacity)\n    )\n  );\n\n  return (\n    inBounds &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to add a member to the queue.\n *\n * @param  {number} member - Member to add.\n * @return {SparseQueueSet}\n */\nSparseQueueSet.prototype.enqueue = function(member) {\n  var index = this.sparse[member];\n\n  if (this.size !== 0) {\n    var inBounds = (\n      index < this.capacity &&\n      (\n        index >= this.start &&\n        index < this.start + this.size\n      ) ||\n      (\n        index < ((this.start + this.size) % this.capacity)\n      )\n    );\n\n    if (inBounds && this.dense[index] === member)\n      return this;\n  }\n\n  index = (this.start + this.size) % this.capacity;\n\n  this.dense[index] = member;\n  this.sparse[member] = index;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove the next member from the queue.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseQueueSet.prototype.dequeue = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start;\n\n  this.size--;\n  this.start++;\n\n  if (this.start === this.capacity)\n    this.start = 0;\n\n  var member = this.dense[index];\n\n  this.sparse[member] = this.capacity;\n\n  return member;\n};\n\n/**\n * Method used to iterate over the queue's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseQueueSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.dense[i], j, this);\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseQueueSet.prototype.values = function() {\n  var dense = this.dense,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = dense[i];\n\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.iterator] = SparseQueueSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nSparseQueueSet.prototype.inspect = function() {\n  var proxy = [];\n\n  this.forEach(function(member) {\n    proxy.push(member);\n  });\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseQueueSet,\n    enumerable: false\n  });\n\n  proxy.capacity = this.capacity;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseQueueSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseQueueSet.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseQueueSet;\n"]},"metadata":{},"sourceType":"script"}