{"ast":null,"code":"/**\n * Mnemonist MultiSet\n * ====================\n *\n * JavaScript implementation of a MultiSet.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    FixedReverseHeap = require('./fixed-reverse-heap.js');\n/**\n * Helpers.\n */\n\n\nvar MULTISET_ITEM_COMPARATOR = function (a, b) {\n  if (a[1] > b[1]) return -1;\n  if (a[1] < b[1]) return 1;\n  return 0;\n}; // TODO: helper functions: union, intersection, sum, difference, subtract\n\n/**\n * MultiSet.\n *\n * @constructor\n */\n\n\nfunction MultiSet() {\n  this.items = new Map();\n  Object.defineProperty(this.items, 'constructor', {\n    value: MultiSet,\n    enumerable: false\n  });\n  this.clear();\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nMultiSet.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n  this.dimension = 0;\n  this.items.clear();\n};\n/**\n * Method used to add an item to the set.\n *\n * @param  {any}    item  - Item to add.\n * @param  {number} count - Optional count.\n * @return {MultiSet}\n */\n\n\nMultiSet.prototype.add = function (item, count) {\n  if (count === 0) return this;\n  if (count < 0) return this.remove(item, -count);\n  count = count || 1;\n  if (typeof count !== 'number') throw new Error('mnemonist/multi-set.add: given count should be a number.');\n  this.size += count;\n  const currentCount = this.items.get(item);\n  if (currentCount === undefined) this.dimension++;else count += currentCount;\n  this.items.set(item, count);\n  return this;\n};\n/**\n * Method used to set the multiplicity of an item in the set.\n *\n * @param  {any}    item  - Target item.\n * @param  {number} count - Desired multiplicity.\n * @return {MultiSet}\n */\n\n\nMultiSet.prototype.set = function (item, count) {\n  var currentCount;\n  if (typeof count !== 'number') throw new Error('mnemonist/multi-set.set: given count should be a number.'); // Setting an item to 0 or to a negative number means deleting it from the set\n\n  if (count <= 0) {\n    currentCount = this.items.get(item);\n\n    if (typeof currentCount !== 'undefined') {\n      this.size -= currentCount;\n      this.dimension--;\n    }\n\n    this.items.delete(item);\n    return this;\n  }\n\n  count = count || 1;\n  currentCount = this.items.get(item);\n\n  if (typeof currentCount === 'number') {\n    this.items.set(item, currentCount + count);\n  } else {\n    this.dimension++;\n    this.items.set(item, count);\n  }\n\n  this.size += count;\n  return this;\n};\n/**\n * Method used to return whether the item exists in the set.\n *\n * @param  {any} item  - Item to check.\n * @return {boolan}\n */\n\n\nMultiSet.prototype.has = function (item) {\n  return this.items.has(item);\n};\n/**\n * Method used to delete an item from the set.\n *\n * @param  {any} item  - Item to delete.\n * @return {boolan}\n */\n\n\nMultiSet.prototype.delete = function (item) {\n  var count = this.items.get(item);\n  if (count === 0) return false;\n  this.size -= count;\n  this.dimension--;\n  this.items.delete(item);\n  return true;\n};\n/**\n * Method used to remove an item from the set.\n *\n * @param  {any} item  - Item to delete.\n * @param  {number} count - Optional count.\n * @return {undefined}\n */\n\n\nMultiSet.prototype.remove = function (item, count) {\n  if (count === 0) return;\n  if (count < 0) return this.add(item, -count);\n  count = count || 1;\n  if (typeof count !== 'number') throw new Error('mnemonist/multi-set.remove: given count should be a number.');\n  var currentCount = this.multiplicity(item),\n      newCount = Math.max(0, currentCount - count);\n\n  if (newCount === 0) {\n    this.delete(item);\n  } else {\n    this.items.set(item, newCount);\n    this.size -= currentCount - newCount;\n  }\n\n  return;\n};\n/**\n * Method used to change a key into another one, merging counts if the target\n * key already exists.\n *\n * @param  {any} a - From key.\n * @param  {any} b - To key.\n * @return {MultiSet}\n */\n\n\nMultiSet.prototype.edit = function (a, b) {\n  var am = this.multiplicity(a); // If a does not exist in the set, we can stop right there\n\n  if (am === 0) return;\n  var bm = this.multiplicity(b);\n  this.items.set(b, am + bm);\n  this.items.delete(a);\n  return this;\n};\n/**\n * Method used to return the multiplicity of the given item.\n *\n * @param  {any} item  - Item to get.\n * @return {number}\n */\n\n\nMultiSet.prototype.multiplicity = function (item) {\n  var count = this.items.get(item);\n  if (typeof count === 'undefined') return 0;\n  return count;\n};\n\nMultiSet.prototype.get = MultiSet.prototype.multiplicity;\nMultiSet.prototype.count = MultiSet.prototype.multiplicity;\n/**\n * Method used to return the frequency of the given item in the set.\n *\n * @param  {any} item - Item to get.\n * @return {number}\n */\n\nMultiSet.prototype.frequency = function (item) {\n  if (this.size === 0) return 0;\n  var count = this.multiplicity(item);\n  return count / this.size;\n};\n/**\n * Method used to return the n most common items from the set.\n *\n * @param  {number} n - Number of items to retrieve.\n * @return {array}\n */\n\n\nMultiSet.prototype.top = function (n) {\n  if (typeof n !== 'number' || n <= 0) throw new Error('mnemonist/multi-set.top: n must be a number > 0.');\n  var heap = new FixedReverseHeap(Array, MULTISET_ITEM_COMPARATOR, n);\n  var iterator = this.items.entries(),\n      step;\n\n  while (step = iterator.next(), !step.done) heap.push(step.value);\n\n  return heap.consume();\n};\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nMultiSet.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var i;\n  this.items.forEach(function (multiplicity, value) {\n    for (i = 0; i < multiplicity; i++) callback.call(scope, value, value);\n  });\n};\n/**\n * Method used to iterate over the set's multiplicities.\n *\n * @param  {function}  callback - Function to call for each multiplicity.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nMultiSet.prototype.forEachMultiplicity = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  this.items.forEach(callback, scope);\n};\n/**\n * Method returning an iterator over the set's keys. I.e. its unique values,\n * in a sense.\n *\n * @return {Iterator}\n */\n\n\nMultiSet.prototype.keys = function () {\n  return this.items.keys();\n};\n/**\n * Method returning an iterator over the set's values.\n *\n * @return {Iterator}\n */\n\n\nMultiSet.prototype.values = function () {\n  var iterator = this.items.entries(),\n      inContainer = false,\n      step,\n      value,\n      multiplicity,\n      i;\n  return new Iterator(function next() {\n    if (!inContainer) {\n      step = iterator.next();\n      if (step.done) return {\n        done: true\n      };\n      inContainer = true;\n      value = step.value[0];\n      multiplicity = step.value[1];\n      i = 0;\n    }\n\n    if (i >= multiplicity) {\n      inContainer = false;\n      return next();\n    }\n\n    i++;\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n/**\n * Method returning an iterator over the set's multiplicities.\n *\n * @return {Iterator}\n */\n\n\nMultiSet.prototype.multiplicities = function () {\n  return this.items.entries();\n};\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') MultiSet.prototype[Symbol.iterator] = MultiSet.prototype.values;\n/**\n * Convenience known methods.\n */\n\nMultiSet.prototype.inspect = function () {\n  return this.items;\n};\n\nif (typeof Symbol !== 'undefined') MultiSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = MultiSet.prototype.inspect;\n\nMultiSet.prototype.toJSON = function () {\n  return this.items;\n};\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {MultiSet}\n */\n\n\nMultiSet.from = function (iterable) {\n  var set = new MultiSet();\n  forEach(iterable, function (value) {\n    set.add(value);\n  });\n  return set;\n};\n/**\n * Function returning whether the multiset A is a subset of the multiset B.\n *\n * @param  {MultiSet} A - First set.\n * @param  {MultiSet} B - Second set.\n * @return {boolean}\n */\n\n\nMultiSet.isSubset = function (A, B) {\n  var iterator = A.multiplicities(),\n      step,\n      key,\n      mA; // Shortcuts\n\n  if (A === B) return true;\n  if (A.dimension > B.dimension) return false;\n\n  while (step = iterator.next(), !step.done) {\n    key = step.value[0];\n    mA = step.value[1];\n    if (B.multiplicity(key) < mA) return false;\n  }\n\n  return true;\n};\n/**\n * Function returning whether the multiset A is a superset of the multiset B.\n *\n * @param  {MultiSet} A - First set.\n * @param  {MultiSet} B - Second set.\n * @return {boolean}\n */\n\n\nMultiSet.isSuperset = function (A, B) {\n  return MultiSet.isSubset(B, A);\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = MultiSet;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/multi-set.js"],"names":["Iterator","require","forEach","FixedReverseHeap","MULTISET_ITEM_COMPARATOR","a","b","MultiSet","items","Map","Object","defineProperty","value","enumerable","clear","prototype","size","dimension","add","item","count","remove","Error","currentCount","get","undefined","set","delete","has","multiplicity","newCount","Math","max","edit","am","bm","frequency","top","n","heap","Array","iterator","entries","step","next","done","push","consume","callback","scope","arguments","length","i","call","forEachMultiplicity","keys","values","inContainer","multiplicities","Symbol","inspect","for","toJSON","from","iterable","isSubset","A","B","key","mA","isSuperset","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist MultiSet\n * ====================\n *\n * JavaScript implementation of a MultiSet.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    FixedReverseHeap = require('./fixed-reverse-heap.js');\n\n/**\n * Helpers.\n */\nvar MULTISET_ITEM_COMPARATOR = function(a, b) {\n  if (a[1] > b[1])\n    return -1;\n  if (a[1] < b[1])\n    return 1;\n\n  return 0;\n};\n\n// TODO: helper functions: union, intersection, sum, difference, subtract\n\n/**\n * MultiSet.\n *\n * @constructor\n */\nfunction MultiSet() {\n  this.items = new Map();\n\n  Object.defineProperty(this.items, 'constructor', {\n    value: MultiSet,\n    enumerable: false\n  });\n\n  this.clear();\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nMultiSet.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n  this.dimension = 0;\n  this.items.clear();\n};\n\n/**\n * Method used to add an item to the set.\n *\n * @param  {any}    item  - Item to add.\n * @param  {number} count - Optional count.\n * @return {MultiSet}\n */\nMultiSet.prototype.add = function(item, count) {\n  if (count === 0)\n    return this;\n\n  if (count < 0)\n    return this.remove(item, -count);\n\n  count = count || 1;\n\n  if (typeof count !== 'number')\n    throw new Error('mnemonist/multi-set.add: given count should be a number.');\n\n  this.size += count;\n\n  const currentCount = this.items.get(item);\n\n  if (currentCount === undefined)\n    this.dimension++;\n  else\n    count += currentCount;\n\n  this.items.set(item, count);\n\n  return this;\n};\n\n/**\n * Method used to set the multiplicity of an item in the set.\n *\n * @param  {any}    item  - Target item.\n * @param  {number} count - Desired multiplicity.\n * @return {MultiSet}\n */\nMultiSet.prototype.set = function(item, count) {\n  var currentCount;\n\n  if (typeof count !== 'number')\n    throw new Error('mnemonist/multi-set.set: given count should be a number.');\n\n  // Setting an item to 0 or to a negative number means deleting it from the set\n  if (count <= 0) {\n    currentCount = this.items.get(item);\n\n    if (typeof currentCount !== 'undefined') {\n      this.size -= currentCount;\n      this.dimension--;\n    }\n\n    this.items.delete(item);\n    return this;\n  }\n\n  count = count || 1;\n\n  currentCount = this.items.get(item);\n\n  if (typeof currentCount === 'number') {\n    this.items.set(item, currentCount + count);\n  }\n  else {\n    this.dimension++;\n    this.items.set(item, count);\n  }\n\n  this.size += count;\n\n  return this;\n};\n\n/**\n * Method used to return whether the item exists in the set.\n *\n * @param  {any} item  - Item to check.\n * @return {boolan}\n */\nMultiSet.prototype.has = function(item) {\n  return this.items.has(item);\n};\n\n/**\n * Method used to delete an item from the set.\n *\n * @param  {any} item  - Item to delete.\n * @return {boolan}\n */\nMultiSet.prototype.delete = function(item) {\n  var count = this.items.get(item);\n\n  if (count === 0)\n    return false;\n\n  this.size -= count;\n  this.dimension--;\n  this.items.delete(item);\n\n  return true;\n};\n\n/**\n * Method used to remove an item from the set.\n *\n * @param  {any} item  - Item to delete.\n * @param  {number} count - Optional count.\n * @return {undefined}\n */\nMultiSet.prototype.remove = function(item, count) {\n  if (count === 0)\n    return;\n\n  if (count < 0)\n    return this.add(item, -count);\n\n  count = count || 1;\n\n  if (typeof count !== 'number')\n    throw new Error('mnemonist/multi-set.remove: given count should be a number.');\n\n  var currentCount = this.multiplicity(item),\n      newCount = Math.max(0, currentCount - count);\n\n  if (newCount === 0) {\n    this.delete(item);\n  }\n  else {\n    this.items.set(item, newCount);\n    this.size -= (currentCount - newCount);\n  }\n\n  return;\n};\n\n/**\n * Method used to change a key into another one, merging counts if the target\n * key already exists.\n *\n * @param  {any} a - From key.\n * @param  {any} b - To key.\n * @return {MultiSet}\n */\nMultiSet.prototype.edit = function(a, b) {\n  var am = this.multiplicity(a);\n\n  // If a does not exist in the set, we can stop right there\n  if (am === 0)\n    return;\n\n  var bm = this.multiplicity(b);\n\n  this.items.set(b, am + bm);\n  this.items.delete(a);\n\n  return this;\n};\n\n/**\n * Method used to return the multiplicity of the given item.\n *\n * @param  {any} item  - Item to get.\n * @return {number}\n */\nMultiSet.prototype.multiplicity = function(item) {\n  var count = this.items.get(item);\n\n  if (typeof count === 'undefined')\n    return 0;\n\n  return count;\n};\nMultiSet.prototype.get = MultiSet.prototype.multiplicity;\nMultiSet.prototype.count = MultiSet.prototype.multiplicity;\n\n/**\n * Method used to return the frequency of the given item in the set.\n *\n * @param  {any} item - Item to get.\n * @return {number}\n */\nMultiSet.prototype.frequency = function(item) {\n  if (this.size === 0)\n    return 0;\n\n  var count = this.multiplicity(item);\n\n  return count / this.size;\n};\n\n/**\n * Method used to return the n most common items from the set.\n *\n * @param  {number} n - Number of items to retrieve.\n * @return {array}\n */\nMultiSet.prototype.top = function(n) {\n  if (typeof n !== 'number' || n <= 0)\n    throw new Error('mnemonist/multi-set.top: n must be a number > 0.');\n\n  var heap = new FixedReverseHeap(Array, MULTISET_ITEM_COMPARATOR, n);\n\n  var iterator = this.items.entries(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    heap.push(step.value);\n\n  return heap.consume();\n};\n\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nMultiSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var i;\n\n  this.items.forEach(function(multiplicity, value) {\n\n    for (i = 0; i < multiplicity; i++)\n      callback.call(scope, value, value);\n  });\n};\n\n/**\n * Method used to iterate over the set's multiplicities.\n *\n * @param  {function}  callback - Function to call for each multiplicity.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nMultiSet.prototype.forEachMultiplicity = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  this.items.forEach(callback, scope);\n};\n\n/**\n * Method returning an iterator over the set's keys. I.e. its unique values,\n * in a sense.\n *\n * @return {Iterator}\n */\nMultiSet.prototype.keys = function() {\n  return this.items.keys();\n};\n\n/**\n * Method returning an iterator over the set's values.\n *\n * @return {Iterator}\n */\nMultiSet.prototype.values = function() {\n  var iterator = this.items.entries(),\n      inContainer = false,\n      step,\n      value,\n      multiplicity,\n      i;\n\n  return new Iterator(function next() {\n    if (!inContainer) {\n      step = iterator.next();\n\n      if (step.done)\n        return {done: true};\n\n      inContainer = true;\n      value = step.value[0];\n      multiplicity = step.value[1];\n      i = 0;\n    }\n\n    if (i >= multiplicity) {\n      inContainer = false;\n      return next();\n    }\n\n    i++;\n\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n\n/**\n * Method returning an iterator over the set's multiplicities.\n *\n * @return {Iterator}\n */\nMultiSet.prototype.multiplicities = function() {\n  return this.items.entries();\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  MultiSet.prototype[Symbol.iterator] = MultiSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nMultiSet.prototype.inspect = function() {\n  return this.items;\n};\n\nif (typeof Symbol !== 'undefined')\n  MultiSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = MultiSet.prototype.inspect;\nMultiSet.prototype.toJSON = function() {\n  return this.items;\n};\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {MultiSet}\n */\nMultiSet.from = function(iterable) {\n  var set = new MultiSet();\n\n  forEach(iterable, function(value) {\n    set.add(value);\n  });\n\n  return set;\n};\n\n/**\n * Function returning whether the multiset A is a subset of the multiset B.\n *\n * @param  {MultiSet} A - First set.\n * @param  {MultiSet} B - Second set.\n * @return {boolean}\n */\nMultiSet.isSubset = function(A, B) {\n  var iterator = A.multiplicities(),\n      step,\n      key,\n      mA;\n\n  // Shortcuts\n  if (A === B)\n    return true;\n\n  if (A.dimension > B.dimension)\n    return false;\n\n  while ((step = iterator.next(), !step.done)) {\n    key = step.value[0];\n    mA = step.value[1];\n\n    if (B.multiplicity(key) < mA)\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Function returning whether the multiset A is a superset of the multiset B.\n *\n * @param  {MultiSet} A - First set.\n * @param  {MultiSet} B - Second set.\n * @return {boolean}\n */\nMultiSet.isSuperset = function(A, B) {\n  return MultiSet.isSubset(B, A);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = MultiSet;\n"]},"metadata":{},"sourceType":"script"}