{"ast":null,"code":"/* eslint no-constant-condition: 0 */\n\n/**\n * Mnemonist BK Tree\n * ==================\n *\n * Implementation of a Burkhard-Keller tree, allowing fast lookups of words\n * that lie within a specified distance of the query word.\n *\n * [Reference]:\n * https://en.wikipedia.org/wiki/BK-tree\n *\n * [Article]:\n * W. Burkhard and R. Keller. Some approaches to best-match file searching,\n * CACM, 1973\n */\nvar forEach = require('obliterator/foreach');\n/**\n * BK Tree.\n *\n * @constructor\n * @param {function} distance - Distance function to use.\n */\n\n\nfunction BKTree(distance) {\n  if (typeof distance !== 'function') throw new Error('mnemonist/BKTree.constructor: given `distance` should be a function.');\n  this.distance = distance;\n  this.clear();\n}\n/**\n * Method used to add an item to the tree.\n *\n * @param  {any} item - Item to add.\n * @return {BKTree}\n */\n\n\nBKTree.prototype.add = function (item) {\n  // Initializing the tree with the first given word\n  if (!this.root) {\n    this.root = {\n      item: item,\n      children: {}\n    };\n    this.size++;\n    return this;\n  }\n\n  var node = this.root,\n      d;\n\n  while (true) {\n    d = this.distance(item, node.item);\n    if (!node.children[d]) break;\n    node = node.children[d];\n  }\n\n  node.children[d] = {\n    item: item,\n    children: {}\n  };\n  this.size++;\n  return this;\n};\n/**\n * Method used to query the tree.\n *\n * @param  {number} n     - Maximum distance between query & item.\n * @param  {any}    query - Query\n * @return {BKTree}\n */\n\n\nBKTree.prototype.search = function (n, query) {\n  if (!this.root) return [];\n  var found = [],\n      stack = [this.root],\n      node,\n      child,\n      d,\n      i,\n      l;\n\n  while (stack.length) {\n    node = stack.pop();\n    d = this.distance(query, node.item);\n    if (d <= n) found.push({\n      item: node.item,\n      distance: d\n    });\n\n    for (i = d - n, l = d + n + 1; i < l; i++) {\n      child = node.children[i];\n      if (child) stack.push(child);\n    }\n  }\n\n  return found;\n};\n/**\n * Method used to clear the tree.\n *\n * @return {undefined}\n */\n\n\nBKTree.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n  this.root = null;\n};\n/**\n * Convenience known methods.\n */\n\n\nBKTree.prototype.toJSON = function () {\n  return this.root;\n};\n\nBKTree.prototype.inspect = function () {\n  var array = [],\n      stack = [this.root],\n      node,\n      d;\n\n  while (stack.length) {\n    node = stack.pop();\n    if (!node) continue;\n    array.push(node.item);\n\n    for (d in node.children) {\n      stack.push(node.children[d]);\n    }\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(array, 'constructor', {\n    value: BKTree,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') BKTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = BKTree.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a tree.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} distance - Distance function.\n * @return {Heap}\n */\n\nBKTree.from = function (iterable, distance) {\n  var tree = new BKTree(distance);\n  forEach(iterable, function (value) {\n    tree.add(value);\n  });\n  return tree;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = BKTree;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/bk-tree.js"],"names":["forEach","require","BKTree","distance","Error","clear","prototype","add","item","root","children","size","node","d","search","n","query","found","stack","child","i","l","length","pop","push","toJSON","inspect","array","Object","defineProperty","value","enumerable","Symbol","for","from","iterable","tree","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition: 0 */\n/**\n * Mnemonist BK Tree\n * ==================\n *\n * Implementation of a Burkhard-Keller tree, allowing fast lookups of words\n * that lie within a specified distance of the query word.\n *\n * [Reference]:\n * https://en.wikipedia.org/wiki/BK-tree\n *\n * [Article]:\n * W. Burkhard and R. Keller. Some approaches to best-match file searching,\n * CACM, 1973\n */\nvar forEach = require('obliterator/foreach');\n\n/**\n * BK Tree.\n *\n * @constructor\n * @param {function} distance - Distance function to use.\n */\nfunction BKTree(distance) {\n\n  if (typeof distance !== 'function')\n    throw new Error('mnemonist/BKTree.constructor: given `distance` should be a function.');\n\n  this.distance = distance;\n  this.clear();\n}\n\n/**\n * Method used to add an item to the tree.\n *\n * @param  {any} item - Item to add.\n * @return {BKTree}\n */\nBKTree.prototype.add = function(item) {\n\n  // Initializing the tree with the first given word\n  if (!this.root) {\n    this.root = {\n      item: item,\n      children: {}\n    };\n\n    this.size++;\n    return this;\n  }\n\n  var node = this.root,\n      d;\n\n  while (true) {\n    d = this.distance(item, node.item);\n\n    if (!node.children[d])\n      break;\n\n    node = node.children[d];\n  }\n\n  node.children[d] = {\n    item: item,\n    children: {}\n  };\n\n  this.size++;\n  return this;\n};\n\n/**\n * Method used to query the tree.\n *\n * @param  {number} n     - Maximum distance between query & item.\n * @param  {any}    query - Query\n * @return {BKTree}\n */\nBKTree.prototype.search = function(n, query) {\n  if (!this.root)\n    return [];\n\n  var found = [],\n      stack = [this.root],\n      node,\n      child,\n      d,\n      i,\n      l;\n\n  while (stack.length) {\n    node = stack.pop();\n    d = this.distance(query, node.item);\n\n    if (d <= n)\n      found.push({item: node.item, distance: d});\n\n    for (i = d - n, l = d + n + 1; i < l; i++) {\n      child = node.children[i];\n\n      if (child)\n        stack.push(child);\n    }\n  }\n\n  return found;\n};\n\n/**\n * Method used to clear the tree.\n *\n * @return {undefined}\n */\nBKTree.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n  this.root = null;\n};\n\n/**\n * Convenience known methods.\n */\nBKTree.prototype.toJSON = function() {\n  return this.root;\n};\n\nBKTree.prototype.inspect = function() {\n  var array = [],\n      stack = [this.root],\n      node,\n      d;\n\n  while (stack.length) {\n    node = stack.pop();\n\n    if (!node)\n      continue;\n\n    array.push(node.item);\n\n    for (d in node.children)\n      stack.push(node.children[d]);\n  }\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: BKTree,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  BKTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = BKTree.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a tree.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} distance - Distance function.\n * @return {Heap}\n */\nBKTree.from = function(iterable, distance) {\n  var tree = new BKTree(distance);\n\n  forEach(iterable, function(value) {\n    tree.add(value);\n  });\n\n  return tree;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = BKTree;\n"]},"metadata":{},"sourceType":"script"}