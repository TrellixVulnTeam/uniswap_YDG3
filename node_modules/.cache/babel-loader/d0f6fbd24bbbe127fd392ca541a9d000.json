{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { parseUnits } from '@ethersproject/units';\nimport { CurrencyAmount, TradeType } from '@uniswap/sdk-core';\nimport { useBestTrade } from 'hooks/useBestTrade';\nimport JSBI from 'jsbi';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { useCurrency } from '../../hooks/Tokens';\nimport useENS from '../../hooks/useENS';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport useSwapSlippageTolerance from '../../hooks/useSwapSlippageTolerance';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { isAddress } from '../../utils';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function useSwapState() {\n  _s();\n\n  return useAppSelector(state => state.swap);\n}\n\n_s(useSwapState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function useSwapActionHandlers() {\n  _s2();\n\n  const dispatch = useAppDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency.isToken ? currency.address : currency.isNative ? 'ETH' : ''\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n} // try to parse a user entered amount for a given token\n\n_s2(useSwapActionHandlers, \"gN7CWTdCUNzuQ1VDHr7Wk0O/imI=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function tryParseAmount(value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  } // necessary for all paths to return a value\n\n\n  return undefined;\n}\nconst BAD_RECIPIENT_ADDRESSES = {\n  '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f': true,\n  // v2 factory\n  '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a': true,\n  // v2 router 01\n  '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D': true // v2 router 02\n\n}; // from the current swap inputs, compute the best trade and return it.\n\nexport function useDerivedSwapInfo() {\n  _s3();\n\n  var _ref, _ref3, _trade$trade, _trade$trade2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    },\n    recipient\n  } = useSwapState();\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  const to = (_ref = recipient === null ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  const relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined], [inputCurrency, outputCurrency]));\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = useMemo(() => {\n    var _ref2;\n\n    return tryParseAmount(typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  }, [inputCurrency, isExactIn, outputCurrency, typedValue]);\n  const trade = useBestTrade(isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT, parsedAmount, (_ref3 = isExactIn ? outputCurrency : inputCurrency) !== null && _ref3 !== void 0 ? _ref3 : undefined);\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  };\n  const currencies = {\n    [Field.INPUT]: inputCurrency,\n    [Field.OUTPUT]: outputCurrency\n  };\n  let inputError;\n\n  if (!account) {\n    inputError = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError;\n\n    inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Select a token\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!parsedAmount) {\n    var _inputError2;\n\n    inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n\n  const formattedTo = isAddress(to);\n\n  if (!to || !formattedTo) {\n    var _inputError3;\n\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter a recipient\"\n    }, void 0, false, void 0, this);\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n      var _inputError4;\n\n      inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 : /*#__PURE__*/_jsxDEV(Trans, {\n        id: \"Invalid recipient\"\n      }, void 0, false, void 0, this);\n    }\n  }\n\n  const allowedSlippage = useSwapSlippageTolerance((_trade$trade = trade.trade) !== null && _trade$trade !== void 0 ? _trade$trade : undefined); // compare input balance to max input based on version\n\n  const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], (_trade$trade2 = trade.trade) === null || _trade$trade2 === void 0 ? void 0 : _trade$trade2.maximumAmountIn(allowedSlippage)];\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: amountIn.currency.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    inputError,\n    trade,\n    allowedSlippage\n  };\n}\n\n_s3(useDerivedSwapInfo, \"6agdB2eK4COFGVLH3/vcAukT6Pw=\", false, function () {\n  return [useActiveWeb3React, useSwapState, useCurrency, useCurrency, useENS, useCurrencyBalances, useBestTrade, useSwapSlippageTolerance];\n});\n\nfunction parseCurrencyFromURLParameter(urlParam) {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'ETH') return 'ETH';\n  }\n\n  return '';\n}\n\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\n\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs) {\n  var _inputCurrency, _outputCurrency;\n\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n\n  if (inputCurrency === '' && outputCurrency === '') {\n    // default to ETH input\n    inputCurrency = 'ETH';\n  } else if (inputCurrency === outputCurrency) {\n    // clear output if identical\n    outputCurrency = '';\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency === '' ? null : (_inputCurrency = inputCurrency) !== null && _inputCurrency !== void 0 ? _inputCurrency : null\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency === '' ? null : (_outputCurrency = outputCurrency) !== null && _outputCurrency !== void 0 ? _outputCurrency : null\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n} // updates the swap state to use the defaults for a given network\n\nexport function useDefaultsFromURLSearch() {\n  _s4();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const dispatch = useAppDispatch();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState();\n  useEffect(() => {\n    var _parsed$Field$INPUT$c, _parsed$Field$OUTPUT$;\n\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n    const inputCurrencyId = (_parsed$Field$INPUT$c = parsed[Field.INPUT].currencyId) !== null && _parsed$Field$INPUT$c !== void 0 ? _parsed$Field$INPUT$c : undefined;\n    const outputCurrencyId = (_parsed$Field$OUTPUT$ = parsed[Field.OUTPUT].currencyId) !== null && _parsed$Field$OUTPUT$ !== void 0 ? _parsed$Field$OUTPUT$ : undefined;\n    dispatch(replaceSwapState({\n      typedValue: parsed.typedValue,\n      field: parsed.independentField,\n      inputCurrencyId,\n      outputCurrencyId,\n      recipient: parsed.recipient\n    }));\n    setResult({\n      inputCurrencyId,\n      outputCurrencyId\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n  return result;\n}\n\n_s4(useDefaultsFromURLSearch, \"iAcudCmfDywgKqrVFaxpm9lUQwY=\", false, function () {\n  return [useActiveWeb3React, useAppDispatch, useParsedQueryString];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/swap/hooks.tsx"],"names":["parseUnits","CurrencyAmount","TradeType","useBestTrade","JSBI","useCallback","useEffect","useMemo","useState","useAppDispatch","useAppSelector","useCurrency","useENS","useParsedQueryString","useSwapSlippageTolerance","useActiveWeb3React","isAddress","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapState","state","swap","useSwapActionHandlers","dispatch","onCurrencySelection","field","currency","currencyId","isToken","address","isNative","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","fromRawAmount","BigInt","error","console","debug","BAD_RECIPIENT_ADDRESSES","useDerivedSwapInfo","account","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientLookup","to","relevantTokenBalances","isExactIn","parsedAmount","trade","EXACT_INPUT","EXACT_OUTPUT","currencyBalances","currencies","inputError","formattedTo","allowedSlippage","balanceIn","amountIn","maximumAmountIn","lessThan","symbol","parseCurrencyFromURLParameter","urlParam","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","chainId","result","setResult","parsed"],"mappings":";;;;;;AAAA,SAASA,UAAT,QAA2B,sBAA3B;AAEA,SAAmBC,cAAnB,EAA4CC,SAA5C,QAA6D,mBAA7D;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,OAAOC,IAAP,MAAiB,MAAjB;AAEA,SAAoBC,WAApB,EAAiCC,SAAjC,EAA4CC,OAA5C,EAAqDC,QAArD,QAAqE,OAArE;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,aAA/C;AAGA,SAASC,WAAT,QAA4B,oBAA5B;AACA,OAAOC,MAAP,MAAmB,oBAAnB;AACA,OAAOC,oBAAP,MAAiC,kCAAjC;AACA,OAAOC,wBAAP,MAAqC,sCAArC;AACA,SAASC,kBAAT,QAAmC,kBAAnC;AACA,SAASC,SAAT,QAA0B,aAA1B;AAEA,SAASC,mBAAT,QAAoC,iBAApC;AACA,SAASC,KAAT,EAAgBC,gBAAhB,EAAkCC,cAAlC,EAAkDC,YAAlD,EAAgEC,gBAAhE,EAAkFC,SAAlF,QAAmG,WAAnG;;AAGA,OAAO,SAASC,YAAT,GAA0C;AAAA;;AAC/C,SAAOd,cAAc,CAAEe,KAAD,IAAWA,KAAK,CAACC,IAAlB,CAArB;AACD;;GAFeF,Y;UACPd,c;;;AAGT,OAAO,SAASiB,qBAAT,GAKL;AAAA;;AACA,QAAMC,QAAQ,GAAGnB,cAAc,EAA/B;AACA,QAAMoB,mBAAmB,GAAGxB,WAAW,CACrC,CAACyB,KAAD,EAAeC,QAAf,KAAsC;AACpCH,IAAAA,QAAQ,CACNR,cAAc,CAAC;AACbU,MAAAA,KADa;AAEbE,MAAAA,UAAU,EAAED,QAAQ,CAACE,OAAT,GAAmBF,QAAQ,CAACG,OAA5B,GAAsCH,QAAQ,CAACI,QAAT,GAAoB,KAApB,GAA4B;AAFjE,KAAD,CADR,CAAR;AAMD,GARoC,EASrC,CAACP,QAAD,CATqC,CAAvC;AAYA,QAAMQ,cAAc,GAAG/B,WAAW,CAAC,MAAM;AACvCuB,IAAAA,QAAQ,CAACN,gBAAgB,EAAjB,CAAR;AACD,GAFiC,EAE/B,CAACM,QAAD,CAF+B,CAAlC;AAIA,QAAMS,WAAW,GAAGhC,WAAW,CAC7B,CAACyB,KAAD,EAAeQ,UAAf,KAAsC;AACpCV,IAAAA,QAAQ,CAACL,SAAS,CAAC;AAAEO,MAAAA,KAAF;AAASQ,MAAAA;AAAT,KAAD,CAAV,CAAR;AACD,GAH4B,EAI7B,CAACV,QAAD,CAJ6B,CAA/B;AAOA,QAAMW,iBAAiB,GAAGlC,WAAW,CAClCmC,SAAD,IAA8B;AAC5BZ,IAAAA,QAAQ,CAACP,YAAY,CAAC;AAAEmB,MAAAA;AAAF,KAAD,CAAb,CAAR;AACD,GAHkC,EAInC,CAACZ,QAAD,CAJmC,CAArC;AAOA,SAAO;AACLQ,IAAAA,cADK;AAELP,IAAAA,mBAFK;AAGLQ,IAAAA,WAHK;AAILE,IAAAA;AAJK,GAAP;AAMD,C,CAED;;IA7CgBZ,qB;UAMGlB,c;;;AAwCnB,OAAO,SAASgC,cAAT,CAA4CC,KAA5C,EAA4DX,QAA5D,EAAyG;AAC9G,MAAI,CAACW,KAAD,IAAU,CAACX,QAAf,EAAyB;AACvB,WAAOY,SAAP;AACD;;AACD,MAAI;AACF,UAAMC,gBAAgB,GAAG5C,UAAU,CAAC0C,KAAD,EAAQX,QAAQ,CAACc,QAAjB,CAAV,CAAqCC,QAArC,EAAzB;;AACA,QAAIF,gBAAgB,KAAK,GAAzB,EAA8B;AAC5B,aAAO3C,cAAc,CAAC8C,aAAf,CAA6BhB,QAA7B,EAAuC3B,IAAI,CAAC4C,MAAL,CAAYJ,gBAAZ,CAAvC,CAAP;AACD;AACF,GALD,CAKE,OAAOK,KAAP,EAAc;AACd;AACAC,IAAAA,OAAO,CAACC,KAAR,CAAe,kCAAiCT,KAAM,GAAtD,EAA0DO,KAA1D;AACD,GAZ6G,CAa9G;;;AACA,SAAON,SAAP;AACD;AAED,MAAMS,uBAAoD,GAAG;AAC3D,gDAA8C,IADa;AACP;AACpD,gDAA8C,IAFa;AAEP;AACpD,gDAA8C,IAHa,CAGP;;AAHO,CAA7D,C,CAMA;;AACA,OAAO,SAASC,kBAAT,GAUL;AAAA;;AAAA;;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAcvC,kBAAkB,EAAtC;AAEA,QAAM;AACJwC,IAAAA,gBADI;AAEJjB,IAAAA,UAFI;AAGJ,KAACpB,KAAK,CAACsC,KAAP,GAAe;AAAExB,MAAAA,UAAU,EAAEyB;AAAd,KAHX;AAIJ,KAACvC,KAAK,CAACwC,MAAP,GAAgB;AAAE1B,MAAAA,UAAU,EAAE2B;AAAd,KAJZ;AAKJnB,IAAAA;AALI,MAMFhB,YAAY,EANhB;AAQA,QAAMoC,aAAa,GAAGjD,WAAW,CAAC8C,eAAD,CAAjC;AACA,QAAMI,cAAc,GAAGlD,WAAW,CAACgD,gBAAD,CAAlC;AACA,QAAMG,eAAe,GAAGlD,MAAM,CAAC4B,SAAD,aAACA,SAAD,cAACA,SAAD,GAAcG,SAAd,CAA9B;AACA,QAAMoB,EAAiB,WAAIvB,SAAS,KAAK,IAAd,GAAqBc,OAArB,GAA+BQ,eAAe,CAAC5B,OAAnD,uCAA+D,IAAtF;AAEA,QAAM8B,qBAAqB,GAAG/C,mBAAmB,CAC/CqC,OAD+C,aAC/CA,OAD+C,cAC/CA,OAD+C,GACpCX,SADoC,EAE/CpC,OAAO,CAAC,MAAM,CAACqD,aAAD,aAACA,aAAD,cAACA,aAAD,GAAkBjB,SAAlB,EAA6BkB,cAA7B,aAA6BA,cAA7B,cAA6BA,cAA7B,GAA+ClB,SAA/C,CAAP,EAAkE,CAACiB,aAAD,EAAgBC,cAAhB,CAAlE,CAFwC,CAAjD;AAKA,QAAMI,SAAkB,GAAGV,gBAAgB,KAAKrC,KAAK,CAACsC,KAAtD;AACA,QAAMU,YAAY,GAAG3D,OAAO,CAC1B;AAAA;;AAAA,WAAMkC,cAAc,CAACH,UAAD,WAAc2B,SAAS,GAAGL,aAAH,GAAmBC,cAA1C,yCAA6DlB,SAA7D,CAApB;AAAA,GAD0B,EAE1B,CAACiB,aAAD,EAAgBK,SAAhB,EAA2BJ,cAA3B,EAA2CvB,UAA3C,CAF0B,CAA5B;AAKA,QAAM6B,KAAK,GAAGhE,YAAY,CACxB8D,SAAS,GAAG/D,SAAS,CAACkE,WAAb,GAA2BlE,SAAS,CAACmE,YADtB,EAExBH,YAFwB,WAGvBD,SAAS,GAAGJ,cAAH,GAAoBD,aAHN,yCAGwBjB,SAHxB,CAA1B;AAMA,QAAM2B,gBAAgB,GAAG;AACvB,KAACpD,KAAK,CAACsC,KAAP,GAAeQ,qBAAqB,CAAC,CAAD,CADb;AAEvB,KAAC9C,KAAK,CAACwC,MAAP,GAAgBM,qBAAqB,CAAC,CAAD;AAFd,GAAzB;AAKA,QAAMO,UAAkD,GAAG;AACzD,KAACrD,KAAK,CAACsC,KAAP,GAAeI,aAD0C;AAEzD,KAAC1C,KAAK,CAACwC,MAAP,GAAgBG;AAFyC,GAA3D;AAKA,MAAIW,UAAJ;;AACA,MAAI,CAAClB,OAAL,EAAc;AACZkB,IAAAA,UAAU,gBAAG;AAAA;AAAA,mCAAb;AACD;;AAED,MAAI,CAACD,UAAU,CAACrD,KAAK,CAACsC,KAAP,CAAX,IAA4B,CAACe,UAAU,CAACrD,KAAK,CAACwC,MAAP,CAA3C,EAA2D;AAAA;;AACzDc,IAAAA,UAAU,kBAAGA,UAAH,kEAAiB;AAAA;AAAA,mCAA3B;AACD;;AAED,MAAI,CAACN,YAAL,EAAmB;AAAA;;AACjBM,IAAAA,UAAU,mBAAGA,UAAH,oEAAiB;AAAA;AAAA,mCAA3B;AACD;;AAED,QAAMC,WAAW,GAAGzD,SAAS,CAAC+C,EAAD,CAA7B;;AACA,MAAI,CAACA,EAAD,IAAO,CAACU,WAAZ,EAAyB;AAAA;;AACvBD,IAAAA,UAAU,mBAAGA,UAAH,oEAAiB;AAAA;AAAA,mCAA3B;AACD,GAFD,MAEO;AACL,QAAIpB,uBAAuB,CAACqB,WAAD,CAA3B,EAA0C;AAAA;;AACxCD,MAAAA,UAAU,mBAAGA,UAAH,oEAAiB;AAAA;AAAA,qCAA3B;AACD;AACF;;AAED,QAAME,eAAe,GAAG5D,wBAAwB,iBAACqD,KAAK,CAACA,KAAP,uDAAgBxB,SAAhB,CAAhD,CAjEA,CAmEA;;AACA,QAAM,CAACgC,SAAD,EAAYC,QAAZ,IAAwB,CAACN,gBAAgB,CAACpD,KAAK,CAACsC,KAAP,CAAjB,mBAAgCW,KAAK,CAACA,KAAtC,kDAAgC,cAAaU,eAAb,CAA6BH,eAA7B,CAAhC,CAA9B;;AAEA,MAAIC,SAAS,IAAIC,QAAb,IAAyBD,SAAS,CAACG,QAAV,CAAmBF,QAAnB,CAA7B,EAA2D;AACzDJ,IAAAA,UAAU,gBAAG;AAAA;AAAA;AAAA,WAAqBI,QAAQ,CAAC7C,QAAT,CAAkBgD;AAAvC;AAAA,mCAAb;AACD;;AAED,SAAO;AACLR,IAAAA,UADK;AAELD,IAAAA,gBAFK;AAGLJ,IAAAA,YAHK;AAILM,IAAAA,UAJK;AAKLL,IAAAA,KALK;AAMLO,IAAAA;AANK,GAAP;AAQD;;IA5FerB,kB;UAWMtC,kB,EAQhBS,Y,EAEkBb,W,EACCA,W,EACCC,M,EAGMK,mB,EAWhBd,Y,EAsCUW,wB;;;AAmB1B,SAASkE,6BAAT,CAAuCC,QAAvC,EAA8D;AAC5D,MAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAMC,KAAK,GAAGlE,SAAS,CAACiE,QAAD,CAAvB;AACA,QAAIC,KAAJ,EAAW,OAAOA,KAAP;AACX,QAAID,QAAQ,CAACE,WAAT,OAA2B,KAA/B,EAAsC,OAAO,KAAP;AACvC;;AACD,SAAO,EAAP;AACD;;AAED,SAASC,4BAAT,CAAsCH,QAAtC,EAA6D;AAC3D,SAAO,OAAOA,QAAP,KAAoB,QAApB,IAAgC,CAACI,KAAK,CAACC,UAAU,CAACL,QAAD,CAAX,CAAtC,GAA+DA,QAA/D,GAA0E,EAAjF;AACD;;AAED,SAASM,iCAAT,CAA2CN,QAA3C,EAAiE;AAC/D,SAAO,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,CAACO,WAAT,OAA2B,QAA3D,GAAsEtE,KAAK,CAACwC,MAA5E,GAAqFxC,KAAK,CAACsC,KAAlG;AACD;;AAED,MAAMiC,cAAc,GAAG,oFAAvB;AACA,MAAMC,aAAa,GAAG,qBAAtB;;AACA,SAASC,kBAAT,CAA4BnD,SAA5B,EAA2D;AACzD,MAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC,OAAO,IAAP;AACnC,QAAMN,OAAO,GAAGlB,SAAS,CAACwB,SAAD,CAAzB;AACA,MAAIN,OAAJ,EAAa,OAAOA,OAAP;AACb,MAAIuD,cAAc,CAACG,IAAf,CAAoBpD,SAApB,CAAJ,EAAoC,OAAOA,SAAP;AACpC,MAAIkD,aAAa,CAACE,IAAd,CAAmBpD,SAAnB,CAAJ,EAAmC,OAAOA,SAAP;AACnC,SAAO,IAAP;AACD;;AAED,OAAO,SAASqD,0BAAT,CAAoCC,QAApC,EAAmE;AAAA;;AACxE,MAAIlC,aAAa,GAAGoB,6BAA6B,CAACc,QAAQ,CAAClC,aAAV,CAAjD;AACA,MAAIC,cAAc,GAAGmB,6BAA6B,CAACc,QAAQ,CAACjC,cAAV,CAAlD;;AACA,MAAID,aAAa,KAAK,EAAlB,IAAwBC,cAAc,KAAK,EAA/C,EAAmD;AACjD;AACAD,IAAAA,aAAa,GAAG,KAAhB;AACD,GAHD,MAGO,IAAIA,aAAa,KAAKC,cAAtB,EAAsC;AAC3C;AACAA,IAAAA,cAAc,GAAG,EAAjB;AACD;;AAED,QAAMrB,SAAS,GAAGmD,kBAAkB,CAACG,QAAQ,CAACtD,SAAV,CAApC;AAEA,SAAO;AACL,KAACtB,KAAK,CAACsC,KAAP,GAAe;AACbxB,MAAAA,UAAU,EAAE4B,aAAa,KAAK,EAAlB,GAAuB,IAAvB,qBAA8BA,aAA9B,2DAA+C;AAD9C,KADV;AAIL,KAAC1C,KAAK,CAACwC,MAAP,GAAgB;AACd1B,MAAAA,UAAU,EAAE6B,cAAc,KAAK,EAAnB,GAAwB,IAAxB,sBAA+BA,cAA/B,6DAAiD;AAD/C,KAJX;AAOLvB,IAAAA,UAAU,EAAE8C,4BAA4B,CAACU,QAAQ,CAACC,WAAV,CAPnC;AAQLxC,IAAAA,gBAAgB,EAAEgC,iCAAiC,CAACO,QAAQ,CAACE,UAAV,CAR9C;AASLxD,IAAAA;AATK,GAAP;AAWD,C,CAED;;AACA,OAAO,SAASyD,wBAAT,GAEO;AAAA;;AACZ,QAAM;AAAEC,IAAAA;AAAF,MAAcnF,kBAAkB,EAAtC;AACA,QAAMa,QAAQ,GAAGnB,cAAc,EAA/B;AACA,QAAMqF,QAAQ,GAAGjF,oBAAoB,EAArC;AACA,QAAM,CAACsF,MAAD,EAASC,SAAT,IAAsB5F,QAAQ,EAApC;AAIAF,EAAAA,SAAS,CAAC,MAAM;AAAA;;AACd,QAAI,CAAC4F,OAAL,EAAc;AACd,UAAMG,MAAM,GAAGR,0BAA0B,CAACC,QAAD,CAAzC;AACA,UAAMrC,eAAe,4BAAG4C,MAAM,CAACnF,KAAK,CAACsC,KAAP,CAAN,CAAoBxB,UAAvB,yEAAqCW,SAA1D;AACA,UAAMgB,gBAAgB,4BAAG0C,MAAM,CAACnF,KAAK,CAACwC,MAAP,CAAN,CAAqB1B,UAAxB,yEAAsCW,SAA5D;AAEAf,IAAAA,QAAQ,CACNT,gBAAgB,CAAC;AACfmB,MAAAA,UAAU,EAAE+D,MAAM,CAAC/D,UADJ;AAEfR,MAAAA,KAAK,EAAEuE,MAAM,CAAC9C,gBAFC;AAGfE,MAAAA,eAHe;AAIfE,MAAAA,gBAJe;AAKfnB,MAAAA,SAAS,EAAE6D,MAAM,CAAC7D;AALH,KAAD,CADV,CAAR;AAUA4D,IAAAA,SAAS,CAAC;AAAE3C,MAAAA,eAAF;AAAmBE,MAAAA;AAAnB,KAAD,CAAT,CAhBc,CAiBd;AACD,GAlBQ,EAkBN,CAAC/B,QAAD,EAAWsE,OAAX,CAlBM,CAAT;AAoBA,SAAOC,MAAP;AACD;;IA/BeF,wB;UAGMlF,kB,EACHN,c,EACAI,oB","sourcesContent":["import { parseUnits } from '@ethersproject/units'\nimport { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, TradeType } from '@uniswap/sdk-core'\nimport { useBestTrade } from 'hooks/useBestTrade'\nimport JSBI from 'jsbi'\nimport { ParsedQs } from 'qs'\nimport { ReactNode, useCallback, useEffect, useMemo, useState } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport { useCurrency } from '../../hooks/Tokens'\nimport useENS from '../../hooks/useENS'\nimport useParsedQueryString from '../../hooks/useParsedQueryString'\nimport useSwapSlippageTolerance from '../../hooks/useSwapSlippageTolerance'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { isAddress } from '../../utils'\nimport { AppState } from '../index'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\n\nexport function useSwapState(): AppState['swap'] {\n  return useAppSelector((state) => state.swap)\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Currency) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const dispatch = useAppDispatch()\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency.isToken ? currency.address : currency.isNative ? 'ETH' : '',\n        })\n      )\n    },\n    [dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount<T extends Currency>(value?: string, currency?: T): CurrencyAmount<T> | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n    if (typedValueParsed !== '0') {\n      return CurrencyAmount.fromRawAmount(currency, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return undefined\n}\n\nconst BAD_RECIPIENT_ADDRESSES: { [address: string]: true } = {\n  '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f': true, // v2 factory\n  '0xf164fC0Ec4E93095b804a4795bBe1e041497b92a': true, // v2 router 01\n  '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D': true, // v2 router 02\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Currency | null }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmount: CurrencyAmount<Currency> | undefined\n  inputError?: ReactNode\n  trade: {\n    trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n    state: TradeState\n  }\n  allowedSlippage: Percent\n} {\n  const { account } = useActiveWeb3React()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [inputCurrency ?? undefined, outputCurrency ?? undefined], [inputCurrency, outputCurrency])\n  )\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = useMemo(\n    () => tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined),\n    [inputCurrency, isExactIn, outputCurrency, typedValue]\n  )\n\n  const trade = useBestTrade(\n    isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT,\n    parsedAmount,\n    (isExactIn ? outputCurrency : inputCurrency) ?? undefined\n  )\n\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  }\n\n  const currencies: { [field in Field]?: Currency | null } = {\n    [Field.INPUT]: inputCurrency,\n    [Field.OUTPUT]: outputCurrency,\n  }\n\n  let inputError: ReactNode | undefined\n  if (!account) {\n    inputError = <Trans>Connect Wallet</Trans>\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? <Trans>Select a token</Trans>\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? <Trans>Enter an amount</Trans>\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? <Trans>Enter a recipient</Trans>\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES[formattedTo]) {\n      inputError = inputError ?? <Trans>Invalid recipient</Trans>\n    }\n  }\n\n  const allowedSlippage = useSwapSlippageTolerance(trade.trade ?? undefined)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], trade.trade?.maximumAmountIn(allowedSlippage)]\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = <Trans>Insufficient {amountIn.currency.symbol} balance</Trans>\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    inputError,\n    trade,\n    allowedSlippage,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'ETH') return 'ETH'\n  }\n  return ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency)\n  if (inputCurrency === '' && outputCurrency === '') {\n    // default to ETH input\n    inputCurrency = 'ETH'\n  } else if (inputCurrency === outputCurrency) {\n    // clear output if identical\n    outputCurrency = ''\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency === '' ? null : inputCurrency ?? null,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency === '' ? null : outputCurrency ?? null,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const { chainId } = useActiveWeb3React()\n  const dispatch = useAppDispatch()\n  const parsedQs = useParsedQueryString()\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >()\n\n  useEffect(() => {\n    if (!chainId) return\n    const parsed = queryParametersToSwapState(parsedQs)\n    const inputCurrencyId = parsed[Field.INPUT].currencyId ?? undefined\n    const outputCurrencyId = parsed[Field.OUTPUT].currencyId ?? undefined\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId,\n        outputCurrencyId,\n        recipient: parsed.recipient,\n      })\n    )\n\n    setResult({ inputCurrencyId, outputCurrencyId })\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId])\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}