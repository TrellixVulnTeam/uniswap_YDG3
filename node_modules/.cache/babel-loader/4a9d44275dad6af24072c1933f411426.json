{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useMemo } from 'react';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { useBlockNumber } from '../application/hooks';\nimport { useAppDispatch, useAppSelector } from '../hooks';\nimport { addListener, removeListener } from './slice';\nimport { filterToKey } from './utils';\nexport let LogsState;\n\n(function (LogsState) {\n  LogsState[LogsState[\"INVALID\"] = 0] = \"INVALID\";\n  LogsState[LogsState[\"LOADING\"] = 1] = \"LOADING\";\n  LogsState[LogsState[\"SYNCING\"] = 2] = \"SYNCING\";\n  LogsState[LogsState[\"ERROR\"] = 3] = \"ERROR\";\n  LogsState[LogsState[\"SYNCED\"] = 4] = \"SYNCED\";\n})(LogsState || (LogsState = {}));\n\n/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, without `blockHash`, `fromBlock` or `toBlock` defined.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */\nexport function useLogs(filter) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const blockNumber = useBlockNumber();\n  const logs = useAppSelector(state => state.logs);\n  const dispatch = useAppDispatch();\n  useEffect(() => {\n    if (!filter || !chainId) return;\n    dispatch(addListener({\n      chainId,\n      filter\n    }));\n    return () => {\n      dispatch(removeListener({\n        chainId,\n        filter\n      }));\n    };\n  }, [chainId, dispatch, filter]);\n  const filterKey = useMemo(() => filter ? filterToKey(filter) : undefined, [filter]);\n  return useMemo(() => {\n    var _logs$chainId;\n\n    if (!chainId || !filterKey || !blockNumber) return {\n      logs: undefined,\n      state: LogsState.INVALID\n    };\n    const state = (_logs$chainId = logs[chainId]) === null || _logs$chainId === void 0 ? void 0 : _logs$chainId[filterKey];\n    const result = state === null || state === void 0 ? void 0 : state.results;\n\n    if (!result) {\n      return {\n        state: LogsState.LOADING,\n        logs: undefined\n      };\n    }\n\n    if (result.error) {\n      return {\n        state: LogsState.ERROR,\n        logs: undefined\n      };\n    }\n\n    return {\n      state: result.blockNumber >= blockNumber ? LogsState.SYNCED : LogsState.SYNCING,\n      logs: result.logs\n    };\n  }, [blockNumber, chainId, filterKey, logs]);\n}\n\n_s(useLogs, \"pRfl6ba6CGAwb+LTVGVN0eJFhzA=\", false, function () {\n  return [useActiveWeb3React, useBlockNumber, useAppSelector, useAppDispatch];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/logs/hooks.ts"],"names":["useEffect","useMemo","useActiveWeb3React","useBlockNumber","useAppDispatch","useAppSelector","addListener","removeListener","filterToKey","LogsState","useLogs","filter","chainId","blockNumber","logs","state","dispatch","filterKey","undefined","INVALID","result","results","LOADING","error","ERROR","SYNCED","SYNCING"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,OAAnC;AAEA,SAASC,kBAAT,QAAmC,kBAAnC;AACA,SAASC,cAAT,QAA+B,sBAA/B;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,UAA/C;AACA,SAASC,WAAT,EAAsBC,cAAtB,QAA4C,SAA5C;AACA,SAAsBC,WAAtB,QAA8C,SAA9C;AAEA,WAAYC,SAAZ;;WAAYA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;AAAAA,EAAAA,S,CAAAA,S;GAAAA,S,KAAAA,S;;AAkBZ;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAT,CAAiBC,MAAjB,EAAiE;AAAA;;AACtE,QAAM;AAAEC,IAAAA;AAAF,MAAcV,kBAAkB,EAAtC;AACA,QAAMW,WAAW,GAAGV,cAAc,EAAlC;AAEA,QAAMW,IAAI,GAAGT,cAAc,CAAEU,KAAD,IAAWA,KAAK,CAACD,IAAlB,CAA3B;AACA,QAAME,QAAQ,GAAGZ,cAAc,EAA/B;AAEAJ,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACW,MAAD,IAAW,CAACC,OAAhB,EAAyB;AAEzBI,IAAAA,QAAQ,CAACV,WAAW,CAAC;AAAEM,MAAAA,OAAF;AAAWD,MAAAA;AAAX,KAAD,CAAZ,CAAR;AACA,WAAO,MAAM;AACXK,MAAAA,QAAQ,CAACT,cAAc,CAAC;AAAEK,QAAAA,OAAF;AAAWD,QAAAA;AAAX,OAAD,CAAf,CAAR;AACD,KAFD;AAGD,GAPQ,EAON,CAACC,OAAD,EAAUI,QAAV,EAAoBL,MAApB,CAPM,CAAT;AASA,QAAMM,SAAS,GAAGhB,OAAO,CAAC,MAAOU,MAAM,GAAGH,WAAW,CAACG,MAAD,CAAd,GAAyBO,SAAvC,EAAmD,CAACP,MAAD,CAAnD,CAAzB;AAEA,SAAOV,OAAO,CAAC,MAAM;AAAA;;AACnB,QAAI,CAACW,OAAD,IAAY,CAACK,SAAb,IAA0B,CAACJ,WAA/B,EACE,OAAO;AACLC,MAAAA,IAAI,EAAEI,SADD;AAELH,MAAAA,KAAK,EAAEN,SAAS,CAACU;AAFZ,KAAP;AAKF,UAAMJ,KAAK,oBAAGD,IAAI,CAACF,OAAD,CAAP,kDAAG,cAAgBK,SAAhB,CAAd;AACA,UAAMG,MAAM,GAAGL,KAAH,aAAGA,KAAH,uBAAGA,KAAK,CAAEM,OAAtB;;AACA,QAAI,CAACD,MAAL,EAAa;AACX,aAAO;AACLL,QAAAA,KAAK,EAAEN,SAAS,CAACa,OADZ;AAELR,QAAAA,IAAI,EAAEI;AAFD,OAAP;AAID;;AAED,QAAIE,MAAM,CAACG,KAAX,EAAkB;AAChB,aAAO;AACLR,QAAAA,KAAK,EAAEN,SAAS,CAACe,KADZ;AAELV,QAAAA,IAAI,EAAEI;AAFD,OAAP;AAID;;AAED,WAAO;AACLH,MAAAA,KAAK,EAAEK,MAAM,CAACP,WAAP,IAAsBA,WAAtB,GAAoCJ,SAAS,CAACgB,MAA9C,GAAuDhB,SAAS,CAACiB,OADnE;AAELZ,MAAAA,IAAI,EAAEM,MAAM,CAACN;AAFR,KAAP;AAID,GA3Ba,EA2BX,CAACD,WAAD,EAAcD,OAAd,EAAuBK,SAAvB,EAAkCH,IAAlC,CA3BW,CAAd;AA4BD;;GA9CeJ,O;UACMR,kB,EACAC,c,EAEPE,c,EACID,c","sourcesContent":["import { useEffect, useMemo } from 'react'\n\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { useBlockNumber } from '../application/hooks'\nimport { useAppDispatch, useAppSelector } from '../hooks'\nimport { addListener, removeListener } from './slice'\nimport { EventFilter, filterToKey, Log } from './utils'\n\nexport enum LogsState {\n  // The filter is invalid\n  INVALID,\n  // The logs are being loaded\n  LOADING,\n  // Logs are from a previous block number\n  SYNCING,\n  // Tried to fetch logs but received an error\n  ERROR,\n  // Logs have been fetched as of the latest block number\n  SYNCED,\n}\n\nexport interface UseLogsResult {\n  logs: Log[] | undefined\n  state: LogsState\n}\n\n/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, without `blockHash`, `fromBlock` or `toBlock` defined.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */\nexport function useLogs(filter: EventFilter | undefined): UseLogsResult {\n  const { chainId } = useActiveWeb3React()\n  const blockNumber = useBlockNumber()\n\n  const logs = useAppSelector((state) => state.logs)\n  const dispatch = useAppDispatch()\n\n  useEffect(() => {\n    if (!filter || !chainId) return\n\n    dispatch(addListener({ chainId, filter }))\n    return () => {\n      dispatch(removeListener({ chainId, filter }))\n    }\n  }, [chainId, dispatch, filter])\n\n  const filterKey = useMemo(() => (filter ? filterToKey(filter) : undefined), [filter])\n\n  return useMemo(() => {\n    if (!chainId || !filterKey || !blockNumber)\n      return {\n        logs: undefined,\n        state: LogsState.INVALID,\n      }\n\n    const state = logs[chainId]?.[filterKey]\n    const result = state?.results\n    if (!result) {\n      return {\n        state: LogsState.LOADING,\n        logs: undefined,\n      }\n    }\n\n    if (result.error) {\n      return {\n        state: LogsState.ERROR,\n        logs: undefined,\n      }\n    }\n\n    return {\n      state: result.blockNumber >= blockNumber ? LogsState.SYNCED : LogsState.SYNCING,\n      logs: result.logs,\n    }\n  }, [blockNumber, chainId, filterKey, logs])\n}\n"]},"metadata":{},"sourceType":"module"}