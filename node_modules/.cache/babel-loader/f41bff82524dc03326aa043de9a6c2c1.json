{"ast":null,"code":"/**\n * Mnemonist FixedDeque\n * =====================\n *\n * Fixed capacity double-ended queue implemented as ring deque.\n */\nvar iterables = require('./utils/iterables.js'),\n    Iterator = require('obliterator/iterator');\n/**\n * FixedDeque.\n *\n * @constructor\n */\n\n\nfunction FixedDeque(ArrayClass, capacity) {\n  if (arguments.length < 2) throw new Error('mnemonist/fixed-deque: expecting an Array class and a capacity.');\n  if (typeof capacity !== 'number' || capacity <= 0) throw new Error('mnemonist/fixed-deque: `capacity` should be a positive number.');\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(this.capacity);\n  this.clear();\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nFixedDeque.prototype.clear = function () {\n  // Properties\n  this.start = 0;\n  this.size = 0;\n};\n/**\n * Method used to append a value to the deque.\n *\n * @param  {any}    item - Item to append.\n * @return {number}      - Returns the new size of the deque.\n */\n\n\nFixedDeque.prototype.push = function (item) {\n  if (this.size === this.capacity) throw new Error('mnemonist/fixed-deque.push: deque capacity (' + this.capacity + ') exceeded!');\n  var index = (this.start + this.size) % this.capacity;\n  this.items[index] = item;\n  return ++this.size;\n};\n/**\n * Method used to prepend a value to the deque.\n *\n * @param  {any}    item - Item to prepend.\n * @return {number}      - Returns the new size of the deque.\n */\n\n\nFixedDeque.prototype.unshift = function (item) {\n  if (this.size === this.capacity) throw new Error('mnemonist/fixed-deque.unshift: deque capacity (' + this.capacity + ') exceeded!');\n  var index = this.start - 1;\n  if (this.start === 0) index = this.capacity - 1;\n  this.items[index] = item;\n  this.start = index;\n  return ++this.size;\n};\n/**\n * Method used to pop the deque.\n *\n * @return {any} - Returns the popped item.\n */\n\n\nFixedDeque.prototype.pop = function () {\n  if (this.size === 0) return;\n  var index = (this.start + this.size - 1) % this.capacity;\n  this.size--;\n  return this.items[index];\n};\n/**\n * Method used to shift the deque.\n *\n * @return {any} - Returns the shifted item.\n */\n\n\nFixedDeque.prototype.shift = function () {\n  if (this.size === 0) return;\n  var index = this.start;\n  this.size--;\n  this.start++;\n  if (this.start === this.capacity) this.start = 0;\n  return this.items[index];\n};\n/**\n * Method used to peek the first value of the deque.\n *\n * @return {any}\n */\n\n\nFixedDeque.prototype.peekFirst = function () {\n  if (this.size === 0) return;\n  return this.items[this.start];\n};\n/**\n * Method used to peek the last value of the deque.\n *\n * @return {any}\n */\n\n\nFixedDeque.prototype.peekLast = function () {\n  if (this.size === 0) return;\n  var index = this.start + this.size - 1;\n  if (index > this.capacity) index -= this.capacity;\n  return this.items[index];\n};\n/**\n * Method used to get the desired value of the deque.\n *\n * @param  {number} index\n * @return {any}\n */\n\n\nFixedDeque.prototype.get = function (index) {\n  if (this.size === 0) return;\n  index = this.start + index;\n  if (index > this.capacity) index -= this.capacity;\n  return this.items[index];\n};\n/**\n * Method used to iterate over the deque.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nFixedDeque.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.items[i], j, this);\n    i++;\n    j++;\n    if (i === c) i = 0;\n  }\n};\n/**\n * Method used to convert the deque to a JavaScript array.\n *\n * @return {array}\n */\n// TODO: optional array class as argument?\n\n\nFixedDeque.prototype.toArray = function () {\n  // Optimization\n  var offset = this.start + this.size;\n  if (offset < this.capacity) return this.items.slice(this.start, offset);\n  var array = new this.ArrayClass(this.size),\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    array[j] = this.items[i];\n    i++;\n    j++;\n    if (i === c) i = 0;\n  }\n\n  return array;\n};\n/**\n * Method used to create an iterator over the deque's values.\n *\n * @return {Iterator}\n */\n\n\nFixedDeque.prototype.values = function () {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n  return new Iterator(function () {\n    if (j >= l) return {\n      done: true\n    };\n    var value = items[i];\n    i++;\n    j++;\n    if (i === c) i = 0;\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n/**\n * Method used to create an iterator over the deque's entries.\n *\n * @return {Iterator}\n */\n\n\nFixedDeque.prototype.entries = function () {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n  return new Iterator(function () {\n    if (j >= l) return {\n      done: true\n    };\n    var value = items[i];\n    i++;\n    if (i === c) i = 0;\n    return {\n      value: [j++, value],\n      done: false\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;\n/**\n * Convenience known methods.\n */\n\nFixedDeque.prototype.inspect = function () {\n  var array = this.toArray();\n  array.type = this.ArrayClass.name;\n  array.capacity = this.capacity; // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(array, 'constructor', {\n    value: FixedDeque,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') FixedDeque.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedDeque.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a deque.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FiniteStack}\n */\n\nFixedDeque.from = function (iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n    if (typeof capacity !== 'number') throw new Error('mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var deque = new FixedDeque(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++) {\n      deque.items[i] = iterable[i];\n    }\n\n    deque.size = l;\n    return deque;\n  }\n\n  iterables.forEach(iterable, function (value) {\n    deque.push(value);\n  });\n  return deque;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = FixedDeque;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/fixed-deque.js"],"names":["iterables","require","Iterator","FixedDeque","ArrayClass","capacity","arguments","length","Error","items","clear","prototype","start","size","push","item","index","unshift","pop","shift","peekFirst","peekLast","get","forEach","callback","scope","c","l","i","j","call","toArray","offset","slice","array","values","done","value","entries","Symbol","iterator","inspect","type","name","Object","defineProperty","enumerable","for","from","iterable","guessLength","deque","isArrayLike","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist FixedDeque\n * =====================\n *\n * Fixed capacity double-ended queue implemented as ring deque.\n */\nvar iterables = require('./utils/iterables.js'),\n    Iterator = require('obliterator/iterator');\n\n/**\n * FixedDeque.\n *\n * @constructor\n */\nfunction FixedDeque(ArrayClass, capacity) {\n\n  if (arguments.length < 2)\n    throw new Error('mnemonist/fixed-deque: expecting an Array class and a capacity.');\n\n  if (typeof capacity !== 'number' || capacity <= 0)\n    throw new Error('mnemonist/fixed-deque: `capacity` should be a positive number.');\n\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(this.capacity);\n  this.clear();\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nFixedDeque.prototype.clear = function() {\n\n  // Properties\n  this.start = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to append a value to the deque.\n *\n * @param  {any}    item - Item to append.\n * @return {number}      - Returns the new size of the deque.\n */\nFixedDeque.prototype.push = function(item) {\n  if (this.size === this.capacity)\n    throw new Error('mnemonist/fixed-deque.push: deque capacity (' + this.capacity + ') exceeded!');\n\n  var index = (this.start + this.size) % this.capacity;\n\n  this.items[index] = item;\n\n  return ++this.size;\n};\n\n/**\n * Method used to prepend a value to the deque.\n *\n * @param  {any}    item - Item to prepend.\n * @return {number}      - Returns the new size of the deque.\n */\nFixedDeque.prototype.unshift = function(item) {\n  if (this.size === this.capacity)\n    throw new Error('mnemonist/fixed-deque.unshift: deque capacity (' + this.capacity + ') exceeded!');\n\n  var index = this.start - 1;\n\n  if (this.start === 0)\n    index = this.capacity - 1;\n\n  this.items[index] = item;\n  this.start = index;\n\n  return ++this.size;\n};\n\n/**\n * Method used to pop the deque.\n *\n * @return {any} - Returns the popped item.\n */\nFixedDeque.prototype.pop = function() {\n  if (this.size === 0)\n    return;\n\n  const index = (this.start + this.size - 1) % this.capacity;\n\n  this.size--;\n\n  return this.items[index];\n};\n\n/**\n * Method used to shift the deque.\n *\n * @return {any} - Returns the shifted item.\n */\nFixedDeque.prototype.shift = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start;\n\n  this.size--;\n  this.start++;\n\n  if (this.start === this.capacity)\n    this.start = 0;\n\n  return this.items[index];\n};\n\n/**\n * Method used to peek the first value of the deque.\n *\n * @return {any}\n */\nFixedDeque.prototype.peekFirst = function() {\n  if (this.size === 0)\n    return;\n\n  return this.items[this.start];\n};\n\n/**\n * Method used to peek the last value of the deque.\n *\n * @return {any}\n */\nFixedDeque.prototype.peekLast = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start + this.size - 1;\n\n  if (index > this.capacity)\n    index -= this.capacity;\n\n  return this.items[index];\n};\n\n/**\n * Method used to get the desired value of the deque.\n *\n * @param  {number} index\n * @return {any}\n */\nFixedDeque.prototype.get = function(index) {\n  if (this.size === 0)\n    return;\n\n  index = this.start + index;\n\n  if (index > this.capacity)\n    index -= this.capacity;\n\n  return this.items[index];\n};\n\n/**\n * Method used to iterate over the deque.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nFixedDeque.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.items[i], j, this);\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n};\n\n/**\n * Method used to convert the deque to a JavaScript array.\n *\n * @return {array}\n */\n// TODO: optional array class as argument?\nFixedDeque.prototype.toArray = function() {\n\n  // Optimization\n  var offset = this.start + this.size;\n\n  if (offset < this.capacity)\n    return this.items.slice(this.start, offset);\n\n  var array = new this.ArrayClass(this.size),\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    array[j] = this.items[i];\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n\n  return array;\n};\n\n/**\n * Method used to create an iterator over the deque's values.\n *\n * @return {Iterator}\n */\nFixedDeque.prototype.values = function() {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the deque's entries.\n *\n * @return {Iterator}\n */\nFixedDeque.prototype.entries = function() {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n\n    i++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: [j++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;\n\n/**\n * Convenience known methods.\n */\nFixedDeque.prototype.inspect = function() {\n  var array = this.toArray();\n\n  array.type = this.ArrayClass.name;\n  array.capacity = this.capacity;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: FixedDeque,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  FixedDeque.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedDeque.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a deque.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FiniteStack}\n */\nFixedDeque.from = function(iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var deque = new FixedDeque(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++)\n      deque.items[i] = iterable[i];\n\n    deque.size = l;\n\n    return deque;\n  }\n\n  iterables.forEach(iterable, function(value) {\n    deque.push(value);\n  });\n\n  return deque;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FixedDeque;\n"]},"metadata":{},"sourceType":"script"}