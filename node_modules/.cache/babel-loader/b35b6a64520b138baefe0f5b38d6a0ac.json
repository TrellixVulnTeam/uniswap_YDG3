{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { TradeType } from '@uniswap/sdk-core';\nimport { TradeState } from 'state/routing/types';\nimport { useRoutingAPITrade } from 'state/routing/useRoutingAPITrade';\nimport useAutoRouterSupported from './useAutoRouterSupported';\nimport { useClientSideV3Trade } from './useClientSideV3Trade';\nimport useDebounce from './useDebounce';\nimport useIsWindowVisible from './useIsWindowVisible';\n/**\n * Returns the best v2+v3 trade for a desired swap.\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\n\nexport function useBestTrade(tradeType, amountSpecified, otherCurrency) {\n  _s();\n\n  const autoRouterSupported = useAutoRouterSupported();\n  const isWindowVisible = useIsWindowVisible();\n  const [debouncedAmount, debouncedOtherCurrency] = useDebounce([amountSpecified, otherCurrency], 200);\n  const routingAPITrade = useRoutingAPITrade(tradeType, autoRouterSupported && isWindowVisible ? debouncedAmount : undefined, debouncedOtherCurrency);\n  const isLoading = amountSpecified !== undefined && debouncedAmount === undefined; // consider trade debouncing when inputs/outputs do not match\n\n  const debouncing = routingAPITrade.trade && amountSpecified && (tradeType === TradeType.EXACT_INPUT ? !routingAPITrade.trade.inputAmount.equalTo(amountSpecified) || !amountSpecified.currency.equals(routingAPITrade.trade.inputAmount.currency) || !(debouncedOtherCurrency === null || debouncedOtherCurrency === void 0 ? void 0 : debouncedOtherCurrency.equals(routingAPITrade.trade.outputAmount.currency)) : !routingAPITrade.trade.outputAmount.equalTo(amountSpecified) || !amountSpecified.currency.equals(routingAPITrade.trade.outputAmount.currency) || !(debouncedOtherCurrency === null || debouncedOtherCurrency === void 0 ? void 0 : debouncedOtherCurrency.equals(routingAPITrade.trade.inputAmount.currency)));\n  const useFallback = !autoRouterSupported || !debouncing && routingAPITrade.state === TradeState.NO_ROUTE_FOUND; // only use client side router if routing api trade failed or is not supported\n\n  const bestV3Trade = useClientSideV3Trade(tradeType, useFallback ? debouncedAmount : undefined, useFallback ? debouncedOtherCurrency : undefined); // only return gas estimate from api if routing api trade is used\n\n  return { ...(useFallback ? bestV3Trade : routingAPITrade),\n    ...(debouncing ? {\n      state: TradeState.SYNCING\n    } : {}),\n    ...(isLoading ? {\n      state: TradeState.LOADING\n    } : {})\n  };\n}\n\n_s(useBestTrade, \"sumJ9G1JRKjg00uPJ4sRhfb63iU=\", false, function () {\n  return [useAutoRouterSupported, useIsWindowVisible, useDebounce, useRoutingAPITrade, useClientSideV3Trade];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useBestTrade.ts"],"names":["TradeType","TradeState","useRoutingAPITrade","useAutoRouterSupported","useClientSideV3Trade","useDebounce","useIsWindowVisible","useBestTrade","tradeType","amountSpecified","otherCurrency","autoRouterSupported","isWindowVisible","debouncedAmount","debouncedOtherCurrency","routingAPITrade","undefined","isLoading","debouncing","trade","EXACT_INPUT","inputAmount","equalTo","currency","equals","outputAmount","useFallback","state","NO_ROUTE_FOUND","bestV3Trade","SYNCING","LOADING"],"mappings":";;AAAA,SAAmCA,SAAnC,QAAoD,mBAApD;AACA,SAAyBC,UAAzB,QAA2C,qBAA3C;AACA,SAASC,kBAAT,QAAmC,kCAAnC;AAEA,OAAOC,sBAAP,MAAmC,0BAAnC;AACA,SAASC,oBAAT,QAAqC,wBAArC;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,kBAAP,MAA+B,sBAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,YAAT,CACLC,SADK,EAELC,eAFK,EAGLC,aAHK,EAOL;AAAA;;AACA,QAAMC,mBAAmB,GAAGR,sBAAsB,EAAlD;AACA,QAAMS,eAAe,GAAGN,kBAAkB,EAA1C;AAEA,QAAM,CAACO,eAAD,EAAkBC,sBAAlB,IAA4CT,WAAW,CAAC,CAACI,eAAD,EAAkBC,aAAlB,CAAD,EAAmC,GAAnC,CAA7D;AAEA,QAAMK,eAAe,GAAGb,kBAAkB,CACxCM,SADwC,EAExCG,mBAAmB,IAAIC,eAAvB,GAAyCC,eAAzC,GAA2DG,SAFnB,EAGxCF,sBAHwC,CAA1C;AAMA,QAAMG,SAAS,GAAGR,eAAe,KAAKO,SAApB,IAAiCH,eAAe,KAAKG,SAAvE,CAZA,CAcA;;AACA,QAAME,UAAU,GACdH,eAAe,CAACI,KAAhB,IACAV,eADA,KAECD,SAAS,KAAKR,SAAS,CAACoB,WAAxB,GACG,CAACL,eAAe,CAACI,KAAhB,CAAsBE,WAAtB,CAAkCC,OAAlC,CAA0Cb,eAA1C,CAAD,IACA,CAACA,eAAe,CAACc,QAAhB,CAAyBC,MAAzB,CAAgCT,eAAe,CAACI,KAAhB,CAAsBE,WAAtB,CAAkCE,QAAlE,CADD,IAEA,EAACT,sBAAD,aAACA,sBAAD,uBAACA,sBAAsB,CAAEU,MAAxB,CAA+BT,eAAe,CAACI,KAAhB,CAAsBM,YAAtB,CAAmCF,QAAlE,CAAD,CAHH,GAIG,CAACR,eAAe,CAACI,KAAhB,CAAsBM,YAAtB,CAAmCH,OAAnC,CAA2Cb,eAA3C,CAAD,IACA,CAACA,eAAe,CAACc,QAAhB,CAAyBC,MAAzB,CAAgCT,eAAe,CAACI,KAAhB,CAAsBM,YAAtB,CAAmCF,QAAnE,CADD,IAEA,EAACT,sBAAD,aAACA,sBAAD,uBAACA,sBAAsB,CAAEU,MAAxB,CAA+BT,eAAe,CAACI,KAAhB,CAAsBE,WAAtB,CAAkCE,QAAjE,CAAD,CARJ,CADF;AAWA,QAAMG,WAAW,GAAG,CAACf,mBAAD,IAAyB,CAACO,UAAD,IAAeH,eAAe,CAACY,KAAhB,KAA0B1B,UAAU,CAAC2B,cAAjG,CA1BA,CA4BA;;AACA,QAAMC,WAAW,GAAGzB,oBAAoB,CACtCI,SADsC,EAEtCkB,WAAW,GAAGb,eAAH,GAAqBG,SAFM,EAGtCU,WAAW,GAAGZ,sBAAH,GAA4BE,SAHD,CAAxC,CA7BA,CAmCA;;AACA,SAAO,EACL,IAAIU,WAAW,GAAGG,WAAH,GAAiBd,eAAhC,CADK;AAEL,QAAIG,UAAU,GAAG;AAAES,MAAAA,KAAK,EAAE1B,UAAU,CAAC6B;AAApB,KAAH,GAAmC,EAAjD,CAFK;AAGL,QAAIb,SAAS,GAAG;AAAEU,MAAAA,KAAK,EAAE1B,UAAU,CAAC8B;AAApB,KAAH,GAAmC,EAAhD;AAHK,GAAP;AAKD;;GAhDexB,Y;UAQcJ,sB,EACJG,kB,EAE0BD,W,EAE1BH,kB,EAuBJE,oB","sourcesContent":["import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\nimport { useRoutingAPITrade } from 'state/routing/useRoutingAPITrade'\n\nimport useAutoRouterSupported from './useAutoRouterSupported'\nimport { useClientSideV3Trade } from './useClientSideV3Trade'\nimport useDebounce from './useDebounce'\nimport useIsWindowVisible from './useIsWindowVisible'\n\n/**\n * Returns the best v2+v3 trade for a desired swap.\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useBestTrade(\n  tradeType: TradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TradeType> | undefined\n} {\n  const autoRouterSupported = useAutoRouterSupported()\n  const isWindowVisible = useIsWindowVisible()\n\n  const [debouncedAmount, debouncedOtherCurrency] = useDebounce([amountSpecified, otherCurrency], 200)\n\n  const routingAPITrade = useRoutingAPITrade(\n    tradeType,\n    autoRouterSupported && isWindowVisible ? debouncedAmount : undefined,\n    debouncedOtherCurrency\n  )\n\n  const isLoading = amountSpecified !== undefined && debouncedAmount === undefined\n\n  // consider trade debouncing when inputs/outputs do not match\n  const debouncing =\n    routingAPITrade.trade &&\n    amountSpecified &&\n    (tradeType === TradeType.EXACT_INPUT\n      ? !routingAPITrade.trade.inputAmount.equalTo(amountSpecified) ||\n        !amountSpecified.currency.equals(routingAPITrade.trade.inputAmount.currency) ||\n        !debouncedOtherCurrency?.equals(routingAPITrade.trade.outputAmount.currency)\n      : !routingAPITrade.trade.outputAmount.equalTo(amountSpecified) ||\n        !amountSpecified.currency.equals(routingAPITrade.trade.outputAmount.currency) ||\n        !debouncedOtherCurrency?.equals(routingAPITrade.trade.inputAmount.currency))\n\n  const useFallback = !autoRouterSupported || (!debouncing && routingAPITrade.state === TradeState.NO_ROUTE_FOUND)\n\n  // only use client side router if routing api trade failed or is not supported\n  const bestV3Trade = useClientSideV3Trade(\n    tradeType,\n    useFallback ? debouncedAmount : undefined,\n    useFallback ? debouncedOtherCurrency : undefined\n  )\n\n  // only return gas estimate from api if routing api trade is used\n  return {\n    ...(useFallback ? bestV3Trade : routingAPITrade),\n    ...(debouncing ? { state: TradeState.SYNCING } : {}),\n    ...(isLoading ? { state: TradeState.LOADING } : {}),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}