{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\nclass RequestError extends Error {\n  constructor(message, code, data) {\n    super(message);\n    this.code = code;\n    this.data = data;\n  }\n\n}\n\nclass MiniRpcProvider {\n  constructor(connector, chainId, url, batchWaitTimeMs) {\n    this.isMetaMask = false;\n    this.chainId = void 0;\n    this.url = void 0;\n    this.host = void 0;\n    this.path = void 0;\n    this.batchWaitTimeMs = void 0;\n    this.connector = void 0;\n    this.nextId = 1;\n    this.batchTimeoutId = null;\n    this.batch = [];\n\n    this.clearBatch = async () => {\n      console.debug('Clearing batch', this.batch);\n      let batch = this.batch;\n      batch = batch.filter(b => {\n        if (b.request.method === 'wallet_switchEthereumChain') {\n          try {\n            this.connector.changeChainId(parseInt(b.request.params[0].chainId));\n            b.resolve({\n              id: b.request.id\n            });\n          } catch (error) {\n            b.reject(error);\n          }\n\n          return false;\n        }\n\n        return true;\n      });\n      this.batch = [];\n      this.batchTimeoutId = null;\n      let response;\n\n      try {\n        response = await fetch(this.url, {\n          method: 'POST',\n          headers: {\n            'content-type': 'application/json',\n            accept: 'application/json'\n          },\n          body: JSON.stringify(batch.map(item => item.request))\n        });\n      } catch (error) {\n        batch.forEach(({\n          reject\n        }) => reject(new Error('Failed to send batch call')));\n        return;\n      }\n\n      if (!response.ok) {\n        batch.forEach(({\n          reject\n        }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));\n        return;\n      }\n\n      let json;\n\n      try {\n        json = await response.json();\n      } catch (error) {\n        batch.forEach(({\n          reject\n        }) => reject(new Error('Failed to parse JSON response')));\n        return;\n      }\n\n      const byKey = batch.reduce((memo, current) => {\n        memo[current.request.id] = current;\n        return memo;\n      }, {});\n\n      for (const result of json) {\n        const {\n          resolve,\n          reject,\n          request: {\n            method\n          }\n        } = byKey[result.id];\n\n        if ('error' in result) {\n          var _result$error, _result$error2, _result$error3;\n\n          reject(new RequestError(result === null || result === void 0 ? void 0 : (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message, result === null || result === void 0 ? void 0 : (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.code, result === null || result === void 0 ? void 0 : (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.data));\n        } else if ('result' in result && resolve) {\n          resolve(result.result);\n        } else {\n          reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n        }\n      }\n    };\n\n    this.sendAsync = (request, callback) => {\n      this.request(request.method, request.params).then(result => callback(null, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result\n      })).catch(error => callback(error, null));\n    };\n\n    this.request = async (method, params) => {\n      var _this$batchTimeoutId;\n\n      if (typeof method !== 'string') {\n        return this.request(method.method, method.params);\n      }\n\n      if (method === 'eth_chainId') {\n        return `0x${this.chainId.toString(16)}`;\n      }\n\n      const promise = new Promise((resolve, reject) => {\n        this.batch.push({\n          request: {\n            jsonrpc: '2.0',\n            id: this.nextId++,\n            method,\n            params\n          },\n          resolve,\n          reject\n        });\n      });\n      this.batchTimeoutId = (_this$batchTimeoutId = this.batchTimeoutId) !== null && _this$batchTimeoutId !== void 0 ? _this$batchTimeoutId : setTimeout(this.clearBatch, this.batchWaitTimeMs);\n      return promise;\n    };\n\n    this.connector = connector;\n    this.chainId = chainId;\n    this.url = url;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname; // how long to wait to batch calls\n\n    this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;\n  }\n\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  constructor({\n    urls,\n    defaultChainId\n  }) {\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');\n    super({\n      supportedChainIds: Object.keys(urls).map(k => Number(k))\n    });\n    this.providers = void 0;\n    this.currentChainId = void 0;\n    this.currentChainId = defaultChainId !== null && defaultChainId !== void 0 ? defaultChainId : Number(Object.keys(urls)[0]);\n    this.providers = Object.keys(urls).reduce((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(this, Number(chainId), urls[Number(chainId)]);\n      return accumulator;\n    }, {});\n  }\n\n  get provider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null\n    };\n  }\n\n  async getProvider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async getChainId() {\n    return this.currentChainId;\n  }\n\n  async getAccount() {\n    return null;\n  }\n\n  deactivate() {\n    return;\n  }\n  /**\n   * Meant to be called only by MiniRpcProvider\n   * @param chainId the new chain id\n   */\n\n\n  changeChainId(chainId) {\n    if (chainId in this.providers) {\n      this.currentChainId = chainId;\n      this.emitUpdate({\n        chainId,\n        account: null,\n        provider: this.providers[chainId]\n      });\n    } else {\n      throw new Error(`Unsupported chain ID: ${chainId}`);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/connectors/NetworkConnector.ts"],"names":["AbstractConnector","invariant","RequestError","Error","constructor","message","code","data","MiniRpcProvider","connector","chainId","url","batchWaitTimeMs","isMetaMask","host","path","nextId","batchTimeoutId","batch","clearBatch","console","debug","filter","b","request","method","changeChainId","parseInt","params","resolve","id","error","reject","response","fetch","headers","accept","body","JSON","stringify","map","item","forEach","ok","status","statusText","json","byKey","reduce","memo","current","result","sendAsync","callback","then","jsonrpc","catch","toString","promise","Promise","push","setTimeout","parsed","URL","pathname","NetworkConnector","urls","defaultChainId","Object","keys","length","supportedChainIds","k","Number","providers","currentChainId","accumulator","provider","activate","account","getProvider","getChainId","getAccount","deactivate","emitUpdate"],"mappings":"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","sourcesContent":["import { AbstractConnector } from '@web3-react/abstract-connector'\nimport { ConnectorUpdate } from '@web3-react/types'\nimport invariant from 'tiny-invariant'\n\ninterface NetworkConnectorArguments {\n  urls: { [chainId: number]: string }\n  defaultChainId?: number\n}\n\n// taken from ethers.js, compatible interface with web3 provider\ntype AsyncSendable = {\n  isMetaMask?: boolean\n  host?: string\n  path?: string\n  sendAsync?: (request: any, callback: (error: any, response: any) => void) => void\n  send?: (request: any, callback: (error: any, response: any) => void) => void\n}\n\nclass RequestError extends Error {\n  constructor(message: string, public code: number, public data?: unknown) {\n    super(message)\n  }\n}\n\ninterface BatchItem {\n  request: { jsonrpc: '2.0'; id: number; method: string; params: unknown }\n  resolve: (result: any) => void\n  reject: (error: Error) => void\n}\n\nclass MiniRpcProvider implements AsyncSendable {\n  public readonly isMetaMask: false = false\n  public readonly chainId: number\n  public readonly url: string\n  public readonly host: string\n  public readonly path: string\n  public readonly batchWaitTimeMs: number\n\n  private readonly connector: NetworkConnector\n\n  private nextId = 1\n  private batchTimeoutId: ReturnType<typeof setTimeout> | null = null\n  private batch: BatchItem[] = []\n\n  constructor(connector: NetworkConnector, chainId: number, url: string, batchWaitTimeMs?: number) {\n    this.connector = connector\n    this.chainId = chainId\n    this.url = url\n    const parsed = new URL(url)\n    this.host = parsed.host\n    this.path = parsed.pathname\n    // how long to wait to batch calls\n    this.batchWaitTimeMs = batchWaitTimeMs ?? 50\n  }\n\n  public readonly clearBatch = async () => {\n    console.debug('Clearing batch', this.batch)\n    let batch = this.batch\n\n    batch = batch.filter((b) => {\n      if (b.request.method === 'wallet_switchEthereumChain') {\n        try {\n          this.connector.changeChainId(parseInt((b.request.params as [{ chainId: string }])[0].chainId))\n          b.resolve({ id: b.request.id })\n        } catch (error) {\n          b.reject(error)\n        }\n        return false\n      }\n      return true\n    })\n\n    this.batch = []\n    this.batchTimeoutId = null\n    let response: Response\n    try {\n      response = await fetch(this.url, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json', accept: 'application/json' },\n        body: JSON.stringify(batch.map((item) => item.request)),\n      })\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')))\n      return\n    }\n\n    if (!response.ok) {\n      batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)))\n      return\n    }\n\n    let json\n    try {\n      json = await response.json()\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')))\n      return\n    }\n    const byKey = batch.reduce<{ [id: number]: BatchItem }>((memo, current) => {\n      memo[current.request.id] = current\n      return memo\n    }, {})\n    for (const result of json) {\n      const {\n        resolve,\n        reject,\n        request: { method },\n      } = byKey[result.id]\n      if ('error' in result) {\n        reject(new RequestError(result?.error?.message, result?.error?.code, result?.error?.data))\n      } else if ('result' in result && resolve) {\n        resolve(result.result)\n      } else {\n        reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result))\n      }\n    }\n  }\n\n  public readonly sendAsync = (\n    request: {\n      jsonrpc: '2.0'\n      id: number | string | null\n      method: string\n      params?: unknown[] | Record<string, unknown>\n    },\n    callback: (error: any, response: any) => void\n  ): void => {\n    this.request(request.method, request.params)\n      .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))\n      .catch((error) => callback(error, null))\n  }\n\n  public readonly request = async (\n    method: string | { method: string; params: unknown[] },\n    params?: unknown[] | Record<string, unknown>\n  ): Promise<unknown> => {\n    if (typeof method !== 'string') {\n      return this.request(method.method, method.params)\n    }\n    if (method === 'eth_chainId') {\n      return `0x${this.chainId.toString(16)}`\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.batch.push({\n        request: {\n          jsonrpc: '2.0',\n          id: this.nextId++,\n          method,\n          params,\n        },\n        resolve,\n        reject,\n      })\n    })\n    this.batchTimeoutId = this.batchTimeoutId ?? setTimeout(this.clearBatch, this.batchWaitTimeMs)\n    return promise\n  }\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  private readonly providers: { [chainId: number]: MiniRpcProvider }\n  private currentChainId: number\n\n  constructor({ urls, defaultChainId }: NetworkConnectorArguments) {\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url')\n    super({ supportedChainIds: Object.keys(urls).map((k): number => Number(k)) })\n\n    this.currentChainId = defaultChainId ?? Number(Object.keys(urls)[0])\n    this.providers = Object.keys(urls).reduce<{ [chainId: number]: MiniRpcProvider }>((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(this, Number(chainId), urls[Number(chainId)])\n      return accumulator\n    }, {})\n  }\n\n  public get provider(): MiniRpcProvider {\n    return this.providers[this.currentChainId]\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null }\n  }\n\n  public async getProvider(): Promise<MiniRpcProvider> {\n    return this.providers[this.currentChainId]\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.currentChainId\n  }\n\n  public async getAccount(): Promise<null> {\n    return null\n  }\n\n  public deactivate() {\n    return\n  }\n\n  /**\n   * Meant to be called only by MiniRpcProvider\n   * @param chainId the new chain id\n   */\n  public changeChainId(chainId: number) {\n    if (chainId in this.providers) {\n      this.currentChainId = chainId\n      this.emitUpdate({\n        chainId,\n        account: null,\n        provider: this.providers[chainId],\n      })\n    } else {\n      throw new Error(`Unsupported chain ID: ${chainId}`)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}