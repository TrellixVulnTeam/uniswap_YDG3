{"ast":null,"code":"import _toConsumableArray from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { TradeType } from '@uniswap/sdk-core';\nimport { BigNumber } from 'ethers';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport { FixedReverseHeap, Queue } from 'mnemonist';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig) {\n  var now = Date.now(); // Build a map of percentage of the input to list of valid quotes.\n  // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n\n  var percentToQuotes = {};\n\n  var _iterator = _createForOfIteratorHelper(routesWithValidQuotes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var routeWithValidQuote = _step.value;\n\n      if (!percentToQuotes[routeWithValidQuote.percent]) {\n        percentToQuotes[routeWithValidQuote.percent] = [];\n      }\n\n      percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds); // Given all the valid quotes for each percentage find the optimal route.\n\n  var swapRoute = getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, function (rq) {\n    return rq.quoteAdjustedForGas;\n  }, routingConfig); // It is possible we were unable to find any valid route given the quotes.\n\n  if (!swapRoute) {\n    return null;\n  } // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n  // route of our optimal quote may not add up exactly to exactIn or exactOut.\n  //\n  // We check this here, and if there is a mismatch\n  // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n\n\n  var routeAmounts = swapRoute.routes;\n\n  var totalAmount = _.reduce(routeAmounts, function (total, routeAmount) {\n    return total.add(routeAmount.amount);\n  }, CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n\n  var missingAmount = amount.subtract(totalAmount);\n\n  if (missingAmount.greaterThan(0)) {\n    log.info({\n      missingAmount: missingAmount.quotient.toString()\n    }, \"Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.\");\n    routeAmounts[routeAmounts.length - 1].amount = routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n  }\n\n  log.info({\n    routes: routeAmountsToString(routeAmounts),\n    numSplits: routeAmounts.length,\n    amount: amount.toExact(),\n    quote: swapRoute.quote.toExact(),\n    quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(2),\n    estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(2),\n    estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(2)\n  }, \"Found best swap route. \".concat(routeAmounts.length, \" split.\"));\n  return swapRoute;\n}\nexport function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig) {\n  // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n  var percentToSortedQuotes = _.mapValues(percentToQuotes, function (routeQuotes) {\n    return routeQuotes.sort(function (routeQuoteA, routeQuoteB) {\n      if (routeType == TradeType.EXACT_INPUT) {\n        return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n      } else {\n        return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n      }\n    });\n  });\n\n  log.info({\n    percentToTop5SortedQuotes: _.mapValues(percentToSortedQuotes, function (ps) {\n      return _.map(ps.slice(0, 5), function (p) {\n        return {\n          protocol: p.protocol,\n          route: routeToString(p.route),\n          percent: p.percent,\n          quote: p.quoteAdjustedForGas.toFixed(2)\n        };\n      });\n    })\n  }, 'Top 5 Quotes for each percentage');\n  var quoteCompFn = routeType == TradeType.EXACT_INPUT ? function (a, b) {\n    return a.greaterThan(b);\n  } : function (a, b) {\n    return a.lessThan(b);\n  };\n\n  var sumFn = function sumFn(currencyAmounts) {\n    var sum = currencyAmounts[0];\n\n    for (var i = 1; i < currencyAmounts.length; i++) {\n      sum = sum.add(currencyAmounts[i]);\n    }\n\n    return sum;\n  };\n\n  var bestQuote;\n  var bestSwap; // Min-heap for tracking the 5 best swaps given some number of splits.\n\n  var bestSwapsPerSplit = new FixedReverseHeap(Array, function (a, b) {\n    return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n  }, 5);\n  var minSplits = routingConfig.minSplits,\n      maxSplits = routingConfig.maxSplits,\n      forceCrossProtocol = routingConfig.forceCrossProtocol;\n\n  if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n    log.info({\n      percentToSortedQuotes: _.mapValues(percentToSortedQuotes, function (p) {\n        return p.length;\n      })\n    }, 'Did not find a valid route without any splits. Continuing search anyway.');\n  } else {\n    bestQuote = by(percentToSortedQuotes[100][0]);\n    bestSwap = [percentToSortedQuotes[100][0]];\n\n    var _iterator2 = _createForOfIteratorHelper(percentToSortedQuotes[100].slice(0, 5)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var routeWithQuote = _step2.value;\n        bestSwapsPerSplit.push({\n          quote: by(routeWithQuote),\n          routes: [routeWithQuote]\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n\n\n  var queue = new Queue(); // First we seed BFS queue with the best quotes for each percentage.\n  // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n  // We will explore the various combinations from each node.\n\n  for (var i = percents.length; i >= 0; i--) {\n    var percent = percents[i];\n\n    if (!percentToSortedQuotes[percent]) {\n      continue;\n    }\n\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][0]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: false\n    });\n\n    if (!percentToSortedQuotes[percent] || !percentToSortedQuotes[percent][1]) {\n      continue;\n    }\n\n    queue.enqueue({\n      curRoutes: [percentToSortedQuotes[percent][1]],\n      percentIndex: i,\n      remainingPercent: 100 - percent,\n      special: true\n    });\n  }\n\n  var splits = 1;\n  var startedSplit = Date.now();\n\n  while (queue.size > 0) {\n    metric.putMetric(\"Split\".concat(splits, \"Done\"), Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n    startedSplit = Date.now();\n    log.info({\n      top5: _.map(Array.from(bestSwapsPerSplit.consume()), function (q) {\n        return \"\".concat(q.quote.toExact(), \" (\").concat(_(q.routes).map(function (r) {\n          return r.toString();\n        }).join(', '), \")\");\n      }),\n      onQueue: queue.size\n    }, \"Top 5 with \".concat(splits, \" splits\"));\n    bestSwapsPerSplit.clear(); // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n\n    var layer = queue.size;\n    splits++; // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n\n    if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n      break;\n    }\n\n    if (splits > maxSplits) {\n      log.info('Max splits reached. Stopping search.');\n      metric.putMetric(\"MaxSplitsHitReached\", 1, MetricLoggerUnit.Count);\n      break;\n    }\n\n    while (layer > 0) {\n      layer--;\n\n      var _queue$dequeue = queue.dequeue(),\n          remainingPercent = _queue$dequeue.remainingPercent,\n          curRoutes = _queue$dequeue.curRoutes,\n          percentIndex = _queue$dequeue.percentIndex,\n          special = _queue$dequeue.special; // For all other percentages, add a new potential route.\n      // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n      // 50% + new 10% route, 50% + new 20% route, etc.\n\n\n      for (var _i = percentIndex; _i >= 0; _i--) {\n        var percentA = percents[_i];\n\n        if (percentA > remainingPercent) {\n          continue;\n        } // At some point the amount * percentage is so small that the quoter is unable to get\n        // a quote. In this case there could be no quotes for that percentage.\n\n\n        if (!percentToSortedQuotes[percentA]) {\n          continue;\n        }\n\n        var candidateRoutesA = percentToSortedQuotes[percentA]; // Find the best route in the complimentary percentage that doesn't re-use a pool already\n        // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n        // so it would make the quotes inaccurate.\n\n        var routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n\n        if (!routeWithQuoteA) {\n          continue;\n        }\n\n        var remainingPercentNew = remainingPercent - percentA;\n        var curRoutesNew = [].concat(_toConsumableArray(curRoutes), [routeWithQuoteA]); // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n\n        if (remainingPercentNew == 0 && splits >= minSplits) {\n          var quotesNew = _.map(curRoutesNew, function (r) {\n            return by(r);\n          });\n\n          var quoteNew = sumFn(quotesNew);\n          bestSwapsPerSplit.push({\n            quote: quoteNew,\n            routes: curRoutesNew\n          });\n\n          if (!bestQuote || quoteCompFn(quoteNew, bestQuote)) {\n            bestQuote = quoteNew;\n            bestSwap = curRoutesNew; // Temporary experiment.\n\n            if (special) {\n              metric.putMetric(\"BestSwapNotPickingBestForPercent\", 1, MetricLoggerUnit.Count);\n            }\n          }\n        } else {\n          queue.enqueue({\n            curRoutes: curRoutesNew,\n            remainingPercent: remainingPercentNew,\n            percentIndex: _i,\n            special: special\n          });\n        }\n      }\n    }\n  }\n\n  if (!bestSwap) {\n    log.info(\"Could not find a valid swap\");\n    return undefined;\n  }\n\n  var postSplitNow = Date.now();\n  var quoteGasAdjusted = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n    return routeWithValidQuote.quoteAdjustedForGas;\n  }));\n\n  var estimatedGasUsed = _(bestSwap).map(function (routeWithValidQuote) {\n    return routeWithValidQuote.gasEstimate;\n  }).reduce(function (sum, routeWithValidQuote) {\n    return sum.add(routeWithValidQuote);\n  }, BigNumber.from(0)); // Each route can use a different stablecoin to account its gas costs.\n  // They should all be pegged, and this is just an estimate, so we do a merge\n  // to an arbitrary stable.\n\n\n  if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n    throw new Error(\"Could not find a USD token for computing gas costs on \".concat(chainId));\n  }\n\n  var usdToken = usdGasTokensByChain[chainId][0];\n  var usdTokenDecimals = usdToken.decimals; // For each gas estimate, normalize decimals to that of the chosen usd token.\n\n  var estimatedGasUsedUSDs = _(bestSwap).map(function (routeWithValidQuote) {\n    var decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n\n    if (decimalsDiff == 0) {\n      return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n    }\n\n    return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n  }).value();\n\n  var estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n  log.info({\n    estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n    normalizedUsdToken: usdToken,\n    routeUSDGasEstimates: _.map(bestSwap, function (b) {\n      return \"\".concat(b.percent, \"% \").concat(routeToString(b.route), \" \").concat(b.gasCostInUSD.toExact());\n    })\n  }, 'USD gas estimates of best route');\n  var estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n    return routeWithValidQuote.gasCostInToken;\n  }));\n  var quote = sumFn(_.map(bestSwap, function (routeWithValidQuote) {\n    return routeWithValidQuote.quote;\n  }));\n  var routeWithQuotes = bestSwap.sort(function (routeAmountA, routeAmountB) {\n    return routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1;\n  });\n  metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n  return {\n    quote: quote,\n    quoteGasAdjusted: quoteGasAdjusted,\n    estimatedGasUsed: estimatedGasUsed,\n    estimatedGasUsedUSD: estimatedGasUsedUSD,\n    estimatedGasUsedQuoteToken: estimatedGasUsedQuoteToken,\n    routes: routeWithQuotes\n  };\n} // We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\n\nvar findFirstRouteNotUsingUsedPools = function findFirstRouteNotUsingUsedPools(usedRoutes, candidateRouteQuotes, forceCrossProtocol) {\n  var poolAddressSet = new Set();\n\n  var usedPoolAddresses = _(usedRoutes).flatMap(function (r) {\n    return r.poolAddresses;\n  }).value();\n\n  var _iterator3 = _createForOfIteratorHelper(usedPoolAddresses),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var poolAddress = _step3.value;\n      poolAddressSet.add(poolAddress);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var protocolsSet = new Set();\n\n  var usedProtocols = _(usedRoutes).flatMap(function (r) {\n    return r.protocol;\n  }).uniq().value();\n\n  var _iterator4 = _createForOfIteratorHelper(usedProtocols),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var protocol = _step4.value;\n      protocolsSet.add(protocol);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(candidateRouteQuotes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var routeQuote = _step5.value;\n      var poolAddresses = routeQuote.poolAddresses,\n          _protocol = routeQuote.protocol;\n\n      if (poolAddresses.some(function (poolAddress) {\n        return poolAddressSet.has(poolAddress);\n      })) {\n        continue;\n      } // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n      // consideration of routes that come from the same protocol as a used route.\n\n\n      var needToForce = forceCrossProtocol && protocolsSet.size == 1;\n\n      if (needToForce && protocolsSet.has(_protocol)) {\n        continue;\n      }\n\n      return routeQuote;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return null;\n};","map":{"version":3,"sources":["../../../../../../src/routers/alpha-router/functions/best-swap-route.ts"],"names":[],"mappings":";;AAAA,SAAS,SAAT,QAA0B,mBAA1B;AACA,SAAS,SAAT,QAA0B,QAA1B;AACA,OAAO,IAAP,MAAiB,MAAjB;AACA,OAAO,CAAP,MAAc,QAAd;AACA,SAAS,gBAAT,EAA2B,KAA3B,QAAwC,WAAxC;AAEA,SAAS,cAAT,QAA+B,uBAA/B;AACA,SAAS,GAAT,QAAoB,mBAApB;AACA,SAAS,MAAT,EAAiB,gBAAjB,QAAyC,sBAAzC;AACA,SAAS,oBAAT,EAA+B,aAA/B,QAAoD,sBAApD;AAEA,SAAS,mBAAT,QAAoC,eAApC;AAGA,OAAM,SAAU,gBAAV,CACJ,MADI,EAEJ,QAFI,EAGJ,qBAHI,EAIJ,SAJI,EAKJ,OALI,EAMJ,aANI,EAM4B;AAShC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ,CATgC,CAWhC;AACA;;AACA,MAAM,eAAe,GAAiD,EAAtE;;AAbgC,6CAcE,qBAdF;AAAA;;AAAA;AAchC,wDAAyD;AAAA,UAA9C,mBAA8C;;AACvD,UAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAApB,EAAmD;AACjD,QAAA,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAAf,GAA+C,EAA/C;AACD;;AACD,MAAA,eAAe,CAAC,mBAAmB,CAAC,OAArB,CAAf,CAA8C,IAA9C,CAAmD,mBAAnD;AACD;AAnB+B;AAAA;AAAA;AAAA;AAAA;;AAqBhC,EAAA,MAAM,CAAC,SAAP,CACE,iCADF,EAEE,IAAI,CAAC,GAAL,KAAa,GAFf,EAGE,gBAAgB,CAAC,YAHnB,EArBgC,CA2BhC;;AACA,MAAM,SAAS,GAAG,kBAAkB,CAClC,SADkC,EAElC,eAFkC,EAGlC,QAHkC,EAIlC,OAJkC,EAKlC,UAAC,EAAD;AAAA,WAA6B,EAAE,CAAC,mBAAhC;AAAA,GALkC,EAMlC,aANkC,CAApC,CA5BgC,CAqChC;;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,WAAO,IAAP;AACD,GAxC+B,CA0ChC;AACA;AACA;AACA;AACA;;;AACA,MAAgB,YAAhB,GAAiC,SAAjC,CAAQ,MAAR;;AACA,MAAM,WAAW,GAAG,CAAC,CAAC,MAAF,CAClB,YADkB,EAElB,UAAC,KAAD,EAAQ,WAAR;AAAA,WAAwB,KAAK,CAAC,GAAN,CAAU,WAAW,CAAC,MAAtB,CAAxB;AAAA,GAFkB,EAGlB,cAAc,CAAC,aAAf,CAA6B,YAAY,CAAC,CAAD,CAAZ,CAAiB,MAAjB,CAAwB,QAArD,EAA+D,CAA/D,CAHkB,CAApB;;AAMA,MAAM,aAAa,GAAG,MAAM,CAAC,QAAP,CAAgB,WAAhB,CAAtB;;AACA,MAAI,aAAa,CAAC,WAAd,CAA0B,CAA1B,CAAJ,EAAkC;AAChC,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,aAAa,EAAE,aAAa,CAAC,QAAd,CAAuB,QAAvB;AADjB,KADF;AAOA,IAAA,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAZ,CAAuC,MAAvC,GACE,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAZ,CAAuC,MAAvC,CAA8C,GAA9C,CAAkD,aAAlD,CADF;AAED;;AAED,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,MAAM,EAAE,oBAAoB,CAAC,YAAD,CAD9B;AAEE,IAAA,SAAS,EAAE,YAAY,CAAC,MAF1B;AAGE,IAAA,MAAM,EAAE,MAAM,CAAC,OAAP,EAHV;AAIE,IAAA,KAAK,EAAE,SAAS,CAAC,KAAV,CAAgB,OAAhB,EAJT;AAKE,IAAA,gBAAgB,EAAE,SAAS,CAAC,gBAAV,CAA2B,OAA3B,CAAmC,CAAnC,CALpB;AAME,IAAA,eAAe,EAAE,SAAS,CAAC,mBAAV,CAA8B,OAA9B,CAAsC,CAAtC,CANnB;AAOE,IAAA,iBAAiB,EAAE,SAAS,CAAC,0BAAV,CAAqC,OAArC,CAA6C,CAA7C;AAPrB,GADF,mCAU4B,YAAY,CAAC,MAVzC;AAaA,SAAO,SAAP;AACD;AAED,OAAM,SAAU,kBAAV,CACJ,SADI,EAEJ,eAFI,EAGJ,QAHI,EAIJ,OAJI,EAKJ,EALI,EAMJ,aANI,EAM4B;AAWhC;AACA,MAAM,qBAAqB,GAAG,CAAC,CAAC,SAAF,CAC5B,eAD4B,EAE5B,UAAC,WAAD,EAAuC;AACrC,WAAO,WAAW,CAAC,IAAZ,CAAiB,UAAC,WAAD,EAAc,WAAd,EAA6B;AACnD,UAAI,SAAS,IAAI,SAAS,CAAC,WAA3B,EAAwC;AACtC,eAAO,EAAE,CAAC,WAAD,CAAF,CAAgB,WAAhB,CAA4B,EAAE,CAAC,WAAD,CAA9B,IAA+C,CAAC,CAAhD,GAAoD,CAA3D;AACD,OAFD,MAEO;AACL,eAAO,EAAE,CAAC,WAAD,CAAF,CAAgB,QAAhB,CAAyB,EAAE,CAAC,WAAD,CAA3B,IAA4C,CAAC,CAA7C,GAAiD,CAAxD;AACD;AACF,KANM,CAAP;AAOD,GAV2B,CAA9B;;AAaA,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,yBAAyB,EAAE,CAAC,CAAC,SAAF,CAAY,qBAAZ,EAAmC,UAAC,EAAD;AAAA,aAC5D,CAAC,CAAC,GAAF,CAAM,EAAE,CAAC,KAAH,CAAS,CAAT,EAAY,CAAZ,CAAN,EAAsB,UAAC,CAAD;AAAA,eAAQ;AAC5B,UAAA,QAAQ,EAAE,CAAC,CAAC,QADgB;AAE5B,UAAA,KAAK,EAAE,aAAa,CAAC,CAAC,CAAC,KAAH,CAFQ;AAG5B,UAAA,OAAO,EAAE,CAAC,CAAC,OAHiB;AAI5B,UAAA,KAAK,EAAE,CAAC,CAAC,mBAAF,CAAsB,OAAtB,CAA8B,CAA9B;AAJqB,SAAR;AAAA,OAAtB,CAD4D;AAAA,KAAnC;AAD7B,GADF,EAWE,kCAXF;AAcA,MAAM,WAAW,GACf,SAAS,IAAI,SAAS,CAAC,WAAvB,GACI,UAAC,CAAD,EAAoB,CAApB;AAAA,WAA0C,CAAC,CAAC,WAAF,CAAc,CAAd,CAA1C;AAAA,GADJ,GAEI,UAAC,CAAD,EAAoB,CAApB;AAAA,WAA0C,CAAC,CAAC,QAAF,CAAW,CAAX,CAA1C;AAAA,GAHN;;AAKA,MAAM,KAAK,GAAG,SAAR,KAAQ,CAAC,eAAD,EAAsD;AAClE,QAAI,GAAG,GAAG,eAAe,CAAC,CAAD,CAAzB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,eAAe,CAAC,MAApC,EAA4C,CAAC,EAA7C,EAAiD;AAC/C,MAAA,GAAG,GAAG,GAAG,CAAC,GAAJ,CAAQ,eAAe,CAAC,CAAD,CAAvB,CAAN;AACD;;AACD,WAAO,GAAP;AACD,GAND;;AAQA,MAAI,SAAJ;AACA,MAAI,QAAJ,CArDgC,CAuDhC;;AACA,MAAM,iBAAiB,GAAG,IAAI,gBAAJ,CAIxB,KAJwB,EAKxB,UAAC,CAAD,EAAI,CAAJ,EAAS;AACP,WAAO,WAAW,CAAC,CAAC,CAAC,KAAH,EAAU,CAAC,CAAC,KAAZ,CAAX,GAAgC,CAAC,CAAjC,GAAqC,CAA5C;AACD,GAPuB,EAQxB,CARwB,CAA1B;AAWA,MAAQ,SAAR,GAAqD,aAArD,CAAQ,SAAR;AAAA,MAAmB,SAAnB,GAAqD,aAArD,CAAmB,SAAnB;AAAA,MAA8B,kBAA9B,GAAqD,aAArD,CAA8B,kBAA9B;;AAEA,MAAI,CAAC,qBAAqB,CAAC,GAAD,CAAtB,IAA+B,SAAS,GAAG,CAA3C,IAAgD,kBAApD,EAAwE;AACtE,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,qBAAqB,EAAE,CAAC,CAAC,SAAF,CACrB,qBADqB,EAErB,UAAC,CAAD;AAAA,eAAO,CAAC,CAAC,MAAT;AAAA,OAFqB;AADzB,KADF,EAOE,0EAPF;AASD,GAVD,MAUO;AACL,IAAA,SAAS,GAAG,EAAE,CAAC,qBAAqB,CAAC,GAAD,CAArB,CAA2B,CAA3B,CAAD,CAAd;AACA,IAAA,QAAQ,GAAG,CAAC,qBAAqB,CAAC,GAAD,CAArB,CAA2B,CAA3B,CAAD,CAAX;;AAFK,gDAIwB,qBAAqB,CAAC,GAAD,CAArB,CAA2B,KAA3B,CAAiC,CAAjC,EAAoC,CAApC,CAJxB;AAAA;;AAAA;AAIL,6DAAqE;AAAA,YAA1D,cAA0D;AACnE,QAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,UAAA,KAAK,EAAE,EAAE,CAAC,cAAD,CADY;AAErB,UAAA,MAAM,EAAE,CAAC,cAAD;AAFa,SAAvB;AAID;AATI;AAAA;AAAA;AAAA;AAAA;AAUN,GAzF+B,CA2FhC;;;AACA,MAAM,KAAK,GAAG,IAAI,KAAJ,EAAd,CA5FgC,CAmGhC;AACA;AACA;;AACA,OAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAtB,EAA8B,CAAC,IAAI,CAAnC,EAAsC,CAAC,EAAvC,EAA2C;AACzC,QAAM,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAxB;;AAEA,QAAI,CAAC,qBAAqB,CAAC,OAAD,CAA1B,EAAqC;AACnC;AACD;;AAED,IAAA,KAAK,CAAC,OAAN,CAAc;AACZ,MAAA,SAAS,EAAE,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAAD,CADC;AAEZ,MAAA,YAAY,EAAE,CAFF;AAGZ,MAAA,gBAAgB,EAAE,MAAM,OAHZ;AAIZ,MAAA,OAAO,EAAE;AAJG,KAAd;;AAOA,QACE,CAAC,qBAAqB,CAAC,OAAD,CAAtB,IACA,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAFH,EAGE;AACA;AACD;;AAED,IAAA,KAAK,CAAC,OAAN,CAAc;AACZ,MAAA,SAAS,EAAE,CAAC,qBAAqB,CAAC,OAAD,CAArB,CAAgC,CAAhC,CAAD,CADC;AAEZ,MAAA,YAAY,EAAE,CAFF;AAGZ,MAAA,gBAAgB,EAAE,MAAM,OAHZ;AAIZ,MAAA,OAAO,EAAE;AAJG,KAAd;AAMD;;AAED,MAAI,MAAM,GAAG,CAAb;AACA,MAAI,YAAY,GAAG,IAAI,CAAC,GAAL,EAAnB;;AAEA,SAAO,KAAK,CAAC,IAAN,GAAa,CAApB,EAAuB;AACrB,IAAA,MAAM,CAAC,SAAP,gBACU,MADV,WAEE,IAAI,CAAC,GAAL,KAAa,YAFf,EAGE,gBAAgB,CAAC,YAHnB;AAMA,IAAA,YAAY,GAAG,IAAI,CAAC,GAAL,EAAf;AAEA,IAAA,GAAG,CAAC,IAAJ,CACE;AACE,MAAA,IAAI,EAAE,CAAC,CAAC,GAAF,CACJ,KAAK,CAAC,IAAN,CAAW,iBAAiB,CAAC,OAAlB,EAAX,CADI,EAEJ,UAAC,CAAD;AAAA,yBACK,CAAC,CAAC,KAAF,CAAQ,OAAR,EADL,eAC2B,CAAC,CAAC,CAAC,CAAC,MAAH,CAAD,CACtB,GADsB,CAClB,UAAC,CAAD;AAAA,iBAAO,CAAC,CAAC,QAAF,EAAP;AAAA,SADkB,EAEtB,IAFsB,CAEjB,IAFiB,CAD3B;AAAA,OAFI,CADR;AAQE,MAAA,OAAO,EAAE,KAAK,CAAC;AARjB,KADF,uBAWgB,MAXhB;AAcA,IAAA,iBAAiB,CAAC,KAAlB,GAvBqB,CAyBrB;;AACA,QAAI,KAAK,GAAG,KAAK,CAAC,IAAlB;AACA,IAAA,MAAM,GA3Be,CA6BrB;;AACA,QAAI,MAAM,IAAI,CAAV,IAAe,QAAf,IAA2B,QAAQ,CAAC,MAAT,GAAkB,MAAM,GAAG,CAA1D,EAA6D;AAC3D;AACD;;AAED,QAAI,MAAM,GAAG,SAAb,EAAwB;AACtB,MAAA,GAAG,CAAC,IAAJ,CAAS,sCAAT;AACA,MAAA,MAAM,CAAC,SAAP,wBAAwC,CAAxC,EAA2C,gBAAgB,CAAC,KAA5D;AACA;AACD;;AAED,WAAO,KAAK,GAAG,CAAf,EAAkB;AAChB,MAAA,KAAK;;AAEL,2BACE,KAAK,CAAC,OAAN,EADF;AAAA,UAAQ,gBAAR,kBAAQ,gBAAR;AAAA,UAA0B,SAA1B,kBAA0B,SAA1B;AAAA,UAAqC,YAArC,kBAAqC,YAArC;AAAA,UAAmD,OAAnD,kBAAmD,OAAnD,CAHgB,CAMhB;AACA;AACA;;;AACA,WAAK,IAAI,EAAC,GAAG,YAAb,EAA2B,EAAC,IAAI,CAAhC,EAAmC,EAAC,EAApC,EAAwC;AACtC,YAAM,QAAQ,GAAG,QAAQ,CAAC,EAAD,CAAzB;;AAEA,YAAI,QAAQ,GAAG,gBAAf,EAAiC;AAC/B;AACD,SALqC,CAOtC;AACA;;;AACA,YAAI,CAAC,qBAAqB,CAAC,QAAD,CAA1B,EAAsC;AACpC;AACD;;AAED,YAAM,gBAAgB,GAAG,qBAAqB,CAAC,QAAD,CAA9C,CAbsC,CAetC;AACA;AACA;;AACA,YAAM,eAAe,GAAG,+BAA+B,CACrD,SADqD,EAErD,gBAFqD,EAGrD,kBAHqD,CAAvD;;AAMA,YAAI,CAAC,eAAL,EAAsB;AACpB;AACD;;AAED,YAAM,mBAAmB,GAAG,gBAAgB,GAAG,QAA/C;AACA,YAAM,YAAY,gCAAO,SAAP,IAAkB,eAAlB,EAAlB,CA7BsC,CA+BtC;;AACA,YAAI,mBAAmB,IAAI,CAAvB,IAA4B,MAAM,IAAI,SAA1C,EAAqD;AACnD,cAAM,SAAS,GAAG,CAAC,CAAC,GAAF,CAAM,YAAN,EAAoB,UAAC,CAAD;AAAA,mBAAO,EAAE,CAAC,CAAD,CAAT;AAAA,WAApB,CAAlB;;AACA,cAAM,QAAQ,GAAG,KAAK,CAAC,SAAD,CAAtB;AAEA,UAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,YAAA,KAAK,EAAE,QADc;AAErB,YAAA,MAAM,EAAE;AAFa,WAAvB;;AAKA,cAAI,CAAC,SAAD,IAAc,WAAW,CAAC,QAAD,EAAW,SAAX,CAA7B,EAAoD;AAClD,YAAA,SAAS,GAAG,QAAZ;AACA,YAAA,QAAQ,GAAG,YAAX,CAFkD,CAIlD;;AACA,gBAAI,OAAJ,EAAa;AACX,cAAA,MAAM,CAAC,SAAP,qCAEE,CAFF,EAGE,gBAAgB,CAAC,KAHnB;AAKD;AACF;AACF,SAtBD,MAsBO;AACL,UAAA,KAAK,CAAC,OAAN,CAAc;AACZ,YAAA,SAAS,EAAE,YADC;AAEZ,YAAA,gBAAgB,EAAE,mBAFN;AAGZ,YAAA,YAAY,EAAE,EAHF;AAIZ,YAAA,OAAO,EAAP;AAJY,WAAd;AAMD;AACF;AACF;AACF;;AAED,MAAI,CAAC,QAAL,EAAe;AACb,IAAA,GAAG,CAAC,IAAJ;AACA,WAAO,SAAP;AACD;;AAED,MAAM,YAAY,GAAG,IAAI,CAAC,GAAL,EAArB;AAEA,MAAM,gBAAgB,GAAG,KAAK,CAC5B,CAAC,CAAC,GAAF,CACE,QADF,EAEE,UAAC,mBAAD;AAAA,WAAyB,mBAAmB,CAAC,mBAA7C;AAAA,GAFF,CAD4B,CAA9B;;AAOA,MAAM,gBAAgB,GAAG,CAAC,CAAC,QAAD,CAAD,CACtB,GADsB,CAClB,UAAC,mBAAD;AAAA,WAAyB,mBAAmB,CAAC,WAA7C;AAAA,GADkB,EAEtB,MAFsB,CAGrB,UAAC,GAAD,EAAM,mBAAN;AAAA,WAA8B,GAAG,CAAC,GAAJ,CAAQ,mBAAR,CAA9B;AAAA,GAHqB,EAIrB,SAAS,CAAC,IAAV,CAAe,CAAf,CAJqB,CAAzB,CAvQgC,CA8QhC;AACA;AACA;;;AACA,MAAI,CAAC,mBAAmB,CAAC,OAAD,CAApB,IAAiC,CAAC,mBAAmB,CAAC,OAAD,CAAnB,CAA8B,CAA9B,CAAtC,EAAwE;AACtE,UAAM,IAAI,KAAJ,iEACqD,OADrD,EAAN;AAGD;;AACD,MAAM,QAAQ,GAAG,mBAAmB,CAAC,OAAD,CAAnB,CAA8B,CAA9B,CAAjB;AACA,MAAM,gBAAgB,GAAG,QAAQ,CAAC,QAAlC,CAvRgC,CAyRhC;;AACA,MAAM,oBAAoB,GAAG,CAAC,CAAC,QAAD,CAAD,CAC1B,GAD0B,CACtB,UAAC,mBAAD,EAAwB;AAC3B,QAAM,YAAY,GAChB,gBAAgB,GAAG,mBAAmB,CAAC,YAApB,CAAiC,QAAjC,CAA0C,QAD/D;;AAGA,QAAI,YAAY,IAAI,CAApB,EAAuB;AACrB,aAAO,cAAc,CAAC,aAAf,CACL,QADK,EAEL,mBAAmB,CAAC,YAApB,CAAiC,QAF5B,CAAP;AAID;;AAED,WAAO,cAAc,CAAC,aAAf,CACL,QADK,EAEL,IAAI,CAAC,QAAL,CACE,mBAAmB,CAAC,YAApB,CAAiC,QADnC,EAEE,IAAI,CAAC,YAAL,CAAkB,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAlB,EAAmC,IAAI,CAAC,MAAL,CAAY,YAAZ,CAAnC,CAFF,CAFK,CAAP;AAOD,GAnB0B,EAoB1B,KApB0B,EAA7B;;AAsBA,MAAM,mBAAmB,GAAG,KAAK,CAAC,oBAAD,CAAjC;AACA,EAAA,GAAG,CAAC,IAAJ,CACE;AACE,IAAA,mBAAmB,EAAE,mBAAmB,CAAC,OAApB,EADvB;AAEE,IAAA,kBAAkB,EAAE,QAFtB;AAGE,IAAA,oBAAoB,EAAE,CAAC,CAAC,GAAF,CACpB,QADoB,EAEpB,UAAC,CAAD;AAAA,uBACK,CAAC,CAAC,OADP,eACmB,aAAa,CAAC,CAAC,CAAC,KAAH,CADhC,cAC6C,CAAC,CAAC,YAAF,CAAe,OAAf,EAD7C;AAAA,KAFoB;AAHxB,GADF,EAUE,iCAVF;AAaA,MAAM,0BAA0B,GAAG,KAAK,CACtC,CAAC,CAAC,GAAF,CAAM,QAAN,EAAgB,UAAC,mBAAD;AAAA,WAAyB,mBAAmB,CAAC,cAA7C;AAAA,GAAhB,CADsC,CAAxC;AAIA,MAAM,KAAK,GAAG,KAAK,CACjB,CAAC,CAAC,GAAF,CAAM,QAAN,EAAgB,UAAC,mBAAD;AAAA,WAAyB,mBAAmB,CAAC,KAA7C;AAAA,GAAhB,CADiB,CAAnB;AAIA,MAAM,eAAe,GAAG,QAAQ,CAAC,IAAT,CAAc,UAAC,YAAD,EAAe,YAAf;AAAA,WACpC,YAAY,CAAC,MAAb,CAAoB,WAApB,CAAgC,YAAY,CAAC,MAA7C,IAAuD,CAAvD,GAA2D,CAAC,CADxB;AAAA,GAAd,CAAxB;AAIA,EAAA,MAAM,CAAC,SAAP,CACE,eADF,EAEE,IAAI,CAAC,GAAL,KAAa,YAFf,EAGE,gBAAgB,CAAC,YAHnB;AAMA,SAAO;AACL,IAAA,KAAK,EAAL,KADK;AAEL,IAAA,gBAAgB,EAAhB,gBAFK;AAGL,IAAA,gBAAgB,EAAhB,gBAHK;AAIL,IAAA,mBAAmB,EAAnB,mBAJK;AAKL,IAAA,0BAA0B,EAA1B,0BALK;AAML,IAAA,MAAM,EAAE;AANH,GAAP;AAQD,C,CAED;AACA;;AACA,IAAM,+BAA+B,GAAG,SAAlC,+BAAkC,CACtC,UADsC,EAEtC,oBAFsC,EAGtC,kBAHsC,EAIR;AAC9B,MAAM,cAAc,GAAG,IAAI,GAAJ,EAAvB;;AACA,MAAM,iBAAiB,GAAG,CAAC,CAAC,UAAD,CAAD,CACvB,OADuB,CACf,UAAC,CAAD;AAAA,WAAO,CAAC,CAAC,aAAT;AAAA,GADe,EAEvB,KAFuB,EAA1B;;AAF8B,8CAMN,iBANM;AAAA;;AAAA;AAM9B,2DAA2C;AAAA,UAAlC,WAAkC;AACzC,MAAA,cAAc,CAAC,GAAf,CAAmB,WAAnB;AACD;AAR6B;AAAA;AAAA;AAAA;AAAA;;AAU9B,MAAM,YAAY,GAAG,IAAI,GAAJ,EAArB;;AACA,MAAM,aAAa,GAAG,CAAC,CAAC,UAAD,CAAD,CACnB,OADmB,CACX,UAAC,CAAD;AAAA,WAAO,CAAC,CAAC,QAAT;AAAA,GADW,EAEnB,IAFmB,GAGnB,KAHmB,EAAtB;;AAX8B,8CAgBT,aAhBS;AAAA;;AAAA;AAgB9B,2DAAoC;AAAA,UAA3B,QAA2B;AAClC,MAAA,YAAY,CAAC,GAAb,CAAiB,QAAjB;AACD;AAlB6B;AAAA;AAAA;AAAA;AAAA;;AAAA,8CAoBL,oBApBK;AAAA;;AAAA;AAoB9B,2DAA+C;AAAA,UAApC,UAAoC;AAC7C,UAAQ,aAAR,GAAoC,UAApC,CAAQ,aAAR;AAAA,UAAuB,SAAvB,GAAoC,UAApC,CAAuB,QAAvB;;AAEA,UAAI,aAAa,CAAC,IAAd,CAAmB,UAAC,WAAD;AAAA,eAAiB,cAAc,CAAC,GAAf,CAAmB,WAAnB,CAAjB;AAAA,OAAnB,CAAJ,EAA0E;AACxE;AACD,OAL4C,CAO7C;AACA;;;AACA,UAAM,WAAW,GAAG,kBAAkB,IAAI,YAAY,CAAC,IAAb,IAAqB,CAA/D;;AACA,UAAI,WAAW,IAAI,YAAY,CAAC,GAAb,CAAiB,SAAjB,CAAnB,EAA+C;AAC7C;AACD;;AAED,aAAO,UAAP;AACD;AAnC6B;AAAA;AAAA;AAAA;AAAA;;AAqC9B,SAAO,IAAP;AACD,CA1CD","sourceRoot":"","sourcesContent":["import { TradeType } from '@uniswap/sdk-core';\nimport { BigNumber } from 'ethers';\nimport JSBI from 'jsbi';\nimport _ from 'lodash';\nimport { FixedReverseHeap, Queue } from 'mnemonist';\nimport { CurrencyAmount } from '../../../util/amounts';\nimport { log } from '../../../util/log';\nimport { metric, MetricLoggerUnit } from '../../../util/metric';\nimport { routeAmountsToString, routeToString } from '../../../util/routes';\nimport { usdGasTokensByChain } from '../gas-models';\nexport function getBestSwapRoute(amount, percents, routesWithValidQuotes, routeType, chainId, routingConfig) {\n    const now = Date.now();\n    // Build a map of percentage of the input to list of valid quotes.\n    // Quotes can be null for a variety of reasons (not enough liquidity etc), so we drop them here too.\n    const percentToQuotes = {};\n    for (const routeWithValidQuote of routesWithValidQuotes) {\n        if (!percentToQuotes[routeWithValidQuote.percent]) {\n            percentToQuotes[routeWithValidQuote.percent] = [];\n        }\n        percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);\n    }\n    metric.putMetric('BuildRouteWithValidQuoteObjects', Date.now() - now, MetricLoggerUnit.Milliseconds);\n    // Given all the valid quotes for each percentage find the optimal route.\n    const swapRoute = getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, (rq) => rq.quoteAdjustedForGas, routingConfig);\n    // It is possible we were unable to find any valid route given the quotes.\n    if (!swapRoute) {\n        return null;\n    }\n    // Due to potential loss of precision when taking percentages of the input it is possible that the sum of the amounts of each\n    // route of our optimal quote may not add up exactly to exactIn or exactOut.\n    //\n    // We check this here, and if there is a mismatch\n    // add the missing amount to a random route. The missing amount size should be neglible so the quote should still be highly accurate.\n    const { routes: routeAmounts } = swapRoute;\n    const totalAmount = _.reduce(routeAmounts, (total, routeAmount) => total.add(routeAmount.amount), CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0));\n    const missingAmount = amount.subtract(totalAmount);\n    if (missingAmount.greaterThan(0)) {\n        log.info({\n            missingAmount: missingAmount.quotient.toString(),\n        }, `Optimal route's amounts did not equal exactIn/exactOut total. Adding missing amount to last route in array.`);\n        routeAmounts[routeAmounts.length - 1].amount =\n            routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);\n    }\n    log.info({\n        routes: routeAmountsToString(routeAmounts),\n        numSplits: routeAmounts.length,\n        amount: amount.toExact(),\n        quote: swapRoute.quote.toExact(),\n        quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(2),\n        estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(2),\n        estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(2),\n    }, `Found best swap route. ${routeAmounts.length} split.`);\n    return swapRoute;\n}\nexport function getBestSwapRouteBy(routeType, percentToQuotes, percents, chainId, by, routingConfig) {\n    // Build a map of percentage to sorted list of quotes, with the biggest quote being first in the list.\n    const percentToSortedQuotes = _.mapValues(percentToQuotes, (routeQuotes) => {\n        return routeQuotes.sort((routeQuoteA, routeQuoteB) => {\n            if (routeType == TradeType.EXACT_INPUT) {\n                return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;\n            }\n            else {\n                return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;\n            }\n        });\n    });\n    log.info({\n        percentToTop5SortedQuotes: _.mapValues(percentToSortedQuotes, (ps) => _.map(ps.slice(0, 5), (p) => ({\n            protocol: p.protocol,\n            route: routeToString(p.route),\n            percent: p.percent,\n            quote: p.quoteAdjustedForGas.toFixed(2),\n        }))),\n    }, 'Top 5 Quotes for each percentage');\n    const quoteCompFn = routeType == TradeType.EXACT_INPUT\n        ? (a, b) => a.greaterThan(b)\n        : (a, b) => a.lessThan(b);\n    const sumFn = (currencyAmounts) => {\n        let sum = currencyAmounts[0];\n        for (let i = 1; i < currencyAmounts.length; i++) {\n            sum = sum.add(currencyAmounts[i]);\n        }\n        return sum;\n    };\n    let bestQuote;\n    let bestSwap;\n    // Min-heap for tracking the 5 best swaps given some number of splits.\n    const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {\n        return quoteCompFn(a.quote, b.quote) ? -1 : 1;\n    }, 5);\n    const { minSplits, maxSplits, forceCrossProtocol } = routingConfig;\n    if (!percentToSortedQuotes[100] || minSplits > 1 || forceCrossProtocol) {\n        log.info({\n            percentToSortedQuotes: _.mapValues(percentToSortedQuotes, (p) => p.length),\n        }, 'Did not find a valid route without any splits. Continuing search anyway.');\n    }\n    else {\n        bestQuote = by(percentToSortedQuotes[100][0]);\n        bestSwap = [percentToSortedQuotes[100][0]];\n        for (const routeWithQuote of percentToSortedQuotes[100].slice(0, 5)) {\n            bestSwapsPerSplit.push({\n                quote: by(routeWithQuote),\n                routes: [routeWithQuote],\n            });\n        }\n    }\n    // We do a BFS. Each additional node in a path represents us adding an additional split to the route.\n    const queue = new Queue();\n    // First we seed BFS queue with the best quotes for each percentage.\n    // i.e. [best quote when sending 10% of amount, best quote when sending 20% of amount, ...]\n    // We will explore the various combinations from each node.\n    for (let i = percents.length; i >= 0; i--) {\n        const percent = percents[i];\n        if (!percentToSortedQuotes[percent]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][0]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: false,\n        });\n        if (!percentToSortedQuotes[percent] ||\n            !percentToSortedQuotes[percent][1]) {\n            continue;\n        }\n        queue.enqueue({\n            curRoutes: [percentToSortedQuotes[percent][1]],\n            percentIndex: i,\n            remainingPercent: 100 - percent,\n            special: true,\n        });\n    }\n    let splits = 1;\n    let startedSplit = Date.now();\n    while (queue.size > 0) {\n        metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);\n        startedSplit = Date.now();\n        log.info({\n            top5: _.map(Array.from(bestSwapsPerSplit.consume()), (q) => `${q.quote.toExact()} (${_(q.routes)\n                .map((r) => r.toString())\n                .join(', ')})`),\n            onQueue: queue.size,\n        }, `Top 5 with ${splits} splits`);\n        bestSwapsPerSplit.clear();\n        // Size of the queue at this point is the number of potential routes we are investigating for the given number of splits.\n        let layer = queue.size;\n        splits++;\n        // If we didn't improve our quote by adding another split, very unlikely to improve it by splitting more after that.\n        if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {\n            break;\n        }\n        if (splits > maxSplits) {\n            log.info('Max splits reached. Stopping search.');\n            metric.putMetric(`MaxSplitsHitReached`, 1, MetricLoggerUnit.Count);\n            break;\n        }\n        while (layer > 0) {\n            layer--;\n            const { remainingPercent, curRoutes, percentIndex, special } = queue.dequeue();\n            // For all other percentages, add a new potential route.\n            // E.g. if our current aggregated route if missing 50%, we will create new nodes and add to the queue for:\n            // 50% + new 10% route, 50% + new 20% route, etc.\n            for (let i = percentIndex; i >= 0; i--) {\n                const percentA = percents[i];\n                if (percentA > remainingPercent) {\n                    continue;\n                }\n                // At some point the amount * percentage is so small that the quoter is unable to get\n                // a quote. In this case there could be no quotes for that percentage.\n                if (!percentToSortedQuotes[percentA]) {\n                    continue;\n                }\n                const candidateRoutesA = percentToSortedQuotes[percentA];\n                // Find the best route in the complimentary percentage that doesn't re-use a pool already\n                // used in the current route. Re-using pools is not allowed as each swap through a pool changes its liquidity,\n                // so it would make the quotes inaccurate.\n                const routeWithQuoteA = findFirstRouteNotUsingUsedPools(curRoutes, candidateRoutesA, forceCrossProtocol);\n                if (!routeWithQuoteA) {\n                    continue;\n                }\n                const remainingPercentNew = remainingPercent - percentA;\n                const curRoutesNew = [...curRoutes, routeWithQuoteA];\n                // If we've found a route combination that uses all 100%, and it has at least minSplits, update our best route.\n                if (remainingPercentNew == 0 && splits >= minSplits) {\n                    const quotesNew = _.map(curRoutesNew, (r) => by(r));\n                    const quoteNew = sumFn(quotesNew);\n                    bestSwapsPerSplit.push({\n                        quote: quoteNew,\n                        routes: curRoutesNew,\n                    });\n                    if (!bestQuote || quoteCompFn(quoteNew, bestQuote)) {\n                        bestQuote = quoteNew;\n                        bestSwap = curRoutesNew;\n                        // Temporary experiment.\n                        if (special) {\n                            metric.putMetric(`BestSwapNotPickingBestForPercent`, 1, MetricLoggerUnit.Count);\n                        }\n                    }\n                }\n                else {\n                    queue.enqueue({\n                        curRoutes: curRoutesNew,\n                        remainingPercent: remainingPercentNew,\n                        percentIndex: i,\n                        special,\n                    });\n                }\n            }\n        }\n    }\n    if (!bestSwap) {\n        log.info(`Could not find a valid swap`);\n        return undefined;\n    }\n    const postSplitNow = Date.now();\n    const quoteGasAdjusted = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quoteAdjustedForGas));\n    const estimatedGasUsed = _(bestSwap)\n        .map((routeWithValidQuote) => routeWithValidQuote.gasEstimate)\n        .reduce((sum, routeWithValidQuote) => sum.add(routeWithValidQuote), BigNumber.from(0));\n    // Each route can use a different stablecoin to account its gas costs.\n    // They should all be pegged, and this is just an estimate, so we do a merge\n    // to an arbitrary stable.\n    if (!usdGasTokensByChain[chainId] || !usdGasTokensByChain[chainId][0]) {\n        throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n    const usdToken = usdGasTokensByChain[chainId][0];\n    const usdTokenDecimals = usdToken.decimals;\n    // For each gas estimate, normalize decimals to that of the chosen usd token.\n    const estimatedGasUsedUSDs = _(bestSwap)\n        .map((routeWithValidQuote) => {\n        const decimalsDiff = usdTokenDecimals - routeWithValidQuote.gasCostInUSD.currency.decimals;\n        if (decimalsDiff == 0) {\n            return CurrencyAmount.fromRawAmount(usdToken, routeWithValidQuote.gasCostInUSD.quotient);\n        }\n        return CurrencyAmount.fromRawAmount(usdToken, JSBI.multiply(routeWithValidQuote.gasCostInUSD.quotient, JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(decimalsDiff))));\n    })\n        .value();\n    const estimatedGasUsedUSD = sumFn(estimatedGasUsedUSDs);\n    log.info({\n        estimatedGasUsedUSD: estimatedGasUsedUSD.toExact(),\n        normalizedUsdToken: usdToken,\n        routeUSDGasEstimates: _.map(bestSwap, (b) => `${b.percent}% ${routeToString(b.route)} ${b.gasCostInUSD.toExact()}`),\n    }, 'USD gas estimates of best route');\n    const estimatedGasUsedQuoteToken = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.gasCostInToken));\n    const quote = sumFn(_.map(bestSwap, (routeWithValidQuote) => routeWithValidQuote.quote));\n    const routeWithQuotes = bestSwap.sort((routeAmountA, routeAmountB) => routeAmountB.amount.greaterThan(routeAmountA.amount) ? 1 : -1);\n    metric.putMetric('PostSplitDone', Date.now() - postSplitNow, MetricLoggerUnit.Milliseconds);\n    return {\n        quote,\n        quoteGasAdjusted,\n        estimatedGasUsed,\n        estimatedGasUsedUSD,\n        estimatedGasUsedQuoteToken,\n        routes: routeWithQuotes,\n    };\n}\n// We do not allow pools to be re-used across split routes, as swapping through a pool changes the pools state.\n// Given a list of used routes, this function finds the first route in the list of candidate routes that does not re-use an already used pool.\nconst findFirstRouteNotUsingUsedPools = (usedRoutes, candidateRouteQuotes, forceCrossProtocol) => {\n    const poolAddressSet = new Set();\n    const usedPoolAddresses = _(usedRoutes)\n        .flatMap((r) => r.poolAddresses)\n        .value();\n    for (let poolAddress of usedPoolAddresses) {\n        poolAddressSet.add(poolAddress);\n    }\n    const protocolsSet = new Set();\n    const usedProtocols = _(usedRoutes)\n        .flatMap((r) => r.protocol)\n        .uniq()\n        .value();\n    for (let protocol of usedProtocols) {\n        protocolsSet.add(protocol);\n    }\n    for (const routeQuote of candidateRouteQuotes) {\n        const { poolAddresses, protocol } = routeQuote;\n        if (poolAddresses.some((poolAddress) => poolAddressSet.has(poolAddress))) {\n            continue;\n        }\n        // This code is just for debugging. Allows us to force a cross-protocol split route by skipping\n        // consideration of routes that come from the same protocol as a used route.\n        const needToForce = forceCrossProtocol && protocolsSet.size == 1;\n        if (needToForce && protocolsSet.has(protocol)) {\n            continue;\n        }\n        return routeQuote;\n    }\n    return null;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVzdC1zd2FwLXJvdXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL3JvdXRlcnMvYWxwaGEtcm91dGVyL2Z1bmN0aW9ucy9iZXN0LXN3YXAtcm91dGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDbkMsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXBELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDeEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUUzRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHcEQsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixNQUFzQixFQUN0QixRQUFrQixFQUNsQixxQkFBNEMsRUFDNUMsU0FBb0IsRUFDcEIsT0FBZ0IsRUFDaEIsYUFBZ0M7SUFTaEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRXZCLGtFQUFrRTtJQUNsRSxvR0FBb0c7SUFDcEcsTUFBTSxlQUFlLEdBQWlELEVBQUUsQ0FBQztJQUN6RSxLQUFLLE1BQU0sbUJBQW1CLElBQUkscUJBQXFCLEVBQUU7UUFDdkQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNq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"]},"metadata":{},"sourceType":"module"}