{"ast":null,"code":"/**\n * Mnemonist Inverted Index\n * =========================\n *\n * JavaScript implementation of an inverted index.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    helpers = require('./utils/merge.js');\n\nfunction identity(x) {\n  return x;\n}\n/**\n * InvertedIndex.\n *\n * @constructor\n * @param {function} tokenizer - Tokenizer function.\n */\n\n\nfunction InvertedIndex(descriptor) {\n  this.clear();\n\n  if (Array.isArray(descriptor)) {\n    this.documentTokenizer = descriptor[0];\n    this.queryTokenizer = descriptor[1];\n  } else {\n    this.documentTokenizer = descriptor;\n    this.queryTokenizer = descriptor;\n  }\n\n  if (!this.documentTokenizer) this.documentTokenizer = identity;\n  if (!this.queryTokenizer) this.queryTokenizer = identity;\n  if (typeof this.documentTokenizer !== 'function') throw new Error('mnemonist/InvertedIndex.constructor: document tokenizer is not a function.');\n  if (typeof this.queryTokenizer !== 'function') throw new Error('mnemonist/InvertedIndex.constructor: query tokenizer is not a function.');\n}\n/**\n * Method used to clear the InvertedIndex.\n *\n * @return {undefined}\n */\n\n\nInvertedIndex.prototype.clear = function () {\n  // Properties\n  this.items = [];\n  this.mapping = new Map();\n  this.size = 0;\n  this.dimension = 0;\n};\n/**\n * Method used to add a document to the index.\n *\n * @param  {any} doc - Item to add.\n * @return {InvertedIndex}\n */\n\n\nInvertedIndex.prototype.add = function (doc) {\n  // Increasing size\n  this.size++; // Storing document\n\n  var key = this.items.length;\n  this.items.push(doc); // Tokenizing the document\n\n  var tokens = this.documentTokenizer(doc);\n  if (!Array.isArray(tokens)) throw new Error('mnemonist/InvertedIndex.add: tokenizer function should return an array of tokens.'); // Indexing\n\n  var done = new Set(),\n      token,\n      container;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    if (done.has(token)) continue;\n    done.add(token);\n    container = this.mapping.get(token);\n\n    if (!container) {\n      container = [];\n      this.mapping.set(token, container);\n    }\n\n    container.push(key);\n  }\n\n  this.dimension = this.mapping.size;\n  return this;\n};\n/**\n * Method used to query the index in a AND fashion.\n *\n * @param  {any} query - Query\n * @return {Set}       - Intersection of documents matching the query.\n */\n\n\nInvertedIndex.prototype.get = function (query) {\n  // Early termination\n  if (!this.size) return []; // First we need to tokenize the query\n\n  var tokens = this.queryTokenizer(query);\n  if (!Array.isArray(tokens)) throw new Error('mnemonist/InvertedIndex.query: tokenizer function should return an array of tokens.');\n  if (!tokens.length) return [];\n  var results = this.mapping.get(tokens[0]),\n      c,\n      i,\n      l;\n  if (typeof results === 'undefined' || results.length === 0) return [];\n\n  if (tokens.length > 1) {\n    for (i = 1, l = tokens.length; i < l; i++) {\n      c = this.mapping.get(tokens[i]);\n      if (typeof c === 'undefined' || c.length === 0) return [];\n      results = helpers.intersectionUniqueArrays(results, c);\n    }\n  }\n\n  var docs = new Array(results.length);\n\n  for (i = 0, l = docs.length; i < l; i++) docs[i] = this.items[results[i]];\n\n  return docs;\n};\n/**\n * Method used to iterate over each of the documents.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nInvertedIndex.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0, l = this.documents.length; i < l; i++) callback.call(scope, this.documents[i], i, this);\n};\n/**\n * Method returning an iterator over the index's documents.\n *\n * @return {Iterator}\n */\n\n\nInvertedIndex.prototype.documents = function () {\n  var documents = this.items,\n      l = documents.length,\n      i = 0;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var value = documents[i++];\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n/**\n * Method returning an iterator over the index's tokens.\n *\n * @return {Iterator}\n */\n\n\nInvertedIndex.prototype.tokens = function () {\n  return this.mapping.keys();\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') InvertedIndex.prototype[Symbol.iterator] = InvertedIndex.prototype.documents;\n/**\n * Convenience known methods.\n */\n\nInvertedIndex.prototype.inspect = function () {\n  var array = this.items.slice(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(array, 'constructor', {\n    value: InvertedIndex,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') InvertedIndex.prototype[Symbol.for('nodejs.util.inspect.custom')] = InvertedIndex.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a InvertedIndex.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} tokenizer - Tokenizer function.\n * @return {InvertedIndex}\n */\n\nInvertedIndex.from = function (iterable, descriptor) {\n  var index = new InvertedIndex(descriptor);\n  forEach(iterable, function (doc) {\n    index.add(doc);\n  });\n  return index;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = InvertedIndex;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/inverted-index.js"],"names":["Iterator","require","forEach","helpers","identity","x","InvertedIndex","descriptor","clear","Array","isArray","documentTokenizer","queryTokenizer","Error","prototype","items","mapping","Map","size","dimension","add","doc","key","length","push","tokens","done","Set","token","container","i","l","has","get","set","query","results","c","intersectionUniqueArrays","docs","callback","scope","arguments","documents","call","value","keys","Symbol","iterator","inspect","array","slice","Object","defineProperty","enumerable","for","from","iterable","index","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Inverted Index\n * =========================\n *\n * JavaScript implementation of an inverted index.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    helpers = require('./utils/merge.js');\n\nfunction identity(x) {\n  return x;\n}\n\n/**\n * InvertedIndex.\n *\n * @constructor\n * @param {function} tokenizer - Tokenizer function.\n */\nfunction InvertedIndex(descriptor) {\n  this.clear();\n\n  if (Array.isArray(descriptor)) {\n    this.documentTokenizer = descriptor[0];\n    this.queryTokenizer = descriptor[1];\n  }\n  else {\n    this.documentTokenizer = descriptor;\n    this.queryTokenizer = descriptor;\n  }\n\n  if (!this.documentTokenizer)\n    this.documentTokenizer = identity;\n  if (!this.queryTokenizer)\n    this.queryTokenizer = identity;\n\n  if (typeof this.documentTokenizer !== 'function')\n    throw new Error('mnemonist/InvertedIndex.constructor: document tokenizer is not a function.');\n\n  if (typeof this.queryTokenizer !== 'function')\n    throw new Error('mnemonist/InvertedIndex.constructor: query tokenizer is not a function.');\n}\n\n/**\n * Method used to clear the InvertedIndex.\n *\n * @return {undefined}\n */\nInvertedIndex.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.mapping = new Map();\n  this.size = 0;\n  this.dimension = 0;\n};\n\n/**\n * Method used to add a document to the index.\n *\n * @param  {any} doc - Item to add.\n * @return {InvertedIndex}\n */\nInvertedIndex.prototype.add = function(doc) {\n\n  // Increasing size\n  this.size++;\n\n  // Storing document\n  var key = this.items.length;\n  this.items.push(doc);\n\n  // Tokenizing the document\n  var tokens = this.documentTokenizer(doc);\n\n  if (!Array.isArray(tokens))\n    throw new Error('mnemonist/InvertedIndex.add: tokenizer function should return an array of tokens.');\n\n  // Indexing\n  var done = new Set(),\n      token,\n      container;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    if (done.has(token))\n      continue;\n\n    done.add(token);\n\n    container = this.mapping.get(token);\n\n    if (!container) {\n      container = [];\n      this.mapping.set(token, container);\n    }\n\n    container.push(key);\n  }\n\n  this.dimension = this.mapping.size;\n\n  return this;\n};\n\n/**\n * Method used to query the index in a AND fashion.\n *\n * @param  {any} query - Query\n * @return {Set}       - Intersection of documents matching the query.\n */\nInvertedIndex.prototype.get = function(query) {\n\n  // Early termination\n  if (!this.size)\n    return [];\n\n  // First we need to tokenize the query\n  var tokens = this.queryTokenizer(query);\n\n  if (!Array.isArray(tokens))\n    throw new Error('mnemonist/InvertedIndex.query: tokenizer function should return an array of tokens.');\n\n  if (!tokens.length)\n    return [];\n\n  var results = this.mapping.get(tokens[0]),\n      c,\n      i,\n      l;\n\n  if (typeof results === 'undefined' || results.length === 0)\n    return [];\n\n  if (tokens.length > 1) {\n    for (i = 1, l = tokens.length; i < l; i++) {\n      c = this.mapping.get(tokens[i]);\n\n      if (typeof c === 'undefined' || c.length === 0)\n        return [];\n\n      results = helpers.intersectionUniqueArrays(results, c);\n    }\n  }\n\n  var docs = new Array(results.length);\n\n  for (i = 0, l = docs.length; i < l; i++)\n    docs[i] = this.items[results[i]];\n\n  return docs;\n};\n\n/**\n * Method used to iterate over each of the documents.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nInvertedIndex.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0, l = this.documents.length; i < l; i++)\n    callback.call(scope, this.documents[i], i, this);\n};\n\n/**\n * Method returning an iterator over the index's documents.\n *\n * @return {Iterator}\n */\nInvertedIndex.prototype.documents = function() {\n  var documents = this.items,\n      l = documents.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n      var value = documents[i++];\n\n      return {\n        value: value,\n        done: false\n      };\n  });\n};\n\n/**\n * Method returning an iterator over the index's tokens.\n *\n * @return {Iterator}\n */\nInvertedIndex.prototype.tokens = function() {\n  return this.mapping.keys();\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  InvertedIndex.prototype[Symbol.iterator] = InvertedIndex.prototype.documents;\n\n/**\n * Convenience known methods.\n */\nInvertedIndex.prototype.inspect = function() {\n  var array = this.items.slice();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: InvertedIndex,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  InvertedIndex.prototype[Symbol.for('nodejs.util.inspect.custom')] = InvertedIndex.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a InvertedIndex.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} tokenizer - Tokenizer function.\n * @return {InvertedIndex}\n */\nInvertedIndex.from = function(iterable, descriptor) {\n  var index = new InvertedIndex(descriptor);\n\n  forEach(iterable, function(doc) {\n    index.add(doc);\n  });\n\n  return index;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = InvertedIndex;\n"]},"metadata":{},"sourceType":"script"}