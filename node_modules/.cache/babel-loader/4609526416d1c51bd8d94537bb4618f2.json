{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { CurrencyAmount, TradeType } from '@uniswap/sdk-core';\nimport { SwapQuoter } from '@uniswap/v3-sdk';\nimport { SupportedChainId } from 'constants/chains';\nimport JSBI from 'jsbi';\nimport { useMemo } from 'react';\nimport { InterfaceTrade, TradeState } from 'state/routing/types';\nimport { useSingleContractWithCallData } from '../state/multicall/hooks';\nimport { useAllV3Routes } from './useAllV3Routes';\nimport { useV3Quoter } from './useContract';\nimport { useActiveWeb3React } from './web3';\nconst QUOTE_GAS_OVERRIDES = {\n  [SupportedChainId.ARBITRUM_ONE]: 25000000,\n  [SupportedChainId.ARBITRUM_RINKEBY]: 25000000\n};\nconst DEFAULT_GAS_QUOTE = 2000000;\n/**\n * Returns the best v3 trade for a desired swap\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\n\nexport function useClientSideV3Trade(tradeType, amountSpecified, otherCurrency) {\n  _s();\n\n  var _QUOTE_GAS_OVERRIDES$;\n\n  const [currencyIn, currencyOut] = useMemo(() => tradeType === TradeType.EXACT_INPUT ? [amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency, otherCurrency] : [otherCurrency, amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency], [tradeType, amountSpecified, otherCurrency]);\n  const {\n    routes,\n    loading: routesLoading\n  } = useAllV3Routes(currencyIn, currencyOut);\n  const quoter = useV3Quoter();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const quotesResults = useSingleContractWithCallData(quoter, amountSpecified ? routes.map(route => SwapQuoter.quoteCallParameters(route, amountSpecified, tradeType).calldata) : [], {\n    gasRequired: chainId ? (_QUOTE_GAS_OVERRIDES$ = QUOTE_GAS_OVERRIDES[chainId]) !== null && _QUOTE_GAS_OVERRIDES$ !== void 0 ? _QUOTE_GAS_OVERRIDES$ : DEFAULT_GAS_QUOTE : undefined\n  });\n  return useMemo(() => {\n    if (!amountSpecified || !currencyIn || !currencyOut || quotesResults.some(({\n      valid\n    }) => !valid) || (tradeType === TradeType.EXACT_INPUT ? amountSpecified.currency.equals(currencyOut) : amountSpecified.currency.equals(currencyIn))) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined\n      };\n    }\n\n    if (routesLoading || quotesResults.some(({\n      loading\n    }) => loading)) {\n      return {\n        state: TradeState.LOADING,\n        trade: undefined\n      };\n    }\n\n    const {\n      bestRoute,\n      amountIn,\n      amountOut\n    } = quotesResults.reduce((currentBest, {\n      result\n    }, i) => {\n      if (!result) return currentBest; // overwrite the current best if it's not defined or if this route is better\n\n      if (tradeType === TradeType.EXACT_INPUT) {\n        const amountOut = CurrencyAmount.fromRawAmount(currencyOut, result.amountOut.toString());\n\n        if (currentBest.amountOut === null || JSBI.lessThan(currentBest.amountOut.quotient, amountOut.quotient)) {\n          return {\n            bestRoute: routes[i],\n            amountIn: amountSpecified,\n            amountOut\n          };\n        }\n      } else {\n        const amountIn = CurrencyAmount.fromRawAmount(currencyIn, result.amountIn.toString());\n\n        if (currentBest.amountIn === null || JSBI.greaterThan(currentBest.amountIn.quotient, amountIn.quotient)) {\n          return {\n            bestRoute: routes[i],\n            amountIn,\n            amountOut: amountSpecified\n          };\n        }\n      }\n\n      return currentBest;\n    }, {\n      bestRoute: null,\n      amountIn: null,\n      amountOut: null\n    });\n\n    if (!bestRoute || !amountIn || !amountOut) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined\n      };\n    }\n\n    return {\n      state: TradeState.VALID,\n      trade: new InterfaceTrade({\n        v2Routes: [],\n        v3Routes: [{\n          routev3: bestRoute,\n          inputAmount: amountIn,\n          outputAmount: amountOut\n        }],\n        tradeType\n      })\n    };\n  }, [amountSpecified, currencyIn, currencyOut, quotesResults, routes, routesLoading, tradeType]);\n}\n\n_s(useClientSideV3Trade, \"Yl30J0/vyl2u+De/Nlvj36Jf6JE=\", false, function () {\n  return [useAllV3Routes, useV3Quoter, useActiveWeb3React, useSingleContractWithCallData];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useClientSideV3Trade.ts"],"names":["CurrencyAmount","TradeType","SwapQuoter","SupportedChainId","JSBI","useMemo","InterfaceTrade","TradeState","useSingleContractWithCallData","useAllV3Routes","useV3Quoter","useActiveWeb3React","QUOTE_GAS_OVERRIDES","ARBITRUM_ONE","ARBITRUM_RINKEBY","DEFAULT_GAS_QUOTE","useClientSideV3Trade","tradeType","amountSpecified","otherCurrency","currencyIn","currencyOut","EXACT_INPUT","currency","routes","loading","routesLoading","quoter","chainId","quotesResults","map","route","quoteCallParameters","calldata","gasRequired","undefined","some","valid","equals","state","INVALID","trade","LOADING","bestRoute","amountIn","amountOut","reduce","currentBest","result","i","fromRawAmount","toString","lessThan","quotient","greaterThan","NO_ROUTE_FOUND","VALID","v2Routes","v3Routes","routev3","inputAmount","outputAmount"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { Route, SwapQuoter } from '@uniswap/v3-sdk'\nimport { SupportedChainId } from 'constants/chains'\nimport JSBI from 'jsbi'\nimport { useMemo } from 'react'\nimport { InterfaceTrade, TradeState } from 'state/routing/types'\n\nimport { useSingleContractWithCallData } from '../state/multicall/hooks'\nimport { useAllV3Routes } from './useAllV3Routes'\nimport { useV3Quoter } from './useContract'\nimport { useActiveWeb3React } from './web3'\n\nconst QUOTE_GAS_OVERRIDES: { [chainId: number]: number } = {\n  [SupportedChainId.ARBITRUM_ONE]: 25_000_000,\n  [SupportedChainId.ARBITRUM_RINKEBY]: 25_000_000,\n}\n\nconst DEFAULT_GAS_QUOTE = 2_000_000\n\n/**\n * Returns the best v3 trade for a desired swap\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useClientSideV3Trade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): { state: TradeState; trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined } {\n  const [currencyIn, currencyOut] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [tradeType, amountSpecified, otherCurrency]\n  )\n  const { routes, loading: routesLoading } = useAllV3Routes(currencyIn, currencyOut)\n\n  const quoter = useV3Quoter()\n  const { chainId } = useActiveWeb3React()\n  const quotesResults = useSingleContractWithCallData(\n    quoter,\n    amountSpecified\n      ? routes.map((route) => SwapQuoter.quoteCallParameters(route, amountSpecified, tradeType).calldata)\n      : [],\n    {\n      gasRequired: chainId ? QUOTE_GAS_OVERRIDES[chainId] ?? DEFAULT_GAS_QUOTE : undefined,\n    }\n  )\n\n  return useMemo(() => {\n    if (\n      !amountSpecified ||\n      !currencyIn ||\n      !currencyOut ||\n      quotesResults.some(({ valid }) => !valid) ||\n      // skip when tokens are the same\n      (tradeType === TradeType.EXACT_INPUT\n        ? amountSpecified.currency.equals(currencyOut)\n        : amountSpecified.currency.equals(currencyIn))\n    ) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (routesLoading || quotesResults.some(({ loading }) => loading)) {\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    const { bestRoute, amountIn, amountOut } = quotesResults.reduce(\n      (\n        currentBest: {\n          bestRoute: Route<Currency, Currency> | null\n          amountIn: CurrencyAmount<Currency> | null\n          amountOut: CurrencyAmount<Currency> | null\n        },\n        { result },\n        i\n      ) => {\n        if (!result) return currentBest\n\n        // overwrite the current best if it's not defined or if this route is better\n        if (tradeType === TradeType.EXACT_INPUT) {\n          const amountOut = CurrencyAmount.fromRawAmount(currencyOut, result.amountOut.toString())\n          if (currentBest.amountOut === null || JSBI.lessThan(currentBest.amountOut.quotient, amountOut.quotient)) {\n            return {\n              bestRoute: routes[i],\n              amountIn: amountSpecified,\n              amountOut,\n            }\n          }\n        } else {\n          const amountIn = CurrencyAmount.fromRawAmount(currencyIn, result.amountIn.toString())\n          if (currentBest.amountIn === null || JSBI.greaterThan(currentBest.amountIn.quotient, amountIn.quotient)) {\n            return {\n              bestRoute: routes[i],\n              amountIn,\n              amountOut: amountSpecified,\n            }\n          }\n        }\n\n        return currentBest\n      },\n      {\n        bestRoute: null,\n        amountIn: null,\n        amountOut: null,\n      }\n    )\n\n    if (!bestRoute || !amountIn || !amountOut) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    return {\n      state: TradeState.VALID,\n      trade: new InterfaceTrade({\n        v2Routes: [],\n        v3Routes: [\n          {\n            routev3: bestRoute,\n            inputAmount: amountIn,\n            outputAmount: amountOut,\n          },\n        ],\n        tradeType,\n      }),\n    }\n  }, [amountSpecified, currencyIn, currencyOut, quotesResults, routes, routesLoading, tradeType])\n}\n"]},"metadata":{},"sourceType":"module"}