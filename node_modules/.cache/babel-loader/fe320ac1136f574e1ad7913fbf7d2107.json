{"ast":null,"code":"import { BigNumber } from 'ethers';\nimport React, { useMemo, useEffect, useState, useRef } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { createSlice } from '@reduxjs/toolkit';\nvar DEFAULT_CALL_GAS_REQUIRED = 1000000;\nvar DEFAULT_CHUNK_GAS_REQUIRED = 200000;\nvar CHUNK_GAS_LIMIT = 100000000;\nvar CONSERVATIVE_BLOCK_GAS_LIMIT = 10000000; // conservative, hard-coded estimate of the current block gas limit\n// Consts for hooks\n\nvar INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\nvar NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction toCallKey(call) {\n  var key = call.address + \"-\" + call.callData;\n\n  if (call.gasRequired) {\n    if (!Number.isSafeInteger(call.gasRequired)) {\n      throw new Error(\"Invalid number: \" + call.gasRequired);\n    }\n\n    key += \"-\" + call.gasRequired;\n  }\n\n  return key;\n}\n\nfunction parseCallKey(callKey) {\n  var pcs = callKey.split('-');\n\n  if (![2, 3].includes(pcs.length)) {\n    throw new Error(\"Invalid call key: \" + callKey);\n  }\n\n  return _extends({\n    address: pcs[0],\n    callData: pcs[1]\n  }, pcs[2] ? {\n    gasRequired: Number.parseInt(pcs[2])\n  } : {});\n}\n\nfunction isMethodArg(x) {\n  return BigNumber.isBigNumber(x) || ['string', 'number'].indexOf(typeof x) !== -1;\n}\n\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(function (xi) {\n    return isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg);\n  });\n} // the lowest level call for subscribing to contract data\n\n\nfunction useCallsData(context, chainId, calls, _temp) {\n  var _ref = _temp === void 0 ? {\n    blocksPerFetch: 1\n  } : _temp,\n      blocksPerFetch = _ref.blocksPerFetch;\n\n  var reducerPath = context.reducerPath,\n      actions = context.actions;\n  var callResults = useSelector(function (state) {\n    return state[reducerPath].callResults;\n  });\n  var dispatch = useDispatch();\n  var serializedCallKeys = useMemo(function () {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n\n    return JSON.stringify((_calls$filter$map$sor = calls == null ? void 0 : (_calls$filter = calls.filter(function (c) {\n      return Boolean(c);\n    })) == null ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) == null ? void 0 : _calls$filter$map.sort()) != null ? _calls$filter$map$sor : []);\n  }, [calls]); // update listeners when there is an actual change that persists for at least 100ms\n\n  useEffect(function () {\n    var callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    var calls = callKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    dispatch(actions.addMulticallListeners({\n      chainId: chainId,\n      calls: calls,\n      options: {\n        blocksPerFetch: blocksPerFetch\n      }\n    }));\n    return function () {\n      dispatch(actions.removeMulticallListeners({\n        chainId: chainId,\n        calls: calls,\n        options: {\n          blocksPerFetch: blocksPerFetch\n        }\n      }));\n    };\n  }, [actions, chainId, dispatch, blocksPerFetch, serializedCallKeys]);\n  return useMemo(function () {\n    return calls.map(function (call) {\n      var _callResults$chainId;\n\n      if (!chainId || !call) return INVALID_RESULT;\n      var result = (_callResults$chainId = callResults[chainId]) == null ? void 0 : _callResults$chainId[toCallKey(call)];\n      var data;\n\n      if (result != null && result.data && (result == null ? void 0 : result.data) !== '0x') {\n        data = result.data;\n      }\n\n      return {\n        valid: true,\n        data: data,\n        blockNumber: result == null ? void 0 : result.blockNumber\n      };\n    });\n  }, [callResults, calls, chainId]);\n}\n\nvar INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nvar LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\n\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  var valid = callResult.valid,\n      data = callResult.data,\n      blockNumber = callResult.blockNumber;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  var success = data && data.length > 2;\n  var syncing = (blockNumber != null ? blockNumber : 0) < latestBlockNumber;\n  var result = undefined;\n\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing: syncing,\n        result: result\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    loading: false,\n    syncing: syncing,\n    result: result,\n    error: !success\n  };\n} // formats many calls to a single function on a single contract, with the function name and inputs specified\n\n\nfunction useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, callInputs, options) {\n  var _options, _options2;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fragment = useMemo(function () {\n    var _contract$interface;\n\n    return contract == null ? void 0 : (_contract$interface = contract[\"interface\"]) == null ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]); // encode callDatas\n\n  var callDatas = useMemo(function () {\n    return contract && fragment ? callInputs.map(function (callInput) {\n      return isValidMethodArgs(callInput) ? contract[\"interface\"].encodeFunctionData(fragment, callInput) : undefined;\n    }) : [];\n  }, [callInputs, contract, fragment]);\n  var gasRequired = (_options = options) == null ? void 0 : _options.gasRequired;\n  var blocksPerFetch = (_options2 = options) == null ? void 0 : _options2.blocksPerFetch; // encode calls\n\n  var calls = useMemo(function () {\n    return contract ? callDatas.map(function (callData) {\n      return callData ? {\n        address: contract.address,\n        callData: callData,\n        gasRequired: gasRequired\n      } : undefined;\n    }) : [];\n  }, [contract, callDatas, gasRequired]);\n  var results = useCallsData(context, chainId, calls, blocksPerFetch ? {\n    blocksPerFetch: blocksPerFetch\n  } : undefined);\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contract == null ? void 0 : contract[\"interface\"], fragment, latestBlockNumber);\n    });\n  }, [results, contract, fragment, latestBlockNumber]);\n}\n\nfunction useMultipleContractSingleData(context, chainId, latestBlockNumber, addresses, contractInterface, methodName, callInputs, options) {\n  var _options3, _options4;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var fragment = useMemo(function () {\n    return contractInterface.getFunction(methodName);\n  }, [contractInterface, methodName]); // encode callData\n\n  var callData = useMemo(function () {\n    return isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined;\n  }, [callInputs, contractInterface, fragment]);\n  var gasRequired = (_options3 = options) == null ? void 0 : _options3.gasRequired;\n  var blocksPerFetch = (_options4 = options) == null ? void 0 : _options4.blocksPerFetch; // encode calls\n\n  var calls = useMemo(function () {\n    return callData ? addresses.map(function (address) {\n      return address ? {\n        address: address,\n        callData: callData,\n        gasRequired: gasRequired\n      } : undefined;\n    }) : [];\n  }, [addresses, callData, gasRequired]);\n  var results = useCallsData(context, chainId, calls, blocksPerFetch ? {\n    blocksPerFetch: blocksPerFetch\n  } : undefined);\n  return useMemo(function () {\n    return results.map(function (result) {\n      return toCallState(result, contractInterface, fragment, latestBlockNumber);\n    });\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\n\nfunction useSingleCallResult(context, chainId, latestBlockNumber, contract, methodName, inputs, options) {\n  var _useSingleContractMul;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  return (_useSingleContractMul = useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, [inputs], options)[0]) != null ? _useSingleContractMul : INVALID_CALL_STATE;\n} // formats many calls to any number of functions on a single contract, with only the calldata specified\n\n\nfunction useSingleContractWithCallData(context, chainId, latestBlockNumber, contract, callDatas, options) {\n  var _options5, _options6;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var gasRequired = (_options5 = options) == null ? void 0 : _options5.gasRequired;\n  var blocksPerFetch = (_options6 = options) == null ? void 0 : _options6.blocksPerFetch; // encode calls\n\n  var calls = useMemo(function () {\n    return contract ? callDatas.map(function (callData) {\n      return {\n        address: contract.address,\n        callData: callData,\n        gasRequired: gasRequired\n      };\n    }) : [];\n  }, [contract, callDatas, gasRequired]);\n  var results = useCallsData(context, chainId, calls, blocksPerFetch ? {\n    blocksPerFetch: blocksPerFetch\n  } : undefined);\n  return useMemo(function () {\n    return results.map(function (result, i) {\n      var _contract$interface2;\n\n      return toCallState(result, contract == null ? void 0 : contract[\"interface\"], contract == null ? void 0 : (_contract$interface2 = contract[\"interface\"]) == null ? void 0 : _contract$interface2.getFunction(callDatas[i].substring(0, 10)), latestBlockNumber);\n    });\n  }, [results, contract, callDatas, latestBlockNumber]);\n}\n\nvar initialState = {\n  callResults: {}\n};\n\nfunction createMulticallSlice(reducerPath) {\n  return createSlice({\n    name: reducerPath,\n    initialState: initialState,\n    reducers: {\n      addMulticallListeners: function addMulticallListeners(state, action) {\n        var _listeners$chainId;\n\n        var _action$payload = action.payload,\n            calls = _action$payload.calls,\n            chainId = _action$payload.chainId,\n            blocksPerFetch = _action$payload.options.blocksPerFetch;\n        var listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n        listeners[chainId] = (_listeners$chainId = listeners[chainId]) != null ? _listeners$chainId : {};\n        calls.forEach(function (call) {\n          var _listeners$chainId$ca, _listeners$chainId$ca2;\n\n          var callKey = toCallKey(call);\n          listeners[chainId][callKey] = (_listeners$chainId$ca = listeners[chainId][callKey]) != null ? _listeners$chainId$ca : {};\n          listeners[chainId][callKey][blocksPerFetch] = ((_listeners$chainId$ca2 = listeners[chainId][callKey][blocksPerFetch]) != null ? _listeners$chainId$ca2 : 0) + 1;\n        });\n      },\n      removeMulticallListeners: function removeMulticallListeners(state, action) {\n        var _action$payload2 = action.payload,\n            calls = _action$payload2.calls,\n            chainId = _action$payload2.chainId,\n            blocksPerFetch = _action$payload2.options.blocksPerFetch;\n        var listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n        if (!listeners[chainId]) return;\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          if (!listeners[chainId][callKey]) return;\n          if (!listeners[chainId][callKey][blocksPerFetch]) return;\n\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch];\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--;\n          }\n        });\n      },\n      fetchingMulticallResults: function fetchingMulticallResults(state, action) {\n        var _state$callResults$ch;\n\n        var _action$payload3 = action.payload,\n            chainId = _action$payload3.chainId,\n            fetchingBlockNumber = _action$payload3.fetchingBlockNumber,\n            calls = _action$payload3.calls;\n        state.callResults[chainId] = (_state$callResults$ch = state.callResults[chainId]) != null ? _state$callResults$ch : {};\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          var current = state.callResults[chainId][callKey];\n\n          if (!current) {\n            state.callResults[chainId][callKey] = {\n              fetchingBlockNumber: fetchingBlockNumber\n            };\n          } else {\n            var _current$fetchingBloc;\n\n            if (((_current$fetchingBloc = current.fetchingBlockNumber) != null ? _current$fetchingBloc : 0) >= fetchingBlockNumber) return;\n            state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n          }\n        });\n      },\n      errorFetchingMulticallResults: function errorFetchingMulticallResults(state, action) {\n        var _state$callResults$ch2;\n\n        var _action$payload4 = action.payload,\n            chainId = _action$payload4.chainId,\n            fetchingBlockNumber = _action$payload4.fetchingBlockNumber,\n            calls = _action$payload4.calls;\n        state.callResults[chainId] = (_state$callResults$ch2 = state.callResults[chainId]) != null ? _state$callResults$ch2 : {};\n        calls.forEach(function (call) {\n          var callKey = toCallKey(call);\n          var current = state.callResults[chainId][callKey];\n          if (!current || typeof current.fetchingBlockNumber !== 'number') return; // only should be dispatched if we are already fetching\n\n          if (current.fetchingBlockNumber <= fetchingBlockNumber) {\n            delete current.fetchingBlockNumber;\n            current.data = null;\n            current.blockNumber = fetchingBlockNumber;\n          }\n        });\n      },\n      updateMulticallResults: function updateMulticallResults(state, action) {\n        var _state$callResults$ch3;\n\n        var _action$payload5 = action.payload,\n            chainId = _action$payload5.chainId,\n            results = _action$payload5.results,\n            blockNumber = _action$payload5.blockNumber;\n        state.callResults[chainId] = (_state$callResults$ch3 = state.callResults[chainId]) != null ? _state$callResults$ch3 : {};\n        Object.keys(results).forEach(function (callKey) {\n          var _current$blockNumber;\n\n          var current = state.callResults[chainId][callKey];\n          if (((_current$blockNumber = current == null ? void 0 : current.blockNumber) != null ? _current$blockNumber : 0) > blockNumber) return;\n          state.callResults[chainId][callKey] = {\n            data: results[callKey],\n            blockNumber: blockNumber\n          };\n        });\n      }\n    }\n  });\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function (obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function () {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    define(Gp, iteratorSymbol, function () {\n      return this;\n    });\n    define(Gp, \"toString\", function () {\n      return \"[object Generator]\";\n    });\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n  }\n}); // evenly distributes items among the chunks\n\nfunction chunkArray(items, chunkGasLimit) {\n  var chunks = [];\n  var currentChunk = [];\n  var currentChunkCumulativeGas = 0;\n\n  for (var i = 0; i < items.length; i++) {\n    var _item$gasRequired;\n\n    var item = items[i]; // calculate the gas required by the current item\n\n    var gasRequired = (_item$gasRequired = item == null ? void 0 : item.gasRequired) != null ? _item$gasRequired : DEFAULT_CHUNK_GAS_REQUIRED; // if the current chunk is empty, or the current item wouldn't push it over the gas limit,\n    // append the current item and increment the cumulative gas\n\n    if (currentChunk.length === 0 || currentChunkCumulativeGas + gasRequired < chunkGasLimit) {\n      currentChunk.push(item);\n      currentChunkCumulativeGas += gasRequired;\n    } else {\n      // otherwise, push the current chunk and create a new chunk\n      chunks.push(currentChunk);\n      currentChunk = [item];\n      currentChunkCumulativeGas = gasRequired;\n    }\n  }\n\n  if (currentChunk.length > 0) chunks.push(currentChunk);\n  return chunks;\n} // TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/utils/retry.ts\n\n\nfunction wait(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\nfunction waitRandom(min, max) {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)));\n}\n/**\r\n * This error is thrown if the function is cancelled before completing\r\n */\n\n\nvar CancelledError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(CancelledError, _Error);\n\n  function CancelledError() {\n    var _this;\n\n    _this = _Error.call(this, 'Cancelled') || this;\n    _this.isCancelledError = true;\n    return _this;\n  }\n\n  return CancelledError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Throw this error if the function should retry\r\n */\n\n\nvar RetryableError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(RetryableError, _Error2);\n\n  function RetryableError() {\n    var _this2;\n\n    _this2 = _Error2.apply(this, arguments) || this;\n    _this2.isRetryableError = true;\n    return _this2;\n  }\n\n  return RetryableError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\r\n * @param fn function to retry\r\n * @param n how many times to retry\r\n * @param minWait min wait between retries in ms\r\n * @param maxWait max wait between retries in ms\r\n */\n\n\nfunction retry(fn, _ref) {\n  var n = _ref.n,\n      minWait = _ref.minWait,\n      maxWait = _ref.maxWait;\n  var completed = false;\n  var rejectCancelled;\n  var promise = new Promise( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(resolve, reject) {\n      var result;\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              rejectCancelled = reject;\n\n            case 1:\n              result = void 0;\n              _context.prev = 3;\n              _context.next = 6;\n              return fn();\n\n            case 6:\n              result = _context.sent;\n\n              if (!completed) {\n                resolve(result);\n                completed = true;\n              }\n\n              return _context.abrupt(\"break\", 24);\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](3);\n\n              if (!completed) {\n                _context.next = 15;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 24);\n\n            case 15:\n              if (!(n <= 0 || !_context.t0.isRetryableError)) {\n                _context.next = 19;\n                break;\n              }\n\n              reject(_context.t0);\n              completed = true;\n              return _context.abrupt(\"break\", 24);\n\n            case 19:\n              n--;\n\n            case 20:\n              _context.next = 22;\n              return waitRandom(minWait, maxWait);\n\n            case 22:\n              _context.next = 1;\n              break;\n\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 11]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n  return {\n    promise: promise,\n    cancel: function cancel() {\n      if (completed) return;\n      completed = true;\n      rejectCancelled(new CancelledError());\n    }\n  };\n} // TODO de-duplicate this file with web interface\n\n\nfunction useDebounce(value, delay) {\n  var _useState = useState(value),\n      debouncedValue = _useState[0],\n      setDebouncedValue = _useState[1];\n\n  useEffect(function () {\n    // Update debounced value after delay\n    var handler = setTimeout(function () {\n      setDebouncedValue(value);\n    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n\n    return function () {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n}\n/**\r\n * Fetches a chunk of calls, enforcing a minimum block number constraint\r\n * @param multicall multicall contract to fetch against\r\n * @param chunk chunk of calls to make\r\n * @param blockNumber block number passed as the block tag in the eth_call\r\n */\n\n\nfunction fetchChunk(_x, _x2, _x3, _x4) {\n  return _fetchChunk.apply(this, arguments);\n}\n/**\r\n * From the current all listeners state, return each call key mapped to the\r\n * minimum number of blocks per fetch. This is how often each key must be fetched.\r\n * @param allListeners the all listeners state\r\n * @param chainId the current chain id\r\n */\n\n\nfunction _fetchChunk() {\n  _fetchChunk = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(multicall, chunk, blockNumber, isDebug) {\n    var _yield$multicall$call, returnData, _error$message, _error$message2, error, half, _yield$Promise$all, c0, c1;\n\n    return runtime_1.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.debug('Fetching chunk', chunk, blockNumber);\n            _context.prev = 1;\n            _context.next = 4;\n            return multicall.callStatic.multicall(chunk.map(function (obj) {\n              var _obj$gasRequired;\n\n              return {\n                target: obj.address,\n                callData: obj.callData,\n                gasLimit: (_obj$gasRequired = obj.gasRequired) != null ? _obj$gasRequired : DEFAULT_CALL_GAS_REQUIRED\n              };\n            }), // we aren't passing through the block gas limit we used to create the chunk, because it causes a problem with the integ tests\n            {\n              blockTag: blockNumber\n            });\n\n          case 4:\n            _yield$multicall$call = _context.sent;\n            returnData = _yield$multicall$call.returnData;\n\n            if (isDebug) {\n              returnData.forEach(function (_ref2, i) {\n                var _chunk$i$gasRequired;\n\n                var gasUsed = _ref2.gasUsed,\n                    returnData = _ref2.returnData,\n                    success = _ref2.success;\n\n                if (!success && returnData.length === 2 && gasUsed.gte(Math.floor(((_chunk$i$gasRequired = chunk[i].gasRequired) != null ? _chunk$i$gasRequired : DEFAULT_CALL_GAS_REQUIRED) * 0.95))) {\n                  var _chunk$i$gasRequired2;\n\n                  console.warn(\"A call failed due to requiring \" + gasUsed.toString() + \" vs. allowed \" + ((_chunk$i$gasRequired2 = chunk[i].gasRequired) != null ? _chunk$i$gasRequired2 : DEFAULT_CALL_GAS_REQUIRED), chunk[i]);\n                }\n              });\n            }\n\n            return _context.abrupt(\"return\", returnData);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](1);\n            error = _context.t0;\n\n            if (!(error.code === -32000 || ((_error$message = error.message) == null ? void 0 : _error$message.indexOf('header not found')) !== -1)) {\n              _context.next = 17;\n              break;\n            }\n\n            throw new RetryableError(\"header not found for block number \" + blockNumber);\n\n          case 17:\n            if (!(error.code === -32603 || ((_error$message2 = error.message) == null ? void 0 : _error$message2.indexOf('execution ran out of gas')) !== -1)) {\n              _context.next = 27;\n              break;\n            }\n\n            if (!(chunk.length > 1)) {\n              _context.next = 27;\n              break;\n            }\n\n            if (process.env.NODE_ENV === 'development') {\n              console.debug('Splitting a chunk in 2', chunk);\n            }\n\n            half = Math.floor(chunk.length / 2);\n            _context.next = 23;\n            return Promise.all([fetchChunk(multicall, chunk.slice(0, half), blockNumber), fetchChunk(multicall, chunk.slice(half, chunk.length), blockNumber)]);\n\n          case 23:\n            _yield$Promise$all = _context.sent;\n            c0 = _yield$Promise$all[0];\n            c1 = _yield$Promise$all[1];\n            return _context.abrupt(\"return\", c0.concat(c1));\n\n          case 27:\n            console.error('Failed to fetch chunk', error);\n            throw error;\n\n          case 29:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 10]]);\n  }));\n  return _fetchChunk.apply(this, arguments);\n}\n\nfunction activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  var listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce(function (memo, callKey) {\n    var keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(function (key) {\n      var blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce(function (previousMin, current) {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n/**\r\n * Return the keys that need to be refetched\r\n * @param callResults current call result state\r\n * @param listeningKeys each call key mapped to how old the data can be in blocks\r\n * @param chainId the current chain id\r\n * @param latestBlockNumber the latest block number\r\n */\n\n\nfunction outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  var results = callResults[chainId]; // no results at all, load everything\n\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(function (callKey) {\n    var blocksPerFetch = listeningKeys[callKey];\n    var data = callResults[chainId][callKey]; // no data, must fetch\n\n    if (!data) return true;\n    var minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1); // already fetching it for a recent enough block, don't refetch it\n\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false; // if data is older than minDataBlockNumber, fetch it\n\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\n\nfunction Updater(_ref) {\n  var context = _ref.context,\n      chainId = _ref.chainId,\n      latestBlockNumber = _ref.latestBlockNumber,\n      contract = _ref.contract,\n      isDebug = _ref.isDebug;\n  var actions = context.actions,\n      reducerPath = context.reducerPath;\n  var dispatch = useDispatch();\n  var state = useSelector(function (state) {\n    return state[reducerPath];\n  }); // wait for listeners to settle before triggering updates\n\n  var debouncedListeners = useDebounce(state.callListeners, 100);\n  var cancellations = useRef();\n  var listeningKeys = useMemo(function () {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  var unserializedOutdatedCallKeys = useMemo(function () {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  var serializedOutdatedCallKeys = useMemo(function () {\n    return JSON.stringify(unserializedOutdatedCallKeys.sort());\n  }, [unserializedOutdatedCallKeys]);\n  useEffect(function () {\n    if (!latestBlockNumber || !chainId || !contract) return;\n    var outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    var calls = outdatedCallKeys.map(function (key) {\n      return parseCallKey(key);\n    });\n    var chunkedCalls = chunkArray(calls, CHUNK_GAS_LIMIT);\n\n    if (cancellations.current && cancellations.current.blockNumber !== latestBlockNumber) {\n      cancellations.current.cancellations.forEach(function (c) {\n        return c();\n      });\n    }\n\n    dispatch(actions.fetchingMulticallResults({\n      calls: calls,\n      chainId: chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map(function (chunk) {\n        var _retry = retry(function () {\n          return fetchChunk(contract, chunk, latestBlockNumber, isDebug);\n        }, {\n          n: Infinity,\n          minWait: 1000,\n          maxWait: 2500\n        }),\n            cancel = _retry.cancel,\n            promise = _retry.promise;\n\n        promise.then(function (returnData) {\n          // split the returned slice into errors and results\n          var _chunk$reduce = chunk.reduce(function (memo, call, i) {\n            if (returnData[i].success) {\n              var _returnData$i$returnD;\n\n              memo.results[toCallKey(call)] = (_returnData$i$returnD = returnData[i].returnData) != null ? _returnData$i$returnD : null;\n            } else {\n              memo.erroredCalls.push(call);\n            }\n\n            return memo;\n          }, {\n            erroredCalls: [],\n            results: {}\n          }),\n              erroredCalls = _chunk$reduce.erroredCalls,\n              results = _chunk$reduce.results; // dispatch any new results\n\n\n          if (Object.keys(results).length > 0) dispatch(actions.updateMulticallResults({\n            chainId: chainId,\n            results: results,\n            blockNumber: latestBlockNumber\n          })); // dispatch any errored calls\n\n          if (erroredCalls.length > 0) {\n            if (isDebug) {\n              returnData.forEach(function (returnData, ix) {\n                if (!returnData.success) {\n                  console.debug('Call failed', chunk[ix], returnData);\n                }\n              });\n            } else {\n              console.debug('Calls errored in fetch', erroredCalls);\n            }\n\n            dispatch(actions.errorFetchingMulticallResults({\n              calls: erroredCalls,\n              chainId: chainId,\n              fetchingBlockNumber: latestBlockNumber\n            }));\n          }\n        })[\"catch\"](function (error) {\n          if (error.isCancelledError) {\n            console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId);\n            return;\n          }\n\n          console.error('Failed to fetch multicall chunk', chunk, chainId, error);\n          dispatch(actions.errorFetchingMulticallResults({\n            calls: chunk,\n            chainId: chainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [actions, chainId, contract, dispatch, serializedOutdatedCallKeys, latestBlockNumber, isDebug]);\n  return null;\n}\n\nfunction createUpdater(context) {\n  var UpdaterContextBound = function UpdaterContextBound(props) {\n    return React.createElement(Updater, Object.assign({\n      context: context\n    }, props));\n  };\n\n  return UpdaterContextBound;\n}\n\nfunction createMulticall(options) {\n  var _options$reducerPath;\n\n  var reducerPath = (_options$reducerPath = options == null ? void 0 : options.reducerPath) != null ? _options$reducerPath : 'multicall';\n  var slice = createMulticallSlice(reducerPath);\n  var actions = slice.actions,\n      reducer = slice.reducer;\n  var context = {\n    reducerPath: reducerPath,\n    actions: actions\n  };\n\n  var useMultipleContractSingleData$1 = function useMultipleContractSingleData$1() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return useMultipleContractSingleData.apply(void 0, [context].concat(args));\n  };\n\n  var useSingleContractMultipleData$1 = function useSingleContractMultipleData$1() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return useSingleContractMultipleData.apply(void 0, [context].concat(args));\n  };\n\n  var useSingleContractWithCallData$1 = function useSingleContractWithCallData$1() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return useSingleContractWithCallData.apply(void 0, [context].concat(args));\n  };\n\n  var useSingleCallResult$1 = function useSingleCallResult$1() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return useSingleCallResult.apply(void 0, [context].concat(args));\n  };\n\n  var hooks = {\n    useMultipleContractSingleData: useMultipleContractSingleData$1,\n    useSingleContractMultipleData: useSingleContractMultipleData$1,\n    useSingleContractWithCallData: useSingleContractWithCallData$1,\n    useSingleCallResult: useSingleCallResult$1\n  };\n  var Updater = createUpdater(context);\n  return {\n    reducerPath: reducerPath,\n    reducer: reducer,\n    actions: actions,\n    hooks: hooks,\n    Updater: Updater\n  };\n}\n\nexport { CHUNK_GAS_LIMIT, CONSERVATIVE_BLOCK_GAS_LIMIT, DEFAULT_CALL_GAS_REQUIRED, DEFAULT_CHUNK_GAS_REQUIRED, INVALID_RESULT, NEVER_RELOAD, createMulticall };","map":{"version":3,"sources":["../src/constants.ts","../src/utils/callKeys.ts","../src/hooks.ts","../src/slice.ts","../node_modules/regenerator-runtime/runtime.js","../src/utils/chunkArray.ts","../src/utils/retry.ts","../src/utils/useDebounce.ts","../src/updater.tsx","../src/create.ts"],"names":["DEFAULT_CALL_GAS_REQUIRED","DEFAULT_CHUNK_GAS_REQUIRED","CHUNK_GAS_LIMIT","CONSERVATIVE_BLOCK_GAS_LIMIT","INVALID_RESULT","valid","blockNumber","data","undefined","NEVER_RELOAD","blocksPerFetch","Infinity","toCallKey","call","key","Number","parseCallKey","callKey","pcs","address","callData","gasRequired","BigNumber","x","Array","isMethodArg","xi","reducerPath","actions","context","callResults","useSelector","state","dispatch","useDispatch","serializedCallKeys","useMemo","Boolean","useEffect","callKeys","JSON","calls","chainId","options","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","callResult","success","contractInterface","console","useSingleContractMultipleData","latestBlockNumber","contract","methodName","callInputs","fragment","callDatas","isValidMethodArgs","results","useCallsData","toCallState","useMultipleContractSingleData","addresses","useSingleCallResult","inputs","useSingleContractWithCallData","initialState","createMulticallSlice","createSlice","name","reducers","addMulticallListeners","action","listeners","removeMulticallListeners","fetchingMulticallResults","fetchingBlockNumber","current","errorFetchingMulticallResults","updateMulticallResults","Object","chunkArray","items","chunkGasLimit","chunks","currentChunk","currentChunkCumulativeGas","i","item","setTimeout","wait","min","Math","max","CancelledError","Error","RetryableError","retry","fn","n","minWait","maxWait","completed","promise","rejectCancelled","resolve","reject","waitRandom","cancel","useDebounce","value","delay","debouncedValue","setDebouncedValue","useState","handler","clearTimeout","fetchChunk","returnData","target","obj","gasLimit","blockTag","gasUsed","chunk","process","half","c0","c1","Promise","activeListeningKeys","allListeners","keyListeners","memo","parseInt","outdatedListeningKeys","listeningKeys","minDataBlockNumber","isDebug","debouncedListeners","cancellations","useRef","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","outdatedCallKeys","chunkedCalls","c","erroredCalls","createUpdater","UpdaterContextBound","React","createMulticall","slice","reducer","args","_useMultipleContractSingleData","_useSingleContractMultipleData","_useSingleContractWithCallData","_useSingleCallResult","hooks","Updater"],"mappings":"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","sourcesContent":["import { CallResult, ListenerOptions } from './types'\n\nexport const DEFAULT_CALL_GAS_REQUIRED = 1_000_000\nexport const DEFAULT_CHUNK_GAS_REQUIRED = 200_000\nexport const CHUNK_GAS_LIMIT = 100_000_000\nexport const CONSERVATIVE_BLOCK_GAS_LIMIT = 10_000_000 // conservative, hard-coded estimate of the current block gas limit\n\n// Consts for hooks\nexport const INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n","import { Call } from '../types'\n\nexport function toCallKey(call: Call): string {\n  let key = `${call.address}-${call.callData}`\n  if (call.gasRequired) {\n    if (!Number.isSafeInteger(call.gasRequired)) {\n      throw new Error(`Invalid number: ${call.gasRequired}`)\n    }\n    key += `-${call.gasRequired}`\n  }\n  return key\n}\n\nexport function parseCallKey(callKey: string): Call {\n  const pcs = callKey.split('-')\n  if (![2, 3].includes(pcs.length)) {\n    throw new Error(`Invalid call key: ${callKey}`)\n  }\n  return {\n    address: pcs[0],\n    callData: pcs[1],\n    ...(pcs[2] ? { gasRequired: Number.parseInt(pcs[2]) } : {}),\n  }\n}\n","import { BigNumber, Contract, utils } from 'ethers'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { INVALID_RESULT } from './constants'\nimport type { MulticallContext } from './context'\nimport type { Call, CallResult, CallState, CallStateResult, ListenerOptions, WithMulticallState } from './types'\nimport { parseCallKey, toCallKey } from './utils/callKeys'\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return BigNumber.isBigNumber(x) || ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  calls: (Call | undefined)[],\n  { blocksPerFetch }: ListenerOptions = { blocksPerFetch: 1 }\n): CallResult[] {\n  const { reducerPath, actions } = context\n  const callResults = useSelector((state: WithMulticallState) => state[reducerPath].callResults)\n  const dispatch = useDispatch()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map((key) => parseCallKey(key))\n    dispatch(\n      actions.addMulticallListeners({\n        chainId,\n        calls,\n        options: { blocksPerFetch },\n      })\n    )\n\n    return () => {\n      dispatch(\n        actions.removeMulticallListeners({\n          chainId,\n          calls,\n          options: { blocksPerFetch },\n        })\n      )\n    }\n  }, [actions, chainId, dispatch, blocksPerFetch, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>((call) => {\n        if (!chainId || !call) return INVALID_RESULT\n\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId]\n  )\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: utils.Interface | undefined,\n  fragment: utils.FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: CallStateResult | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result,\n    error: !success,\n  }\n}\n\n// formats many calls to a single function on a single contract, with the function name and inputs specified\nexport function useSingleContractMultipleData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options: Partial<ListenerOptions> & { gasRequired?: number } = {}\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  // encode callDatas\n  const callDatas = useMemo(\n    () =>\n      contract && fragment\n        ? callInputs.map<string | undefined>((callInput) =>\n            isValidMethodArgs(callInput) ? contract.interface.encodeFunctionData(fragment, callInput) : undefined\n          )\n        : [],\n    [callInputs, contract, fragment]\n  )\n\n  const gasRequired = options?.gasRequired\n  const blocksPerFetch = options?.blocksPerFetch\n\n  // encode calls\n  const calls = useMemo(\n    () =>\n      contract\n        ? callDatas.map<Call | undefined>((callData) =>\n            callData\n              ? {\n                  address: contract.address,\n                  callData,\n                  gasRequired,\n                }\n              : undefined\n          )\n        : [],\n    [contract, callDatas, gasRequired]\n  )\n\n  const results = useCallsData(context, chainId, calls, blocksPerFetch ? { blocksPerFetch } : undefined)\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [results, contract, fragment, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  addresses: (string | undefined)[],\n  contractInterface: utils.Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options: Partial<ListenerOptions> & { gasRequired?: number } = {}\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n\n  // encode callData\n  const callData: string | undefined = useMemo(\n    () => (isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined),\n    [callInputs, contractInterface, fragment]\n  )\n\n  const gasRequired = options?.gasRequired\n  const blocksPerFetch = options?.blocksPerFetch\n\n  // encode calls\n  const calls = useMemo(\n    () =>\n      callData\n        ? addresses.map<Call | undefined>((address) => {\n            return address\n              ? {\n                  address,\n                  callData,\n                  gasRequired,\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, gasRequired]\n  )\n\n  const results = useCallsData(context, chainId, calls, blocksPerFetch ? { blocksPerFetch } : undefined)\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options: Partial<ListenerOptions> & { gasRequired?: number } = {}\n): CallState {\n  return (\n    useSingleContractMultipleData(context, chainId, latestBlockNumber, contract, methodName, [inputs], options)[0] ??\n    INVALID_CALL_STATE\n  )\n}\n\n// formats many calls to any number of functions on a single contract, with only the calldata specified\nexport function useSingleContractWithCallData(\n  context: MulticallContext,\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined,\n  contract: Contract | null | undefined,\n  callDatas: string[],\n  options: Partial<ListenerOptions> & { gasRequired?: number } = {}\n): CallState[] {\n  const gasRequired = options?.gasRequired\n  const blocksPerFetch = options?.blocksPerFetch\n\n  // encode calls\n  const calls = useMemo(\n    () =>\n      contract\n        ? callDatas.map<Call>((callData) => {\n            return {\n              address: contract.address,\n              callData,\n              gasRequired,\n            }\n          })\n        : [],\n    [contract, callDatas, gasRequired]\n  )\n\n  const results = useCallsData(context, chainId, calls, blocksPerFetch ? { blocksPerFetch } : undefined)\n\n  return useMemo(() => {\n    return results.map((result, i) =>\n      toCallState(\n        result,\n        contract?.interface,\n        contract?.interface?.getFunction(callDatas[i].substring(0, 10)),\n        latestBlockNumber\n      )\n    )\n  }, [results, contract, callDatas, latestBlockNumber])\n}\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { MulticallFetchingPayload, MulticallListenerPayload, MulticallResultsPayload, MulticallState } from './types'\nimport { toCallKey } from './utils/callKeys'\n\nconst initialState: MulticallState = {\n  callResults: {},\n}\n\nexport function createMulticallSlice(reducerPath: string) {\n  return createSlice({\n    name: reducerPath,\n    initialState,\n    reducers: {\n      addMulticallListeners: (state, action: PayloadAction<MulticallListenerPayload>) => {\n        const {\n          calls,\n          chainId,\n          options: { blocksPerFetch },\n        } = action.payload\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {})\n        listeners[chainId] = listeners[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          listeners[chainId][callKey] = listeners[chainId][callKey] ?? {}\n          listeners[chainId][callKey][blocksPerFetch] = (listeners[chainId][callKey][blocksPerFetch] ?? 0) + 1\n        })\n      },\n\n      removeMulticallListeners: (state, action: PayloadAction<MulticallListenerPayload>) => {\n        const {\n          calls,\n          chainId,\n          options: { blocksPerFetch },\n        } = action.payload\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {})\n\n        if (!listeners[chainId]) return\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          if (!listeners[chainId][callKey]) return\n          if (!listeners[chainId][callKey][blocksPerFetch]) return\n\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch]\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--\n          }\n        })\n      },\n\n      fetchingMulticallResults: (state, action: PayloadAction<MulticallFetchingPayload>) => {\n        const { chainId, fetchingBlockNumber, calls } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          const current = state.callResults[chainId][callKey]\n          if (!current) {\n            state.callResults[chainId][callKey] = {\n              fetchingBlockNumber,\n            }\n          } else {\n            if ((current.fetchingBlockNumber ?? 0) >= fetchingBlockNumber) return\n            state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber\n          }\n        })\n      },\n\n      errorFetchingMulticallResults: (state, action: PayloadAction<MulticallFetchingPayload>) => {\n        const { chainId, fetchingBlockNumber, calls } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        calls.forEach((call) => {\n          const callKey = toCallKey(call)\n          const current = state.callResults[chainId][callKey]\n          if (!current || typeof current.fetchingBlockNumber !== 'number') return // only should be dispatched if we are already fetching\n          if (current.fetchingBlockNumber <= fetchingBlockNumber) {\n            delete current.fetchingBlockNumber\n            current.data = null\n            current.blockNumber = fetchingBlockNumber\n          }\n        })\n      },\n\n      updateMulticallResults: (state, action: PayloadAction<MulticallResultsPayload>) => {\n        const { chainId, results, blockNumber } = action.payload\n        state.callResults[chainId] = state.callResults[chainId] ?? {}\n        Object.keys(results).forEach((callKey) => {\n          const current = state.callResults[chainId][callKey]\n          if ((current?.blockNumber ?? 0) > blockNumber) return\n          state.callResults[chainId][callKey] = {\n            data: results[callKey],\n            blockNumber,\n          }\n        })\n      },\n    },\n  })\n}\n\nexport type MulticallActions = ReturnType<typeof createMulticallSlice>['actions']\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { DEFAULT_CHUNK_GAS_REQUIRED } from '../constants'\n\n// chunks array into chunks\n// evenly distributes items among the chunks\nexport default function chunkArray<T>(items: T[], chunkGasLimit: number): T[][] {\n  const chunks: T[][] = []\n  let currentChunk: T[] = []\n  let currentChunkCumulativeGas = 0\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n\n    // calculate the gas required by the current item\n    const gasRequired = (item as { gasRequired?: number })?.gasRequired ?? DEFAULT_CHUNK_GAS_REQUIRED\n\n    // if the current chunk is empty, or the current item wouldn't push it over the gas limit,\n    // append the current item and increment the cumulative gas\n    if (currentChunk.length === 0 || currentChunkCumulativeGas + gasRequired < chunkGasLimit) {\n      currentChunk.push(item)\n      currentChunkCumulativeGas += gasRequired\n    } else {\n      // otherwise, push the current chunk and create a new chunk\n      chunks.push(currentChunk)\n      currentChunk = [item]\n      currentChunkCumulativeGas = gasRequired\n    }\n  }\n  if (currentChunk.length > 0) chunks.push(currentChunk)\n\n  return chunks\n}\n","// TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/utils/retry.ts\n\nfunction wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction waitRandom(min: number, max: number): Promise<void> {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nclass CancelledError extends Error {\n  public isCancelledError: true = true\n  constructor() {\n    super('Cancelled')\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {\n  public isRetryableError: true = true\n}\n\nexport interface RetryOptions {\n  n: number\n  minWait: number\n  maxWait: number\n}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry<T>(\n  fn: () => Promise<T>,\n  { n, minWait, maxWait }: RetryOptions\n): { promise: Promise<T>; cancel: () => void } {\n  let completed = false\n  let rejectCancelled: (error: Error) => void\n  const promise = new Promise<T>(async (resolve, reject) => {\n    rejectCancelled = reject\n    while (true) {\n      let result: T\n      try {\n        result = await fn()\n        if (!completed) {\n          resolve(result)\n          completed = true\n        }\n        break\n      } catch (error) {\n        if (completed) {\n          break\n        }\n        if (n <= 0 || !(error as any).isRetryableError) {\n          reject(error)\n          completed = true\n          break\n        }\n        n--\n      }\n      await waitRandom(minWait, maxWait)\n    }\n  })\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return\n      completed = true\n      rejectCancelled(new CancelledError())\n    },\n  }\n}\n","// TODO de-duplicate this file with web interface\n// https://github.com/Uniswap/interface/blob/main/src/hooks/useDebounce.ts\n\nimport { useEffect, useState } from 'react'\n\n// modified from https://usehooks.com/useDebounce/\nexport default function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value)\n\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n    return () => {\n      clearTimeout(handler)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n","import React, { useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport type { UniswapInterfaceMulticall } from './abi/types'\nimport { CHUNK_GAS_LIMIT, DEFAULT_CALL_GAS_REQUIRED } from './constants'\nimport type { MulticallContext } from './context'\nimport type { Call, MulticallState, WithMulticallState } from './types'\nimport { parseCallKey, toCallKey } from './utils/callKeys'\nimport chunkArray from './utils/chunkArray'\nimport { retry, RetryableError } from './utils/retry'\nimport useDebounce from './utils/useDebounce'\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicall multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param blockNumber block number passed as the block tag in the eth_call\n */\nasync function fetchChunk(\n  multicall: UniswapInterfaceMulticall,\n  chunk: Call[],\n  blockNumber: number,\n  isDebug?: boolean\n): Promise<{ success: boolean; returnData: string }[]> {\n  console.debug('Fetching chunk', chunk, blockNumber)\n  try {\n    const { returnData } = await multicall.callStatic.multicall(\n      chunk.map((obj) => ({\n        target: obj.address,\n        callData: obj.callData,\n        gasLimit: obj.gasRequired ?? DEFAULT_CALL_GAS_REQUIRED,\n      })),\n      // we aren't passing through the block gas limit we used to create the chunk, because it causes a problem with the integ tests\n      { blockTag: blockNumber }\n    )\n\n    if (isDebug) {\n      returnData.forEach(({ gasUsed, returnData, success }, i) => {\n        if (\n          !success &&\n          returnData.length === 2 &&\n          gasUsed.gte(Math.floor((chunk[i].gasRequired ?? DEFAULT_CALL_GAS_REQUIRED) * 0.95))\n        ) {\n          console.warn(\n            `A call failed due to requiring ${gasUsed.toString()} vs. allowed ${\n              chunk[i].gasRequired ?? DEFAULT_CALL_GAS_REQUIRED\n            }`,\n            chunk[i]\n          )\n        }\n      })\n    }\n\n    return returnData\n  } catch (e) {\n    const error = e as any\n    if (error.code === -32000 || error.message?.indexOf('header not found') !== -1) {\n      throw new RetryableError(`header not found for block number ${blockNumber}`)\n    } else if (error.code === -32603 || error.message?.indexOf('execution ran out of gas') !== -1) {\n      if (chunk.length > 1) {\n        if (process.env.NODE_ENV === 'development') {\n          console.debug('Splitting a chunk in 2', chunk)\n        }\n        const half = Math.floor(chunk.length / 2)\n        const [c0, c1] = await Promise.all([\n          fetchChunk(multicall, chunk.slice(0, half), blockNumber),\n          fetchChunk(multicall, chunk.slice(half, chunk.length), blockNumber),\n        ])\n        return c0.concat(c1)\n      }\n    }\n    console.error('Failed to fetch chunk', error)\n    throw error\n  }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: MulticallState['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter((key) => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: MulticallState['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport interface UpdaterProps {\n  context: MulticallContext\n  chainId: number | undefined // For now, one updater is required for each chainId to be watched\n  latestBlockNumber: number | undefined\n  contract: UniswapInterfaceMulticall\n  isDebug?: boolean\n}\n\nfunction Updater({ context, chainId, latestBlockNumber, contract, isDebug }: UpdaterProps): null {\n  const { actions, reducerPath } = context\n  const dispatch = useDispatch()\n  const state = useSelector((state: WithMulticallState) => state[reducerPath])\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\n    [unserializedOutdatedCallKeys]\n  )\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !contract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\n\n    const chunkedCalls = chunkArray(calls, CHUNK_GAS_LIMIT)\n\n    if (cancellations.current && cancellations.current.blockNumber !== latestBlockNumber) {\n      cancellations.current.cancellations.forEach((c) => c())\n    }\n\n    dispatch(\n      actions.fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk) => {\n        const { cancel, promise } = retry(() => fetchChunk(contract, chunk, latestBlockNumber, isDebug), {\n          n: Infinity,\n          minWait: 1000,\n          maxWait: 2500,\n        })\n        promise\n          .then((returnData) => {\n            // split the returned slice into errors and results\n            const { erroredCalls, results } = chunk.reduce<{\n              erroredCalls: Call[]\n              results: { [callKey: string]: string | null }\n            }>(\n              (memo, call, i) => {\n                if (returnData[i].success) {\n                  memo.results[toCallKey(call)] = returnData[i].returnData ?? null\n                } else {\n                  memo.erroredCalls.push(call)\n                }\n                return memo\n              },\n              { erroredCalls: [], results: {} }\n            )\n\n            // dispatch any new results\n            if (Object.keys(results).length > 0)\n              dispatch(\n                actions.updateMulticallResults({\n                  chainId,\n                  results,\n                  blockNumber: latestBlockNumber,\n                })\n              )\n\n            // dispatch any errored calls\n            if (erroredCalls.length > 0) {\n              if (isDebug) {\n                returnData.forEach((returnData, ix) => {\n                  if (!returnData.success) {\n                    console.debug('Call failed', chunk[ix], returnData)\n                  }\n                })\n              } else {\n                console.debug('Calls errored in fetch', erroredCalls)\n              }\n              dispatch(\n                actions.errorFetchingMulticallResults({\n                  calls: erroredCalls,\n                  chainId,\n                  fetchingBlockNumber: latestBlockNumber,\n                })\n              )\n            }\n          })\n          .catch((error: any) => {\n            if (error.isCancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber, chunk, chainId)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\n            dispatch(\n              actions.errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              })\n            )\n          })\n        return cancel\n      }),\n    }\n  }, [actions, chainId, contract, dispatch, serializedOutdatedCallKeys, latestBlockNumber, isDebug])\n\n  return null\n}\n\nexport function createUpdater(context: MulticallContext) {\n  const UpdaterContextBound = (props: Omit<UpdaterProps, 'context'>) => {\n    return <Updater context={context} {...props} />\n  }\n  return UpdaterContextBound\n}\n","import type { MulticallContext } from './context'\nimport {\n  useMultipleContractSingleData as _useMultipleContractSingleData,\n  useSingleCallResult as _useSingleCallResult,\n  useSingleContractMultipleData as _useSingleContractMultipleData,\n  useSingleContractWithCallData as _useSingleContractWithCallData,\n} from './hooks'\nimport { createMulticallSlice } from './slice'\nimport { createUpdater } from './updater'\n\ntype RemoveFirstFromTuple<T extends any[]> = T['length'] extends 0\n  ? undefined\n  : ((...b: T) => void) extends (a: any, ...b: infer I) => void\n  ? I\n  : []\ntype ParamsWithoutContext<T extends (...args: any) => any> = RemoveFirstFromTuple<Parameters<T>>\n\nexport interface MulticallOptions {\n  reducerPath?: string\n  // More options can be added here as multicall's capabilities are extended\n}\n\n// Inspired by RTK Query's createApi\nexport function createMulticall(options?: MulticallOptions) {\n  const reducerPath = options?.reducerPath ?? 'multicall'\n  const slice = createMulticallSlice(reducerPath)\n  const { actions, reducer } = slice\n  const context: MulticallContext = { reducerPath, actions }\n\n  const useMultipleContractSingleData = (...args: ParamsWithoutContext<typeof _useMultipleContractSingleData>) =>\n    _useMultipleContractSingleData(context, ...args)\n  const useSingleContractMultipleData = (...args: ParamsWithoutContext<typeof _useSingleContractMultipleData>) =>\n    _useSingleContractMultipleData(context, ...args)\n  const useSingleContractWithCallData = (...args: ParamsWithoutContext<typeof _useSingleContractWithCallData>) =>\n    _useSingleContractWithCallData(context, ...args)\n  const useSingleCallResult = (...args: ParamsWithoutContext<typeof _useSingleCallResult>) =>\n    _useSingleCallResult(context, ...args)\n  const hooks = {\n    useMultipleContractSingleData,\n    useSingleContractMultipleData,\n    useSingleContractWithCallData,\n    useSingleCallResult,\n  }\n\n  const Updater = createUpdater(context)\n\n  return {\n    reducerPath,\n    reducer,\n    actions,\n    hooks,\n    Updater,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}