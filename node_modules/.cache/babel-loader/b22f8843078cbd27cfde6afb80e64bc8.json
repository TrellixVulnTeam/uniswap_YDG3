{"ast":null,"code":"/* eslint no-constant-condition: 0 */\n\n/**\n * Mnemonist Fibonacci Heap\n * =========================\n *\n * Fibonacci heap implementation.\n */\nvar comparators = require('./utils/comparators.js'),\n    forEach = require('obliterator/foreach');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n/**\n * Fibonacci Heap.\n *\n * @constructor\n */\n\nfunction FibonacciHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');\n}\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\n\n\nFibonacciHeap.prototype.clear = function () {\n  // Properties\n  this.root = null;\n  this.min = null;\n  this.size = 0;\n};\n/**\n * Function used to create a node.\n *\n * @param  {any}    item - Target item.\n * @return {object}\n */\n\n\nfunction createNode(item) {\n  return {\n    item: item,\n    degree: 0\n  };\n}\n/**\n * Function used to merge the given node with the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          node - Target node.\n */\n\n\nfunction mergeWithRoot(heap, node) {\n  if (!heap.root) {\n    heap.root = node;\n  } else {\n    node.right = heap.root.right;\n    node.left = heap.root;\n    heap.root.right.left = node;\n    heap.root.right = node;\n  }\n}\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\n\n\nFibonacciHeap.prototype.push = function (item) {\n  var node = createNode(item);\n  node.left = node;\n  node.right = node;\n  mergeWithRoot(this, node);\n  if (!this.min || this.comparator(node.item, this.min.item) <= 0) this.min = node;\n  return ++this.size;\n};\n/**\n * Method used to get the \"first\" item of the heap.\n *\n * @return {any}\n */\n\n\nFibonacciHeap.prototype.peek = function () {\n  return this.min ? this.min.item : undefined;\n};\n/**\n * Function used to consume the given linked list.\n *\n * @param {Node} head - Head node.\n * @param {array}\n */\n\n\nfunction consumeLinkedList(head) {\n  var nodes = [],\n      node = head,\n      flag = false;\n\n  while (true) {\n    if (node === head && flag) break;else if (node === head) flag = true;\n    nodes.push(node);\n    node = node.right;\n  }\n\n  return nodes;\n}\n/**\n * Function used to remove the target node from the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          node - Target node.\n */\n\n\nfunction removeFromRoot(heap, node) {\n  if (heap.root === node) heap.root = node.right;\n  node.left.right = node.right;\n  node.right.left = node.left;\n}\n/**\n * Function used to merge the given node with the child list of a root node.\n *\n * @param {Node} parent - Parent node.\n * @param {Node} node   - Target node.\n */\n\n\nfunction mergeWithChild(parent, node) {\n  if (!parent.child) {\n    parent.child = node;\n  } else {\n    node.right = parent.child.right;\n    node.left = parent.child;\n    parent.child.right.left = node;\n    parent.child.right = node;\n  }\n}\n/**\n * Function used to link one node to another in the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          y - Y node.\n * @param {Node}          x - X node.\n */\n\n\nfunction link(heap, y, x) {\n  removeFromRoot(heap, y);\n  y.left = y;\n  y.right = y;\n  mergeWithChild(x, y);\n  x.degree++;\n  y.parent = x;\n}\n/**\n * Function used to consolidate the heap.\n *\n * @param {FibonacciHeap} heap - Target heap.\n */\n\n\nfunction consolidate(heap) {\n  var A = new Array(heap.size),\n      nodes = consumeLinkedList(heap.root),\n      i,\n      l,\n      x,\n      y,\n      d,\n      t;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    x = nodes[i];\n    d = x.degree;\n\n    while (A[d]) {\n      y = A[d];\n\n      if (heap.comparator(x.item, y.item) > 0) {\n        t = x;\n        x = y;\n        y = t;\n      }\n\n      link(heap, y, x);\n      A[d] = null;\n      d++;\n    }\n\n    A[d] = x;\n  }\n\n  for (i = 0; i < heap.size; i++) {\n    if (A[i] && heap.comparator(A[i].item, heap.min.item) <= 0) heap.min = A[i];\n  }\n}\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\n\n\nFibonacciHeap.prototype.pop = function () {\n  if (!this.size) return undefined;\n  var z = this.min;\n\n  if (z.child) {\n    var nodes = consumeLinkedList(z.child),\n        node,\n        i,\n        l;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      mergeWithRoot(this, node);\n      delete node.parent;\n    }\n  }\n\n  removeFromRoot(this, z);\n\n  if (z === z.right) {\n    this.min = null;\n    this.root = null;\n  } else {\n    this.min = z.right;\n    consolidate(this);\n  }\n\n  this.size--;\n  return z.item;\n};\n/**\n * Convenience known methods.\n */\n\n\nFibonacciHeap.prototype.inspect = function () {\n  var proxy = {\n    size: this.size\n  };\n  if (this.min && 'item' in this.min) proxy.top = this.min.item; // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: FibonacciHeap,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') FibonacciHeap.prototype[Symbol.for('nodejs.util.inspect.custom')] = FibonacciHeap.prototype.inspect;\n/**\n * Fibonacci Maximum Heap.\n *\n * @constructor\n */\n\nfunction MaxFibonacciHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxFibonacciHeap.prototype = FibonacciHeap.prototype;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {FibonacciHeap}\n */\n\nFibonacciHeap.from = function (iterable, comparator) {\n  var heap = new FibonacciHeap(comparator);\n  forEach(iterable, function (value) {\n    heap.push(value);\n  });\n  return heap;\n};\n\nMaxFibonacciHeap.from = function (iterable, comparator) {\n  var heap = new MaxFibonacciHeap(comparator);\n  forEach(iterable, function (value) {\n    heap.push(value);\n  });\n  return heap;\n};\n/**\n * Exporting.\n */\n\n\nFibonacciHeap.MinFibonacciHeap = FibonacciHeap;\nFibonacciHeap.MaxFibonacciHeap = MaxFibonacciHeap;\nmodule.exports = FibonacciHeap;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/fibonacci-heap.js"],"names":["comparators","require","forEach","DEFAULT_COMPARATOR","reverseComparator","FibonacciHeap","comparator","clear","Error","prototype","root","min","size","createNode","item","degree","mergeWithRoot","heap","node","right","left","push","peek","undefined","consumeLinkedList","head","nodes","flag","removeFromRoot","mergeWithChild","parent","child","link","y","x","consolidate","A","Array","i","l","d","t","length","pop","z","inspect","proxy","top","Object","defineProperty","value","enumerable","Symbol","for","MaxFibonacciHeap","from","iterable","MinFibonacciHeap","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition: 0 */\n/**\n * Mnemonist Fibonacci Heap\n * =========================\n *\n * Fibonacci heap implementation.\n */\nvar comparators = require('./utils/comparators.js'),\n    forEach = require('obliterator/foreach');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Fibonacci Heap.\n *\n * @constructor\n */\nfunction FibonacciHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nFibonacciHeap.prototype.clear = function() {\n\n  // Properties\n  this.root = null;\n  this.min = null;\n  this.size = 0;\n};\n\n/**\n * Function used to create a node.\n *\n * @param  {any}    item - Target item.\n * @return {object}\n */\nfunction createNode(item) {\n  return {\n    item: item,\n    degree: 0\n  };\n}\n\n/**\n * Function used to merge the given node with the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          node - Target node.\n */\nfunction mergeWithRoot(heap, node) {\n  if (!heap.root) {\n    heap.root = node;\n  }\n  else {\n    node.right = heap.root.right;\n    node.left = heap.root;\n    heap.root.right.left = node;\n    heap.root.right = node;\n  }\n}\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nFibonacciHeap.prototype.push = function(item) {\n  var node = createNode(item);\n  node.left = node;\n  node.right = node;\n  mergeWithRoot(this, node);\n\n  if (!this.min || this.comparator(node.item, this.min.item) <= 0)\n    this.min = node;\n\n  return ++this.size;\n};\n\n/**\n * Method used to get the \"first\" item of the heap.\n *\n * @return {any}\n */\nFibonacciHeap.prototype.peek = function() {\n  return this.min ? this.min.item : undefined;\n};\n\n/**\n * Function used to consume the given linked list.\n *\n * @param {Node} head - Head node.\n * @param {array}\n */\nfunction consumeLinkedList(head) {\n  var nodes = [],\n      node = head,\n      flag = false;\n\n  while (true) {\n    if (node === head && flag)\n      break;\n    else if (node === head)\n      flag = true;\n\n    nodes.push(node);\n    node = node.right;\n  }\n\n  return nodes;\n}\n\n/**\n * Function used to remove the target node from the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          node - Target node.\n */\nfunction removeFromRoot(heap, node) {\n  if (heap.root === node)\n    heap.root = node.right;\n  node.left.right = node.right;\n  node.right.left = node.left;\n}\n\n/**\n * Function used to merge the given node with the child list of a root node.\n *\n * @param {Node} parent - Parent node.\n * @param {Node} node   - Target node.\n */\nfunction mergeWithChild(parent, node) {\n  if (!parent.child) {\n    parent.child = node;\n  }\n  else {\n    node.right = parent.child.right;\n    node.left = parent.child;\n    parent.child.right.left = node;\n    parent.child.right = node;\n  }\n}\n\n/**\n * Function used to link one node to another in the root list.\n *\n * @param {FibonacciHeap} heap - Target heap.\n * @param {Node}          y - Y node.\n * @param {Node}          x - X node.\n */\nfunction link(heap, y, x) {\n  removeFromRoot(heap, y);\n  y.left = y;\n  y.right = y;\n  mergeWithChild(x, y);\n  x.degree++;\n  y.parent = x;\n}\n\n/**\n * Function used to consolidate the heap.\n *\n * @param {FibonacciHeap} heap - Target heap.\n */\nfunction consolidate(heap) {\n  var A = new Array(heap.size),\n      nodes = consumeLinkedList(heap.root),\n      i, l, x, y, d, t;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    x = nodes[i];\n    d = x.degree;\n\n    while (A[d]) {\n      y = A[d];\n\n      if (heap.comparator(x.item, y.item) > 0) {\n        t = x;\n        x = y;\n        y = t;\n      }\n\n      link(heap, y, x);\n      A[d] = null;\n      d++;\n    }\n\n    A[d] = x;\n  }\n\n  for (i = 0; i < heap.size; i++) {\n    if (A[i] && heap.comparator(A[i].item, heap.min.item) <= 0)\n      heap.min = A[i];\n  }\n}\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nFibonacciHeap.prototype.pop = function() {\n  if (!this.size)\n    return undefined;\n\n  var z = this.min;\n\n  if (z.child) {\n    var nodes = consumeLinkedList(z.child),\n        node,\n        i,\n        l;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n\n      mergeWithRoot(this, node);\n      delete node.parent;\n    }\n  }\n\n  removeFromRoot(this, z);\n\n  if (z === z.right) {\n    this.min = null;\n    this.root = null;\n  }\n  else {\n    this.min = z.right;\n    consolidate(this);\n  }\n\n  this.size--;\n\n  return z.item;\n};\n\n/**\n * Convenience known methods.\n */\nFibonacciHeap.prototype.inspect = function() {\n  var proxy = {\n    size: this.size\n  };\n\n  if (this.min && 'item' in this.min)\n    proxy.top = this.min.item;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: FibonacciHeap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  FibonacciHeap.prototype[Symbol.for('nodejs.util.inspect.custom')] = FibonacciHeap.prototype.inspect;\n\n/**\n * Fibonacci Maximum Heap.\n *\n * @constructor\n */\nfunction MaxFibonacciHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/FibonacciHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxFibonacciHeap.prototype = FibonacciHeap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {FibonacciHeap}\n */\nFibonacciHeap.from = function(iterable, comparator) {\n  var heap = new FibonacciHeap(comparator);\n\n  forEach(iterable, function(value) {\n    heap.push(value);\n  });\n\n  return heap;\n};\n\nMaxFibonacciHeap.from = function(iterable, comparator) {\n  var heap = new MaxFibonacciHeap(comparator);\n\n  forEach(iterable, function(value) {\n    heap.push(value);\n  });\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nFibonacciHeap.MinFibonacciHeap = FibonacciHeap;\nFibonacciHeap.MaxFibonacciHeap = MaxFibonacciHeap;\nmodule.exports = FibonacciHeap;\n"]},"metadata":{},"sourceType":"script"}