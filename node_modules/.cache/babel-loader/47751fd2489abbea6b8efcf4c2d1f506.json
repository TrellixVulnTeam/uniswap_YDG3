{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { Interface } from '@ethersproject/abi';\nimport { abi as IUniswapV3PoolStateABI } from '@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json';\nimport { computePoolAddress } from '@uniswap/v3-sdk';\nimport { Pool } from '@uniswap/v3-sdk';\nimport { useMemo } from 'react';\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses';\nimport { useMultipleContractSingleData } from '../state/multicall/hooks';\nimport { useActiveWeb3React } from './web3';\nconst POOL_STATE_INTERFACE = new Interface(IUniswapV3PoolStateABI);\nexport let PoolState;\n\n(function (PoolState) {\n  PoolState[PoolState[\"LOADING\"] = 0] = \"LOADING\";\n  PoolState[PoolState[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PoolState[PoolState[\"EXISTS\"] = 2] = \"EXISTS\";\n  PoolState[PoolState[\"INVALID\"] = 3] = \"INVALID\";\n})(PoolState || (PoolState = {}));\n\nexport function usePools(poolKeys) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const transformed = useMemo(() => {\n    return poolKeys.map(([currencyA, currencyB, feeAmount]) => {\n      if (!chainId || !currencyA || !currencyB || !feeAmount) return null;\n      const tokenA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n      const tokenB = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped;\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return null;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n      return [token0, token1, feeAmount];\n    });\n  }, [chainId, poolKeys]);\n  const poolAddresses = useMemo(() => {\n    const v3CoreFactoryAddress = chainId && V3_CORE_FACTORY_ADDRESSES[chainId];\n    return transformed.map(value => {\n      if (!v3CoreFactoryAddress || !value) return undefined;\n      return computePoolAddress({\n        factoryAddress: v3CoreFactoryAddress,\n        tokenA: value[0],\n        tokenB: value[1],\n        fee: value[2]\n      });\n    });\n  }, [chainId, transformed]);\n  const slot0s = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'slot0');\n  const liquidities = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'liquidity');\n  return useMemo(() => {\n    return poolKeys.map((_key, index) => {\n      var _transformed$index;\n\n      const [token0, token1, fee] = (_transformed$index = transformed[index]) !== null && _transformed$index !== void 0 ? _transformed$index : [];\n      if (!token0 || !token1 || !fee) return [PoolState.INVALID, null];\n      const {\n        result: slot0,\n        loading: slot0Loading,\n        valid: slot0Valid\n      } = slot0s[index];\n      const {\n        result: liquidity,\n        loading: liquidityLoading,\n        valid: liquidityValid\n      } = liquidities[index];\n      if (!slot0Valid || !liquidityValid) return [PoolState.INVALID, null];\n      if (slot0Loading || liquidityLoading) return [PoolState.LOADING, null];\n      if (!slot0 || !liquidity) return [PoolState.NOT_EXISTS, null];\n      if (!slot0.sqrtPriceX96 || slot0.sqrtPriceX96.eq(0)) return [PoolState.NOT_EXISTS, null];\n\n      try {\n        return [PoolState.EXISTS, new Pool(token0, token1, fee, slot0.sqrtPriceX96, liquidity[0], slot0.tick)];\n      } catch (error) {\n        console.error('Error when constructing the pool', error);\n        return [PoolState.NOT_EXISTS, null];\n      }\n    });\n  }, [liquidities, poolKeys, slot0s, transformed]);\n}\n\n_s(usePools, \"xGtBE3Ms/zlqjzvlzUA3Oi/ykxg=\", false, function () {\n  return [useActiveWeb3React, useMultipleContractSingleData, useMultipleContractSingleData];\n});\n\nexport function usePool(currencyA, currencyB, feeAmount) {\n  _s2();\n\n  const poolKeys = useMemo(() => [[currencyA, currencyB, feeAmount]], [currencyA, currencyB, feeAmount]);\n  return usePools(poolKeys)[0];\n}\n\n_s2(usePool, \"SWZisyHR/2zCsVW9gOIswQWEVlM=\", false, function () {\n  return [usePools];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/usePools.ts"],"names":["Interface","abi","IUniswapV3PoolStateABI","computePoolAddress","Pool","useMemo","V3_CORE_FACTORY_ADDRESSES","useMultipleContractSingleData","useActiveWeb3React","POOL_STATE_INTERFACE","PoolState","usePools","poolKeys","chainId","transformed","map","currencyA","currencyB","feeAmount","tokenA","wrapped","tokenB","equals","token0","token1","sortsBefore","poolAddresses","v3CoreFactoryAddress","value","undefined","factoryAddress","fee","slot0s","liquidities","_key","index","INVALID","result","slot0","loading","slot0Loading","valid","slot0Valid","liquidity","liquidityLoading","liquidityValid","LOADING","NOT_EXISTS","sqrtPriceX96","eq","EXISTS","tick","error","console","usePool"],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { Currency, Token } from '@uniswap/sdk-core'\nimport { abi as IUniswapV3PoolStateABI } from '@uniswap/v3-core/artifacts/contracts/interfaces/pool/IUniswapV3PoolState.sol/IUniswapV3PoolState.json'\nimport { computePoolAddress } from '@uniswap/v3-sdk'\nimport { FeeAmount, Pool } from '@uniswap/v3-sdk'\nimport { useMemo } from 'react'\n\nimport { V3_CORE_FACTORY_ADDRESSES } from '../constants/addresses'\nimport { useMultipleContractSingleData } from '../state/multicall/hooks'\nimport { IUniswapV3PoolStateInterface } from '../types/v3/IUniswapV3PoolState'\nimport { useActiveWeb3React } from './web3'\n\nconst POOL_STATE_INTERFACE = new Interface(IUniswapV3PoolStateABI) as IUniswapV3PoolStateInterface\n\nexport enum PoolState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function usePools(\n  poolKeys: [Currency | undefined, Currency | undefined, FeeAmount | undefined][]\n): [PoolState, Pool | null][] {\n  const { chainId } = useActiveWeb3React()\n\n  const transformed: ([Token, Token, FeeAmount] | null)[] = useMemo(() => {\n    return poolKeys.map(([currencyA, currencyB, feeAmount]) => {\n      if (!chainId || !currencyA || !currencyB || !feeAmount) return null\n\n      const tokenA = currencyA?.wrapped\n      const tokenB = currencyB?.wrapped\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return null\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n      return [token0, token1, feeAmount]\n    })\n  }, [chainId, poolKeys])\n\n  const poolAddresses: (string | undefined)[] = useMemo(() => {\n    const v3CoreFactoryAddress = chainId && V3_CORE_FACTORY_ADDRESSES[chainId]\n\n    return transformed.map((value) => {\n      if (!v3CoreFactoryAddress || !value) return undefined\n      return computePoolAddress({\n        factoryAddress: v3CoreFactoryAddress,\n        tokenA: value[0],\n        tokenB: value[1],\n        fee: value[2],\n      })\n    })\n  }, [chainId, transformed])\n\n  const slot0s = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'slot0')\n  const liquidities = useMultipleContractSingleData(poolAddresses, POOL_STATE_INTERFACE, 'liquidity')\n\n  return useMemo(() => {\n    return poolKeys.map((_key, index) => {\n      const [token0, token1, fee] = transformed[index] ?? []\n      if (!token0 || !token1 || !fee) return [PoolState.INVALID, null]\n\n      const { result: slot0, loading: slot0Loading, valid: slot0Valid } = slot0s[index]\n      const { result: liquidity, loading: liquidityLoading, valid: liquidityValid } = liquidities[index]\n\n      if (!slot0Valid || !liquidityValid) return [PoolState.INVALID, null]\n      if (slot0Loading || liquidityLoading) return [PoolState.LOADING, null]\n\n      if (!slot0 || !liquidity) return [PoolState.NOT_EXISTS, null]\n\n      if (!slot0.sqrtPriceX96 || slot0.sqrtPriceX96.eq(0)) return [PoolState.NOT_EXISTS, null]\n\n      try {\n        return [PoolState.EXISTS, new Pool(token0, token1, fee, slot0.sqrtPriceX96, liquidity[0], slot0.tick)]\n      } catch (error) {\n        console.error('Error when constructing the pool', error)\n        return [PoolState.NOT_EXISTS, null]\n      }\n    })\n  }, [liquidities, poolKeys, slot0s, transformed])\n}\n\nexport function usePool(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): [PoolState, Pool | null] {\n  const poolKeys: [Currency | undefined, Currency | undefined, FeeAmount | undefined][] = useMemo(\n    () => [[currencyA, currencyB, feeAmount]],\n    [currencyA, currencyB, feeAmount]\n  )\n\n  return usePools(poolKeys)[0]\n}\n"]},"metadata":{},"sourceType":"module"}