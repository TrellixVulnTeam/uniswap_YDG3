{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { CurrencyAmount, Percent, Price } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport { useCallback, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from 'state/hooks';\nimport { useTotalSupply } from '../../hooks/useTotalSupply';\nimport { PairState, useV2Pair } from '../../hooks/useV2Pairs';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  _s();\n\n  return useAppSelector(state => state.mint);\n}\n\n_s(useMintState, \"bRaY7Fsh/GrWHjZMhGvF04Z7BZI=\", false, function () {\n  return [useAppSelector];\n});\n\nexport function useMintActionHandlers(noLiquidity) {\n  _s2();\n\n  const dispatch = useAppDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}\n\n_s2(useMintActionHandlers, \"SD7NTLW00Yoy8nJI/INxRyad7FM=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  _s3();\n\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]); // pair\n\n  const [pairState, pair] = useV2Pair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO)) || Boolean(pairState === PairState.EXISTS && pair && JSBI.equal(pair.reserve0.quotient, ZERO) && JSBI.equal(pair.reserve1.quotient, ZERO)); // balances\n\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies]));\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // amounts\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount === null || independentAmount === void 0 ? void 0 : independentAmount.wrapped;\n      const [tokenA, tokenB] = [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped];\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return (dependentCurrency === null || dependentCurrency === void 0 ? void 0 : dependentCurrency.isNative) ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient) : dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair]);\n  const parsedAmounts = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n\n      if ((currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.greaterThan(0)) && (currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.greaterThan(0))) {\n        const value = currencyBAmount.divide(currencyAAmount);\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, value.denominator, value.numerator);\n      }\n\n      return undefined;\n    } else {\n      const wrappedCurrencyA = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount === null || currencyAAmount === void 0 ? void 0 : currencyAAmount.wrapped, currencyBAmount === null || currencyBAmount === void 0 ? void 0 : currencyBAmount.wrapped];\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n      } catch (error) {\n        console.error(error);\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n\n  if (!account) {\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (pairState === PairState.INVALID) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Invalid pair\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Insufficient {0} balance\",\n      values: {\n        0: (_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol\n      }\n    }, void 0, false, void 0, this);\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}\n\n_s3(useDerivedMintInfo, \"fP+U5d79WAwrZQt3S7SVpZXYq4M=\", false, function () {\n  return [useActiveWeb3React, useMintState, useV2Pair, useTotalSupply, useCurrencyBalances];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/mint/hooks.tsx"],"names":["CurrencyAmount","Percent","Price","JSBI","useCallback","useMemo","useAppDispatch","useAppSelector","useTotalSupply","PairState","useV2Pair","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","useDerivedMintInfo","currencyA","currencyB","account","independentField","otherTypedValue","dependentField","currencies","undefined","pairState","pair","totalSupply","liquidityToken","NOT_EXISTS","Boolean","equal","quotient","EXISTS","reserve0","reserve1","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","wrapped","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","isNative","fromRawAmount","parsedAmounts","price","currencyAAmount","currencyBAmount","greaterThan","value","divide","currency","denominator","numerator","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","error","console","poolTokenPercentage","add","INVALID","lessThan","symbol"],"mappings":"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","sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Percent, Price, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport JSBI from 'jsbi'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\n\nimport { useTotalSupply } from '../../hooks/useTotalSupply'\nimport { PairState, useV2Pair } from '../../hooks/useV2Pairs'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, typeInput } from './actions'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useAppSelector((state) => state.mint)\n}\n\nexport function useMintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n  }\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Currency }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  price?: Price<Currency, Currency>\n  noLiquidity?: boolean\n  liquidityMinted?: CurrencyAmount<Token>\n  poolTokenPercentage?: Percent\n  error?: ReactNode\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // pair\n  const [pairState, pair] = useV2Pair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B])\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS ||\n    Boolean(totalSupply && JSBI.equal(totalSupply.quotient, ZERO)) ||\n    Boolean(\n      pairState === PairState.EXISTS &&\n        pair &&\n        JSBI.equal(pair.reserve0.quotient, ZERO) &&\n        JSBI.equal(pair.reserve1.quotient, ZERO)\n    )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField]\n  )\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField])\n      }\n      return undefined\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount?.wrapped\n      const [tokenA, tokenB] = [currencyA?.wrapped, currencyB?.wrapped]\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount)\n        return dependentCurrency?.isNative\n          ? CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n          : dependentTokenAmount\n      }\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount?.greaterThan(0) && currencyBAmount?.greaterThan(0)) {\n        const value = currencyBAmount.divide(currencyAAmount)\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, value.denominator, value.numerator)\n      }\n      return undefined\n    } else {\n      const wrappedCurrencyA = currencyA?.wrapped\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount?.wrapped, currencyBAmount?.wrapped]\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      try {\n        return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n      } catch (error) {\n        console.error(error)\n        return undefined\n      }\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.quotient, totalSupply.add(liquidityMinted).quotient)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: ReactNode | undefined\n  if (!account) {\n    error = <Trans>Connect Wallet</Trans>\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}