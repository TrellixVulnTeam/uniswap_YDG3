{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from 'react';\nimport { isAddress } from '../../utils';\n\nconst alwaysTrue = () => true;\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\n\n\nexport function createTokenFilterFunction(search) {\n  const searchingAddress = isAddress(search);\n\n  if (searchingAddress) {\n    const lower = searchingAddress.toLowerCase();\n    return t => 'isToken' in t ? searchingAddress === t.address : lower === t.address.toLowerCase();\n  }\n\n  const lowerSearchParts = search.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n  if (lowerSearchParts.length === 0) return alwaysTrue;\n\n  const matchesSearch = s => {\n    const sParts = s.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n    return lowerSearchParts.every(p => p.length === 0 || sParts.some(sp => sp.startsWith(p) || sp.endsWith(p)));\n  };\n\n  return ({\n    name,\n    symbol\n  }) => Boolean(symbol && matchesSearch(symbol) || name && matchesSearch(name));\n}\nexport function filterTokens(tokens, search) {\n  return tokens.filter(createTokenFilterFunction(search));\n}\nexport function useSortedTokensByQuery(tokens, searchQuery) {\n  _s();\n\n  return useMemo(() => {\n    if (!tokens) {\n      return [];\n    }\n\n    const symbolMatch = searchQuery.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n\n    if (symbolMatch.length > 1) {\n      return tokens;\n    }\n\n    const exactMatches = [];\n    const symbolSubtrings = [];\n    const rest = []; // sort tokens by exact match -> subtring on symbol match -> rest\n\n    tokens.map(token => {\n      var _token$symbol, _token$symbol2;\n\n      if (((_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase()) === symbolMatch[0]) {\n        return exactMatches.push(token);\n      } else if ((_token$symbol2 = token.symbol) === null || _token$symbol2 === void 0 ? void 0 : _token$symbol2.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\n        return symbolSubtrings.push(token);\n      } else {\n        return rest.push(token);\n      }\n    });\n    return [...exactMatches, ...symbolSubtrings, ...rest];\n  }, [tokens, searchQuery]);\n}\n\n_s(useSortedTokensByQuery, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/components/SearchModal/filtering.ts"],"names":["useMemo","isAddress","alwaysTrue","createTokenFilterFunction","search","searchingAddress","lower","toLowerCase","t","address","lowerSearchParts","split","filter","s","length","matchesSearch","sParts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean","filterTokens","tokens","useSortedTokensByQuery","searchQuery","symbolMatch","exactMatches","symbolSubtrings","rest","map","token","push","trim"],"mappings":"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","sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { TokenInfo } from '@uniswap/token-lists'\nimport { useMemo } from 'react'\n\nimport { isAddress } from '../../utils'\n\nconst alwaysTrue = () => true\n\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\nexport function createTokenFilterFunction<T extends Token | TokenInfo>(search: string): (tokens: T) => boolean {\n  const searchingAddress = isAddress(search)\n\n  if (searchingAddress) {\n    const lower = searchingAddress.toLowerCase()\n    return (t: T) => ('isToken' in t ? searchingAddress === t.address : lower === t.address.toLowerCase())\n  }\n\n  const lowerSearchParts = search\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0)\n\n  if (lowerSearchParts.length === 0) return alwaysTrue\n\n  const matchesSearch = (s: string): boolean => {\n    const sParts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return ({ name, symbol }: T): boolean => Boolean((symbol && matchesSearch(symbol)) || (name && matchesSearch(name)))\n}\n\nexport function filterTokens<T extends Token | TokenInfo>(tokens: T[], search: string): T[] {\n  return tokens.filter(createTokenFilterFunction(search))\n}\n\nexport function useSortedTokensByQuery(tokens: Token[] | undefined, searchQuery: string): Token[] {\n  return useMemo(() => {\n    if (!tokens) {\n      return []\n    }\n\n    const symbolMatch = searchQuery\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    if (symbolMatch.length > 1) {\n      return tokens\n    }\n\n    const exactMatches: Token[] = []\n    const symbolSubtrings: Token[] = []\n    const rest: Token[] = []\n\n    // sort tokens by exact match -> subtring on symbol match -> rest\n    tokens.map((token) => {\n      if (token.symbol?.toLowerCase() === symbolMatch[0]) {\n        return exactMatches.push(token)\n      } else if (token.symbol?.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\n        return symbolSubtrings.push(token)\n      } else {\n        return rest.push(token)\n      }\n    })\n\n    return [...exactMatches, ...symbolSubtrings, ...rest]\n  }, [tokens, searchQuery])\n}\n"]},"metadata":{},"sourceType":"module"}