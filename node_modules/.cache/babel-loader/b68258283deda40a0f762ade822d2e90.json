{"ast":null,"code":"/**\n * Mnemonist Set\n * ==============\n *\n * Useful function related to sets such as union, intersection and so on...\n */\n// TODO: optimize versions for less variadicities\n\n/**\n * Variadic function computing the intersection of multiple sets.\n *\n * @param  {...Set} sets - Sets to intersect.\n * @return {Set}         - The intesection.\n */\nexports.intersection = function () {\n  if (arguments.length < 2) throw new Error('mnemonist/Set.intersection: needs at least two arguments.');\n  var I = new Set(); // First we need to find the smallest set\n\n  var smallestSize = Infinity,\n      smallestSet = null;\n  var s,\n      i,\n      l = arguments.length;\n\n  for (i = 0; i < l; i++) {\n    s = arguments[i]; // If one of the set has no items, we can stop right there\n\n    if (s.size === 0) return I;\n\n    if (s.size < smallestSize) {\n      smallestSize = s.size;\n      smallestSet = s;\n    }\n  } // Now we need to intersect this set with the others\n\n\n  var iterator = smallestSet.values(),\n      step,\n      item,\n      add,\n      set; // TODO: we can optimize by iterating each next time over the current intersection\n  // but this probably means more RAM to consume since we'll create n-1 sets rather than\n  // only the one.\n\n  while (step = iterator.next(), !step.done) {\n    item = step.value;\n    add = true;\n\n    for (i = 0; i < l; i++) {\n      set = arguments[i];\n      if (set === smallestSet) continue;\n\n      if (!set.has(item)) {\n        add = false;\n        break;\n      }\n    }\n\n    if (add) I.add(item);\n  }\n\n  return I;\n};\n/**\n * Variadic function computing the union of multiple sets.\n *\n * @param  {...Set} sets - Sets to unite.\n * @return {Set}         - The union.\n */\n\n\nexports.union = function () {\n  if (arguments.length < 2) throw new Error('mnemonist/Set.union: needs at least two arguments.');\n  var U = new Set();\n  var i,\n      l = arguments.length;\n  var iterator, step;\n\n  for (i = 0; i < l; i++) {\n    iterator = arguments[i].values();\n\n    while (step = iterator.next(), !step.done) U.add(step.value);\n  }\n\n  return U;\n};\n/**\n * Function computing the difference between two sets.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {Set}   - The difference.\n */\n\n\nexports.difference = function (A, B) {\n  // If first set is empty\n  if (!A.size) return new Set();\n  if (!B.size) return new Set(A);\n  var D = new Set();\n  var iterator = A.values(),\n      step;\n\n  while (step = iterator.next(), !step.done) {\n    if (!B.has(step.value)) D.add(step.value);\n  }\n\n  return D;\n};\n/**\n * Function computing the symmetric difference between two sets.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {Set}   - The symmetric difference.\n */\n\n\nexports.symmetricDifference = function (A, B) {\n  var S = new Set();\n  var iterator = A.values(),\n      step;\n\n  while (step = iterator.next(), !step.done) {\n    if (!B.has(step.value)) S.add(step.value);\n  }\n\n  iterator = B.values();\n\n  while (step = iterator.next(), !step.done) {\n    if (!A.has(step.value)) S.add(step.value);\n  }\n\n  return S;\n};\n/**\n * Function returning whether A is a subset of B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {boolean}\n */\n\n\nexports.isSubset = function (A, B) {\n  var iterator = A.values(),\n      step; // Shortcuts\n\n  if (A === B) return true;\n  if (A.size > B.size) return false;\n\n  while (step = iterator.next(), !step.done) {\n    if (!B.has(step.value)) return false;\n  }\n\n  return true;\n};\n/**\n * Function returning whether A is a superset of B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {boolean}\n */\n\n\nexports.isSuperset = function (A, B) {\n  return exports.isSubset(B, A);\n};\n/**\n * Function adding the items of set B to the set A.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\n\n\nexports.add = function (A, B) {\n  var iterator = B.values(),\n      step;\n\n  while (step = iterator.next(), !step.done) A.add(step.value);\n\n  return;\n};\n/**\n * Function subtracting the items of set B from the set A.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\n\n\nexports.subtract = function (A, B) {\n  var iterator = B.values(),\n      step;\n\n  while (step = iterator.next(), !step.done) A.delete(step.value);\n\n  return;\n};\n/**\n * Function intersecting the items of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\n\n\nexports.intersect = function (A, B) {\n  var iterator = A.values(),\n      step;\n\n  while (step = iterator.next(), !step.done) {\n    if (!B.has(step.value)) A.delete(step.value);\n  }\n\n  return;\n};\n/**\n * Function disjuncting the items of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\n\n\nexports.disjunct = function (A, B) {\n  var iterator = A.values(),\n      step;\n  var toRemove = [];\n\n  while (step = iterator.next(), !step.done) {\n    if (B.has(step.value)) toRemove.push(step.value);\n  }\n\n  iterator = B.values();\n\n  while (step = iterator.next(), !step.done) {\n    if (!A.has(step.value)) A.add(step.value);\n  }\n\n  for (var i = 0, l = toRemove.length; i < l; i++) A.delete(toRemove[i]);\n\n  return;\n};\n/**\n * Function returning the size of the intersection of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\n\n\nexports.intersectionSize = function (A, B) {\n  var tmp; // We need to know the smallest set\n\n  if (A.size > B.size) {\n    tmp = A;\n    A = B;\n    B = tmp;\n  }\n\n  if (A.size === 0) return 0;\n  if (A === B) return A.size;\n  var iterator = A.values(),\n      step;\n  var I = 0;\n\n  while (step = iterator.next(), !step.done) {\n    if (B.has(step.value)) I++;\n  }\n\n  return I;\n};\n/**\n * Function returning the size of the union of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\n\n\nexports.unionSize = function (A, B) {\n  var I = exports.intersectionSize(A, B);\n  return A.size + B.size - I;\n};\n/**\n * Function returning the Jaccard similarity between A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\n\n\nexports.jaccard = function (A, B) {\n  var I = exports.intersectionSize(A, B);\n  if (I === 0) return 0;\n  var U = A.size + B.size - I;\n  return I / U;\n};\n/**\n * Function returning the overlap coefficient between A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\n\n\nexports.overlap = function (A, B) {\n  var I = exports.intersectionSize(A, B);\n  if (I === 0) return 0;\n  return I / Math.min(A.size, B.size);\n};","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/set.js"],"names":["exports","intersection","arguments","length","Error","I","Set","smallestSize","Infinity","smallestSet","s","i","l","size","iterator","values","step","item","add","set","next","done","value","has","union","U","difference","A","B","D","symmetricDifference","S","isSubset","isSuperset","subtract","delete","intersect","disjunct","toRemove","push","intersectionSize","tmp","unionSize","jaccard","overlap","Math","min"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Set\n * ==============\n *\n * Useful function related to sets such as union, intersection and so on...\n */\n\n// TODO: optimize versions for less variadicities\n\n/**\n * Variadic function computing the intersection of multiple sets.\n *\n * @param  {...Set} sets - Sets to intersect.\n * @return {Set}         - The intesection.\n */\nexports.intersection = function() {\n  if (arguments.length < 2)\n    throw new Error('mnemonist/Set.intersection: needs at least two arguments.');\n\n  var I = new Set();\n\n  // First we need to find the smallest set\n  var smallestSize = Infinity,\n      smallestSet = null;\n\n  var s, i, l = arguments.length;\n\n  for (i = 0; i < l; i++) {\n    s = arguments[i];\n\n    // If one of the set has no items, we can stop right there\n    if (s.size === 0)\n      return I;\n\n    if (s.size < smallestSize) {\n      smallestSize = s.size;\n      smallestSet = s;\n    }\n  }\n\n  // Now we need to intersect this set with the others\n  var iterator = smallestSet.values(),\n      step,\n      item,\n      add,\n      set;\n\n  // TODO: we can optimize by iterating each next time over the current intersection\n  // but this probably means more RAM to consume since we'll create n-1 sets rather than\n  // only the one.\n  while ((step = iterator.next(), !step.done)) {\n    item = step.value;\n    add = true;\n\n    for (i = 0; i < l; i++) {\n      set = arguments[i];\n\n      if (set === smallestSet)\n        continue;\n\n      if (!set.has(item)) {\n        add = false;\n        break;\n      }\n    }\n\n    if (add)\n      I.add(item);\n  }\n\n  return I;\n};\n\n/**\n * Variadic function computing the union of multiple sets.\n *\n * @param  {...Set} sets - Sets to unite.\n * @return {Set}         - The union.\n */\nexports.union = function() {\n  if (arguments.length < 2)\n    throw new Error('mnemonist/Set.union: needs at least two arguments.');\n\n  var U = new Set();\n\n  var i, l = arguments.length;\n\n  var iterator,\n      step;\n\n  for (i = 0; i < l; i++) {\n    iterator = arguments[i].values();\n\n    while ((step = iterator.next(), !step.done))\n      U.add(step.value);\n  }\n\n  return U;\n};\n\n/**\n * Function computing the difference between two sets.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {Set}   - The difference.\n */\nexports.difference = function(A, B) {\n\n  // If first set is empty\n  if (!A.size)\n    return new Set();\n\n  if (!B.size)\n    return new Set(A);\n\n  var D = new Set();\n\n  var iterator = A.values(),\n      step;\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!B.has(step.value))\n      D.add(step.value);\n  }\n\n  return D;\n};\n\n/**\n * Function computing the symmetric difference between two sets.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {Set}   - The symmetric difference.\n */\nexports.symmetricDifference = function(A, B) {\n  var S = new Set();\n\n  var iterator = A.values(),\n      step;\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!B.has(step.value))\n      S.add(step.value);\n  }\n\n  iterator = B.values();\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!A.has(step.value))\n      S.add(step.value);\n  }\n\n  return S;\n};\n\n/**\n * Function returning whether A is a subset of B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {boolean}\n */\nexports.isSubset = function(A, B) {\n  var iterator = A.values(),\n      step;\n\n  // Shortcuts\n  if (A === B)\n    return true;\n\n  if (A.size > B.size)\n    return false;\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!B.has(step.value))\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Function returning whether A is a superset of B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {boolean}\n */\nexports.isSuperset = function(A, B) {\n  return exports.isSubset(B, A);\n};\n\n/**\n * Function adding the items of set B to the set A.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\nexports.add = function(A, B) {\n  var iterator = B.values(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    A.add(step.value);\n\n  return;\n};\n\n/**\n * Function subtracting the items of set B from the set A.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\nexports.subtract = function(A, B) {\n  var iterator = B.values(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    A.delete(step.value);\n\n  return;\n};\n\n/**\n * Function intersecting the items of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\nexports.intersect = function(A, B) {\n  var iterator = A.values(),\n      step;\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!B.has(step.value))\n      A.delete(step.value);\n  }\n\n  return;\n};\n\n/**\n * Function disjuncting the items of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n */\nexports.disjunct = function(A, B) {\n  var iterator = A.values(),\n      step;\n\n  var toRemove = [];\n\n  while ((step = iterator.next(), !step.done)) {\n    if (B.has(step.value))\n      toRemove.push(step.value);\n  }\n\n  iterator = B.values();\n\n  while ((step = iterator.next(), !step.done)) {\n    if (!A.has(step.value))\n      A.add(step.value);\n  }\n\n  for (var i = 0, l = toRemove.length; i < l; i++)\n    A.delete(toRemove[i]);\n\n  return;\n};\n\n/**\n * Function returning the size of the intersection of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\nexports.intersectionSize = function(A, B) {\n  var tmp;\n\n  // We need to know the smallest set\n  if (A.size > B.size) {\n    tmp = A;\n    A = B;\n    B = tmp;\n  }\n\n  if (A.size === 0)\n    return 0;\n\n  if (A === B)\n    return A.size;\n\n  var iterator = A.values(),\n      step;\n\n  var I = 0;\n\n  while ((step = iterator.next(), !step.done)) {\n    if (B.has(step.value))\n      I++;\n  }\n\n  return I;\n};\n\n/**\n * Function returning the size of the union of A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\nexports.unionSize = function(A, B) {\n  var I = exports.intersectionSize(A, B);\n\n  return A.size + B.size - I;\n};\n\n/**\n * Function returning the Jaccard similarity between A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\nexports.jaccard = function(A, B) {\n  var I = exports.intersectionSize(A, B);\n\n  if (I === 0)\n    return 0;\n\n  var U = A.size + B.size - I;\n\n  return I / U;\n};\n\n/**\n * Function returning the overlap coefficient between A & B.\n *\n * @param  {Set} A - First set.\n * @param  {Set} B - Second set.\n * @return {number}\n */\nexports.overlap = function(A, B) {\n  var I = exports.intersectionSize(A, B);\n\n  if (I === 0)\n    return 0;\n\n  return I / Math.min(A.size, B.size);\n};\n"]},"metadata":{},"sourceType":"script"}