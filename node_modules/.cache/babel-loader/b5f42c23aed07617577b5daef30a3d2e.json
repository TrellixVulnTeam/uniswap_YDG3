{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$();\n\nimport { Interface } from '@ethersproject/abi';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport ERC20ABI from 'abis/erc20.json';\nimport JSBI from 'jsbi';\nimport { useMemo } from 'react';\nimport { nativeOnChain, UNI } from '../../constants/tokens';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { useInterfaceMulticall } from '../../hooks/useContract';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { isAddress } from '../../utils';\nimport { useUserUnclaimedAmount } from '../claim/hooks';\nimport { useMultipleContractSingleData, useSingleContractMultipleData } from '../multicall/hooks';\nimport { useTotalUniEarned } from '../stake/hooks';\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\n\nexport function useNativeCurrencyBalances(uncheckedAddresses) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const multicallContract = useInterfaceMulticall();\n  const validAddressInputs = useMemo(() => uncheckedAddresses ? uncheckedAddresses.map(isAddress).filter(a => a !== false).sort().map(addr => [addr]) : [], [uncheckedAddresses]);\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', validAddressInputs);\n  return useMemo(() => validAddressInputs.reduce((memo, [address], i) => {\n    var _results$i, _results$i$result;\n\n    const value = results === null || results === void 0 ? void 0 : (_results$i = results[i]) === null || _results$i === void 0 ? void 0 : (_results$i$result = _results$i.result) === null || _results$i$result === void 0 ? void 0 : _results$i$result[0];\n    if (value && chainId) memo[address] = CurrencyAmount.fromRawAmount(nativeOnChain(chainId), JSBI.BigInt(value.toString()));\n    return memo;\n  }, {}), [validAddressInputs, chainId, results]);\n}\n\n_s(useNativeCurrencyBalances, \"mAbbnZkxyix5yXsQOyFYqvmRg+Q=\", false, function () {\n  return [useActiveWeb3React, useInterfaceMulticall, useSingleContractMultipleData];\n});\n\nconst ERC20Interface = new Interface(ERC20ABI);\nconst tokenBalancesGasRequirement = {\n  gasRequired: 125000\n};\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\n\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  _s2();\n\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20Interface, 'balanceOf', useMemo(() => [address], [address]), tokenBalancesGasRequirement);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return useMemo(() => [address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n\n    if (amount) {\n      memo[token.address] = CurrencyAmount.fromRawAmount(token, amount);\n    }\n\n    return memo;\n  }, {}) : {}, anyLoading], [address, validatedTokens, anyLoading, balances]);\n}\n\n_s2(useTokenBalancesWithLoadingIndicator, \"tdIiOqpWCSBjrJimTPW8Z/zXbD4=\", false, function () {\n  return [useMultipleContractSingleData];\n});\n\nexport function useTokenBalances(address, tokens) {\n  _s3();\n\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n} // get the balance for a single token/account combo\n\n_s3(useTokenBalances, \"mWHFhmTyaoodDeiE1Op0b2ODA8c=\", false, function () {\n  return [useTokenBalancesWithLoadingIndicator];\n});\n\nexport function useTokenBalance(account, token) {\n  _s4();\n\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\n\n_s4(useTokenBalance, \"Bs7OvuixKI6epyl0XTe28FcYl68=\", false, function () {\n  return [useTokenBalances];\n});\n\nexport function useCurrencyBalances(account, currencies) {\n  _s5();\n\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => {\n      var _currency$isToken;\n\n      return (_currency$isToken = currency === null || currency === void 0 ? void 0 : currency.isToken) !== null && _currency$isToken !== void 0 ? _currency$isToken : false;\n    })) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  const containsETH = useMemo(() => {\n    var _currencies$some;\n\n    return (_currencies$some = currencies === null || currencies === void 0 ? void 0 : currencies.some(currency => currency === null || currency === void 0 ? void 0 : currency.isNative)) !== null && _currencies$some !== void 0 ? _currencies$some : false;\n  }, [currencies]);\n  const ethBalance = useNativeCurrencyBalances(containsETH ? [account] : []);\n  return useMemo(() => {\n    var _currencies$map;\n\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return undefined;\n      if (currency.isToken) return tokenBalances[currency.address];\n      if (currency.isNative) return ethBalance[account];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, ethBalance, tokenBalances]);\n}\n\n_s5(useCurrencyBalances, \"z1qHLF0JJMg7mjP4BHcpbw2tY6E=\", false, function () {\n  return [useTokenBalances, useNativeCurrencyBalances];\n});\n\nexport function useCurrencyBalance(account, currency) {\n  _s6();\n\n  return useCurrencyBalances(account, useMemo(() => [currency], [currency]))[0];\n} // mimics useAllBalances\n\n_s6(useCurrencyBalance, \"0wJSopjcTzaCP/pnaYzHun/ibzg=\", false, function () {\n  return [useCurrencyBalances];\n});\n\nexport function useAllTokenBalances() {\n  _s7();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const allTokens = useAllTokens();\n  const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, allTokensArray);\n  return balances !== null && balances !== void 0 ? balances : {};\n} // get the total owned, unclaimed, and unharvested UNI for account\n\n_s7(useAllTokenBalances, \"7STp84isPT54b5VKsakPLqaA76E=\", false, function () {\n  return [useActiveWeb3React, useAllTokens, useTokenBalances];\n});\n\nexport function useAggregateUniBalance() {\n  _s8();\n\n  var _uniBalance$quotient, _uniUnclaimed$quotien, _uniUnHarvested$quoti;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const uni = chainId ? UNI[chainId] : undefined;\n  const uniBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, uni);\n  const uniUnclaimed = useUserUnclaimedAmount(account);\n  const uniUnHarvested = useTotalUniEarned();\n  if (!uni) return undefined;\n  return CurrencyAmount.fromRawAmount(uni, JSBI.add(JSBI.add((_uniBalance$quotient = uniBalance === null || uniBalance === void 0 ? void 0 : uniBalance.quotient) !== null && _uniBalance$quotient !== void 0 ? _uniBalance$quotient : JSBI.BigInt(0), (_uniUnclaimed$quotien = uniUnclaimed === null || uniUnclaimed === void 0 ? void 0 : uniUnclaimed.quotient) !== null && _uniUnclaimed$quotien !== void 0 ? _uniUnclaimed$quotien : JSBI.BigInt(0)), (_uniUnHarvested$quoti = uniUnHarvested === null || uniUnHarvested === void 0 ? void 0 : uniUnHarvested.quotient) !== null && _uniUnHarvested$quoti !== void 0 ? _uniUnHarvested$quoti : JSBI.BigInt(0)));\n}\n\n_s8(useAggregateUniBalance, \"s+axiF0FcVhhniF5qkxI8sGZtyM=\", false, function () {\n  return [useActiveWeb3React, useTokenBalance, useUserUnclaimedAmount, useTotalUniEarned];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/wallet/hooks.ts"],"names":["Interface","CurrencyAmount","ERC20ABI","JSBI","useMemo","nativeOnChain","UNI","useAllTokens","useInterfaceMulticall","useActiveWeb3React","isAddress","useUserUnclaimedAmount","useMultipleContractSingleData","useSingleContractMultipleData","useTotalUniEarned","useNativeCurrencyBalances","uncheckedAddresses","chainId","multicallContract","validAddressInputs","map","filter","a","sort","addr","results","reduce","memo","address","i","value","result","fromRawAmount","BigInt","toString","ERC20Interface","tokenBalancesGasRequirement","gasRequired","useTokenBalancesWithLoadingIndicator","tokens","validatedTokens","t","validatedTokenAddresses","vt","balances","anyLoading","some","callState","loading","length","token","amount","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","currency","isToken","containsETH","isNative","ethBalance","useCurrencyBalance","useAllTokenBalances","allTokens","allTokensArray","Object","values","useAggregateUniBalance","uni","uniBalance","uniUnclaimed","uniUnHarvested","add","quotient"],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport ERC20ABI from 'abis/erc20.json'\nimport { Erc20Interface } from 'abis/types/Erc20'\nimport JSBI from 'jsbi'\nimport { useMemo } from 'react'\n\nimport { nativeOnChain, UNI } from '../../constants/tokens'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { useInterfaceMulticall } from '../../hooks/useContract'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { isAddress } from '../../utils'\nimport { useUserUnclaimedAmount } from '../claim/hooks'\nimport { useMultipleContractSingleData, useSingleContractMultipleData } from '../multicall/hooks'\nimport { useTotalUniEarned } from '../stake/hooks'\n/**\n * Returns a map of the given addresses to their eventually consistent ETH balances.\n */\nexport function useNativeCurrencyBalances(uncheckedAddresses?: (string | undefined)[]): {\n  [address: string]: CurrencyAmount<Currency> | undefined\n} {\n  const { chainId } = useActiveWeb3React()\n  const multicallContract = useInterfaceMulticall()\n\n  const validAddressInputs: [string][] = useMemo(\n    () =>\n      uncheckedAddresses\n        ? uncheckedAddresses\n            .map(isAddress)\n            .filter((a): a is string => a !== false)\n            .sort()\n            .map((addr) => [addr])\n        : [],\n    [uncheckedAddresses]\n  )\n\n  const results = useSingleContractMultipleData(multicallContract, 'getEthBalance', validAddressInputs)\n\n  return useMemo(\n    () =>\n      validAddressInputs.reduce<{ [address: string]: CurrencyAmount<Currency> }>((memo, [address], i) => {\n        const value = results?.[i]?.result?.[0]\n        if (value && chainId)\n          memo[address] = CurrencyAmount.fromRawAmount(nativeOnChain(chainId), JSBI.BigInt(value.toString()))\n        return memo\n      }, {}),\n    [validAddressInputs, chainId, results]\n  )\n}\n\nconst ERC20Interface = new Interface(ERC20ABI) as Erc20Interface\nconst tokenBalancesGasRequirement = { gasRequired: 125_000 }\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: CurrencyAmount<Token> | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(\n    validatedTokenAddresses,\n    ERC20Interface,\n    'balanceOf',\n    useMemo(() => [address], [address]),\n    tokenBalancesGasRequirement\n  )\n\n  const anyLoading: boolean = useMemo(() => balances.some((callState) => callState.loading), [balances])\n\n  return useMemo(\n    () => [\n      address && validatedTokens.length > 0\n        ? validatedTokens.reduce<{ [tokenAddress: string]: CurrencyAmount<Token> | undefined }>((memo, token, i) => {\n            const value = balances?.[i]?.result?.[0]\n            const amount = value ? JSBI.BigInt(value.toString()) : undefined\n            if (amount) {\n              memo[token.address] = CurrencyAmount.fromRawAmount(token, amount)\n            }\n            return memo\n          }, {})\n        : {},\n      anyLoading,\n    ],\n    [address, validatedTokens, anyLoading, balances]\n  )\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: CurrencyAmount<Token> | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): CurrencyAmount<Token> | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(\n  account?: string,\n  currencies?: (Currency | undefined)[]\n): (CurrencyAmount<Currency> | undefined)[] {\n  const tokens = useMemo(\n    () => currencies?.filter((currency): currency is Token => currency?.isToken ?? false) ?? [],\n    [currencies]\n  )\n\n  const tokenBalances = useTokenBalances(account, tokens)\n  const containsETH: boolean = useMemo(() => currencies?.some((currency) => currency?.isNative) ?? false, [currencies])\n  const ethBalance = useNativeCurrencyBalances(containsETH ? [account] : [])\n\n  return useMemo(\n    () =>\n      currencies?.map((currency) => {\n        if (!account || !currency) return undefined\n        if (currency.isToken) return tokenBalances[currency.address]\n        if (currency.isNative) return ethBalance[account]\n        return undefined\n      }) ?? [],\n    [account, currencies, ethBalance, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Currency): CurrencyAmount<Currency> | undefined {\n  return useCurrencyBalances(\n    account,\n    useMemo(() => [currency], [currency])\n  )[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: CurrencyAmount<Token> | undefined } {\n  const { account } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(account ?? undefined, allTokensArray)\n  return balances ?? {}\n}\n\n// get the total owned, unclaimed, and unharvested UNI for account\nexport function useAggregateUniBalance(): CurrencyAmount<Token> | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const uni = chainId ? UNI[chainId] : undefined\n\n  const uniBalance: CurrencyAmount<Token> | undefined = useTokenBalance(account ?? undefined, uni)\n  const uniUnclaimed: CurrencyAmount<Token> | undefined = useUserUnclaimedAmount(account)\n  const uniUnHarvested: CurrencyAmount<Token> | undefined = useTotalUniEarned()\n\n  if (!uni) return undefined\n\n  return CurrencyAmount.fromRawAmount(\n    uni,\n    JSBI.add(\n      JSBI.add(uniBalance?.quotient ?? JSBI.BigInt(0), uniUnclaimed?.quotient ?? JSBI.BigInt(0)),\n      uniUnHarvested?.quotient ?? JSBI.BigInt(0)\n    )\n  )\n}\n"]},"metadata":{},"sourceType":"module"}