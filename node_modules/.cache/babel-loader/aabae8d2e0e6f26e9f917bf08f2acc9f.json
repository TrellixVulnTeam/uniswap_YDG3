{"ast":null,"code":"/**\n * Mnemonist SparseSet\n * ====================\n *\n * JavaScript sparse set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n/**\n * SparseSet.\n *\n * @constructor\n */\n\n\nfunction SparseSet(length) {\n  var ByteArray = getPointerArray(length); // Properties\n\n  this.size = 0;\n  this.length = length;\n  this.dense = new ByteArray(length);\n  this.sparse = new ByteArray(length);\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nSparseSet.prototype.clear = function () {\n  this.size = 0;\n};\n/**\n * Method used to check the existence of a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {SparseSet}\n */\n\n\nSparseSet.prototype.has = function (member) {\n  var index = this.sparse[member];\n  return index < this.size && this.dense[index] === member;\n};\n/**\n * Method used to add a member to the set.\n *\n * @param  {number} member - Member to add.\n * @return {SparseSet}\n */\n\n\nSparseSet.prototype.add = function (member) {\n  var index = this.sparse[member];\n  if (index < this.size && this.dense[index] === member) return this;\n  this.dense[this.size] = member;\n  this.sparse[member] = this.size;\n  this.size++;\n  return this;\n};\n/**\n * Method used to remove a member from the set.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\n\n\nSparseSet.prototype.delete = function (member) {\n  var index = this.sparse[member];\n  if (index >= this.size || this.dense[index] !== member) return false;\n  index = this.dense[this.size - 1];\n  this.dense[this.sparse[member]] = index;\n  this.sparse[index] = this.sparse[member];\n  this.size--;\n  return true;\n};\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nSparseSet.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var item;\n\n  for (var i = 0; i < this.size; i++) {\n    item = this.dense[i];\n    callback.call(scope, item, item);\n  }\n};\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\n\n\nSparseSet.prototype.values = function () {\n  var size = this.size,\n      dense = this.dense,\n      i = 0;\n  return new Iterator(function () {\n    if (i < size) {\n      var item = dense[i];\n      i++;\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') SparseSet.prototype[Symbol.iterator] = SparseSet.prototype.values;\n/**\n * Convenience known methods.\n */\n\nSparseSet.prototype.inspect = function () {\n  var proxy = new Set();\n\n  for (var i = 0; i < this.size; i++) {\n    proxy.add(this.dense[i]);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseSet,\n    enumerable: false\n  });\n  proxy.length = this.length;\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') SparseSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseSet.prototype.inspect;\n/**\n * Exporting.\n */\n\nmodule.exports = SparseSet;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/sparse-set.js"],"names":["Iterator","require","getPointerArray","SparseSet","length","ByteArray","size","dense","sparse","prototype","clear","has","member","index","add","delete","forEach","callback","scope","arguments","item","i","call","values","value","done","Symbol","iterator","inspect","proxy","Set","Object","defineProperty","enumerable","for","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist SparseSet\n * ====================\n *\n * JavaScript sparse set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseSet.\n *\n * @constructor\n */\nfunction SparseSet(length) {\n\n  var ByteArray = getPointerArray(length);\n\n  // Properties\n  this.size = 0;\n  this.length = length;\n  this.dense = new ByteArray(length);\n  this.sparse = new ByteArray(length);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseSet.prototype.clear = function() {\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {SparseSet}\n */\nSparseSet.prototype.has = function(member) {\n  var index = this.sparse[member];\n\n  return (\n    index < this.size &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to add a member to the set.\n *\n * @param  {number} member - Member to add.\n * @return {SparseSet}\n */\nSparseSet.prototype.add = function(member) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member)\n    return this;\n\n  this.dense[this.size] = member;\n  this.sparse[member] = this.size;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove a member from the set.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseSet.prototype.delete = function(member) {\n  var index = this.sparse[member];\n\n  if (index >= this.size || this.dense[index] !== member)\n    return false;\n\n  index = this.dense[this.size - 1];\n  this.dense[this.sparse[member]] = index;\n  this.sparse[index] = this.sparse[member];\n  this.size--;\n\n  return true;\n};\n\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var item;\n\n  for (var i = 0; i < this.size; i++) {\n    item = this.dense[i];\n\n    callback.call(scope, item, item);\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseSet.prototype.values = function() {\n  var size = this.size,\n      dense = this.dense,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = dense[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseSet.prototype[Symbol.iterator] = SparseSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nSparseSet.prototype.inspect = function() {\n  var proxy = new Set();\n\n  for (var i = 0; i < this.size; i++)\n    proxy.add(this.dense[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseSet,\n    enumerable: false\n  });\n\n  proxy.length = this.length;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseSet.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseSet;\n"]},"metadata":{},"sourceType":"script"}