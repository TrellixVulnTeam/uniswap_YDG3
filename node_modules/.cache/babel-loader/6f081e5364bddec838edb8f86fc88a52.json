{"ast":null,"code":"/**\n * Mnemonist LRUMap\n * =================\n *\n * Variant of the LRUCache class that leverages an ES6 Map instead of an object.\n * It might be faster for some use case but it is still hard to understand\n * when a Map can outperform an object in v8.\n */\nvar LRUCache = require('./lru-cache.js'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n/**\n * LRUMap.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\n\n\nfunction LRUMap(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n  if (typeof this.capacity !== 'number' || this.capacity <= 0) throw new Error('mnemonist/lru-map: capacity should be positive number.');\n  var PointerArray = typed.getPointerArray(capacity);\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity); // Properties\n\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = new Map();\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nLRUMap.prototype.clear = function () {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items.clear();\n};\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\n\n\nLRUMap.prototype.set = function (key, value) {\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items.get(key);\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n    return;\n  } // The cache is not yet full\n\n\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  } // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    this.items.delete(this.K[pointer]);\n  } // Storing key & value\n\n\n  this.items.set(key, pointer);\n  this.K[pointer] = key;\n  this.V[pointer] = value; // Moving the item at the front of the list\n\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\n\n\nLRUMap.prototype.setpop = function (key, value) {\n  var oldValue = null;\n  var oldKey = null; // The key already exists, we just need to update the value and splay on top\n\n  var pointer = this.items.get(key);\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {\n      evicted: false,\n      key: key,\n      value: oldValue\n    };\n  } // The cache is not yet full\n\n\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  } // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    this.items.delete(this.K[pointer]);\n  } // Storing key & value\n\n\n  this.items.set(key, pointer);\n  this.K[pointer] = key;\n  this.V[pointer] = value; // Moving the item at the front of the list\n\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer; // Return object if eviction took place, otherwise return null\n\n  if (oldKey) {\n    return {\n      evicted: true,\n      key: oldKey,\n      value: oldValue\n    };\n  } else {\n    return null;\n  }\n};\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\n\n\nLRUMap.prototype.has = function (key) {\n  return this.items.has(key);\n};\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\n\n\nLRUMap.prototype.get = function (key) {\n  var pointer = this.items.get(key);\n  if (typeof pointer === 'undefined') return;\n  this.splayOnTop(pointer);\n  return this.V[pointer];\n};\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\n\n\nLRUMap.prototype.peek = function (key) {\n  var pointer = this.items.get(key);\n  if (typeof pointer === 'undefined') return;\n  return this.V[pointer];\n};\n/**\n * Methods that can be reused as-is from LRUCache.\n */\n\n\nLRUMap.prototype.splayOnTop = LRUCache.prototype.splayOnTop;\nLRUMap.prototype.forEach = LRUCache.prototype.forEach;\nLRUMap.prototype.keys = LRUCache.prototype.keys;\nLRUMap.prototype.values = LRUCache.prototype.values;\nLRUMap.prototype.entries = LRUCache.prototype.entries;\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\n\nif (typeof Symbol !== 'undefined') LRUMap.prototype[Symbol.iterator] = LRUMap.prototype.entries;\n/**\n * Convenience known methods.\n */\n\nLRUMap.prototype.inspect = LRUCache.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUMap}\n */\n\nLRUMap.from = function (iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n    if (typeof capacity !== 'number') throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  } else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUMap(Keys, Values, capacity);\n  forEach(iterable, function (value, key) {\n    cache.set(key, value);\n  });\n  return cache;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = LRUMap;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/lru-map.js"],"names":["LRUCache","require","forEach","typed","iterables","LRUMap","Keys","Values","capacity","arguments","length","Error","PointerArray","getPointerArray","forward","backward","K","Array","V","size","head","tail","items","Map","prototype","clear","set","key","value","pointer","get","splayOnTop","delete","setpop","oldValue","oldKey","evicted","has","peek","keys","values","entries","Symbol","iterator","inspect","from","iterable","guessLength","cache","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist LRUMap\n * =================\n *\n * Variant of the LRUCache class that leverages an ES6 Map instead of an object.\n * It might be faster for some use case but it is still hard to understand\n * when a Map can outperform an object in v8.\n */\nvar LRUCache = require('./lru-cache.js'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n\n/**\n * LRUMap.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\nfunction LRUMap(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n\n  if (typeof this.capacity !== 'number' || this.capacity <= 0)\n    throw new Error('mnemonist/lru-map: capacity should be positive number.');\n\n  var PointerArray = typed.getPointerArray(capacity);\n\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);\n\n  // Properties\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = new Map();\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nLRUMap.prototype.clear = function() {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items.clear();\n};\n\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\nLRUMap.prototype.set = function(key, value) {\n\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items.get(key);\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n\n    return;\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    this.items.delete(this.K[pointer]);\n  }\n\n  // Storing key & value\n  this.items.set(key, pointer);\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\nLRUMap.prototype.setpop = function(key, value) {\n  var oldValue = null;\n  var oldKey = null;\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items.get(key);\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {evicted: false, key: key, value: oldValue};\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    this.items.delete(this.K[pointer]);\n  }\n\n  // Storing key & value\n  this.items.set(key, pointer);\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n\n  // Return object if eviction took place, otherwise return null\n  if (oldKey) {\n    return {evicted: true, key: oldKey, value: oldValue};\n  }\n  else {\n    return null;\n  }\n};\n\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\nLRUMap.prototype.has = function(key) {\n  return this.items.has(key);\n};\n\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUMap.prototype.get = function(key) {\n  var pointer = this.items.get(key);\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  this.splayOnTop(pointer);\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUMap.prototype.peek = function(key) {\n  var pointer = this.items.get(key);\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  return this.V[pointer];\n};\n\n/**\n * Methods that can be reused as-is from LRUCache.\n */\nLRUMap.prototype.splayOnTop = LRUCache.prototype.splayOnTop;\nLRUMap.prototype.forEach = LRUCache.prototype.forEach;\nLRUMap.prototype.keys = LRUCache.prototype.keys;\nLRUMap.prototype.values = LRUCache.prototype.values;\nLRUMap.prototype.entries = LRUCache.prototype.entries;\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  LRUMap.prototype[Symbol.iterator] = LRUMap.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nLRUMap.prototype.inspect = LRUCache.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUMap}\n */\nLRUMap.from = function(iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n  else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUMap(Keys, Values, capacity);\n\n  forEach(iterable, function(value, key) {\n    cache.set(key, value);\n  });\n\n  return cache;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = LRUMap;\n"]},"metadata":{},"sourceType":"script"}