{"ast":null,"code":"import _regeneratorRuntime from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _slicedToArray from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _asyncToGenerator from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import contenthashToUri from'./contenthashToUri';import{parseENSAddress}from'./parseENSAddress';import uriToHttp from'./uriToHttp';// lazily get the validator the first time it is used\nvar getTokenListValidator=function(){var tokenListValidator;return function(){if(!tokenListValidator){tokenListValidator=new Promise(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve){var _yield$Promise$all,_yield$Promise$all2,ajv,schema,validator;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return Promise.all([import('ajv'),import('@uniswap/token-lists/src/tokenlist.schema.json')]);case 2:_yield$Promise$all=_context.sent;_yield$Promise$all2=_slicedToArray(_yield$Promise$all,2);ajv=_yield$Promise$all2[0];schema=_yield$Promise$all2[1];validator=new ajv.default({allErrors:true}).compile(schema);resolve(validator);case 8:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}());}return tokenListValidator;};}();/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */export default function getTokenList(_x2,_x3){return _getTokenList.apply(this,arguments);}function _getTokenList(){_getTokenList=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(listUrl,resolveENSContentHash){var tokenListValidator,parsedENS,urls,_parsedENS$ensPath,contentHashUri,translatedUri,i,url,isLast,response,_yield$Promise$all3,_yield$Promise$all4,json,validator,_validator$errors$red,_validator$errors,validationErrors;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:tokenListValidator=getTokenListValidator();parsedENS=parseENSAddress(listUrl);if(!parsedENS){_context2.next=24;break;}_context2.prev=3;_context2.next=6;return resolveENSContentHash(parsedENS.ensName);case 6:contentHashUri=_context2.sent;_context2.next=13;break;case 9:_context2.prev=9;_context2.t0=_context2[\"catch\"](3);console.debug(\"Failed to resolve ENS name: \".concat(parsedENS.ensName),_context2.t0);throw new Error(\"Failed to resolve ENS name: \".concat(parsedENS.ensName));case 13:_context2.prev=13;translatedUri=contenthashToUri(contentHashUri);_context2.next=21;break;case 17:_context2.prev=17;_context2.t1=_context2[\"catch\"](13);console.debug('Failed to translate contenthash to URI',contentHashUri);throw new Error(\"Failed to translate contenthash to URI: \".concat(contentHashUri));case 21:urls=uriToHttp(\"\".concat(translatedUri).concat((_parsedENS$ensPath=parsedENS.ensPath)!==null&&_parsedENS$ensPath!==void 0?_parsedENS$ensPath:''));_context2.next=25;break;case 24:urls=uriToHttp(listUrl);case 25:i=0;case 26:if(!(i<urls.length)){_context2.next=59;break;}url=urls[i];isLast=i===urls.length-1;response=void 0;_context2.prev=30;_context2.next=33;return fetch(url,{credentials:'omit'});case 33:response=_context2.sent;_context2.next=42;break;case 36:_context2.prev=36;_context2.t2=_context2[\"catch\"](30);console.debug('Failed to fetch list',listUrl,_context2.t2);if(!isLast){_context2.next=41;break;}throw new Error(\"Failed to download list \".concat(listUrl));case 41:return _context2.abrupt(\"continue\",56);case 42:if(response.ok){_context2.next=46;break;}if(!isLast){_context2.next=45;break;}throw new Error(\"Failed to download list \".concat(listUrl));case 45:return _context2.abrupt(\"continue\",56);case 46:_context2.next=48;return Promise.all([response.json(),tokenListValidator]);case 48:_yield$Promise$all3=_context2.sent;_yield$Promise$all4=_slicedToArray(_yield$Promise$all3,2);json=_yield$Promise$all4[0];validator=_yield$Promise$all4[1];if(validator(json)){_context2.next=55;break;}validationErrors=(_validator$errors$red=(_validator$errors=validator.errors)===null||_validator$errors===void 0?void 0:_validator$errors.reduce(function(memo,error){var _error$message;var add=\"\".concat(error.dataPath,\" \").concat((_error$message=error.message)!==null&&_error$message!==void 0?_error$message:'');return memo.length>0?\"\".concat(memo,\"; \").concat(add):\"\".concat(add);},''))!==null&&_validator$errors$red!==void 0?_validator$errors$red:'unknown error';throw new Error(\"Token list failed validation: \".concat(validationErrors));case 55:return _context2.abrupt(\"return\",json);case 56:i++;_context2.next=26;break;case 59:throw new Error('Unrecognized list URL protocol.');case 60:case\"end\":return _context2.stop();}}},_callee2,null,[[3,9],[13,17],[30,36]]);}));return _getTokenList.apply(this,arguments);}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/utils/getTokenList.ts"],"names":["contenthashToUri","parseENSAddress","uriToHttp","getTokenListValidator","tokenListValidator","Promise","resolve","all","ajv","schema","validator","default","allErrors","compile","getTokenList","listUrl","resolveENSContentHash","parsedENS","ensName","contentHashUri","console","debug","Error","translatedUri","urls","ensPath","i","length","url","isLast","response","fetch","credentials","ok","json","validationErrors","errors","reduce","memo","error","add","dataPath","message"],"mappings":"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","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport { ValidateFunction } from 'ajv'\n\nimport contenthashToUri from './contenthashToUri'\nimport { parseENSAddress } from './parseENSAddress'\nimport uriToHttp from './uriToHttp'\n\n// lazily get the validator the first time it is used\nconst getTokenListValidator = (() => {\n  let tokenListValidator: Promise<ValidateFunction>\n  return () => {\n    if (!tokenListValidator) {\n      tokenListValidator = new Promise<ValidateFunction>(async (resolve) => {\n        const [ajv, schema] = await Promise.all([\n          import('ajv'),\n          import('@uniswap/token-lists/src/tokenlist.schema.json'),\n        ])\n        const validator = new ajv.default({ allErrors: true }).compile(schema)\n        resolve(validator)\n      })\n    }\n    return tokenListValidator\n  }\n})()\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>\n): Promise<TokenList> {\n  const tokenListValidator = getTokenListValidator()\n  const parsedENS = parseENSAddress(listUrl)\n  let urls: string[]\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      console.debug(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      console.debug('Failed to translate contenthash to URI', contentHashUri)\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url, { credentials: 'omit' })\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    const [json, validator] = await Promise.all([response.json(), tokenListValidator])\n    if (!validator(json)) {\n      const validationErrors: string =\n        validator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n"]},"metadata":{},"sourceType":"module"}