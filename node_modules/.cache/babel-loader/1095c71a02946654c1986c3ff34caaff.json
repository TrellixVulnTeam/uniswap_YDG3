{"ast":null,"code":"/**\n * Mnemonist Suffix Array\n * =======================\n *\n * Linear time implementation of a suffix array using the recursive\n * method by Karkkainen and Sanders.\n *\n * [References]:\n * https://www.cs.helsinki.fi/u/tpkarkka/publications/jacm05-revised.pdf\n * http://people.mpi-inf.mpg.de/~sanders/programs/suffix/\n * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.184.442&rep=rep1&type=pdf\n *\n * [Article]:\n * \"Simple Linear Work Suffix Array Construction\", Karkkainen and Sanders.\n *\n * [Note]:\n * A paper by Simon J. Puglisi, William F. Smyth & Andrew Turpin named\n * \"The Performance of Linear Time Suffix Sorting Algorithms\" seems to\n * prove that supralinear algorithm are in fact better faring for\n * \"real\" world use cases. It would be nice to check this out in JavaScript\n * because the high level of the language could change a lot to the fact.\n *\n * The current code is largely inspired by the following:\n * https://github.com/tixxit/suffixarray/blob/master/suffixarray.js\n */\n\n/**\n * Constants.\n */\nvar SEPARATOR = \"\\x01\";\n/**\n * Function used to sort the triples.\n *\n * @param {string|array} string - Padded sequence.\n * @param {array}        array  - Array to sort (will be mutated).\n * @param {number}       offset - Index offset.\n */\n\nfunction sort(string, array, offset) {\n  var l = array.length,\n      buckets = [],\n      i = l,\n      j = -1,\n      b,\n      d = 0,\n      bits;\n\n  while (i--) {\n    j = Math.max(string[array[i] + offset], j);\n  }\n\n  bits = j >> 24 && 32 || j >> 16 && 24 || j >> 8 && 16 || 8;\n\n  for (; d < bits; d += 4) {\n    for (i = 16; i--;) {\n      buckets[i] = [];\n    }\n\n    for (i = l; i--;) {\n      buckets[string[array[i] + offset] >> d & 15].push(array[i]);\n    }\n\n    for (b = 0; b < 16; b++) {\n      for (j = buckets[b].length; j--;) {\n        array[++i] = buckets[b][j];\n      }\n    }\n  }\n}\n/**\n * Comparison helper.\n */\n\n\nfunction compare(string, lookup, m, n) {\n  return string[m] - string[n] || (m % 3 === 2 ? string[m + 1] - string[n + 1] || lookup[m + 2] - lookup[n + 2] : lookup[m + 1] - lookup[n + 1]);\n}\n/**\n * Recursive function used to build the suffix tree in linear time.\n *\n * @param  {string|array} string - Padded sequence.\n * @param  {number}       l      - True length of sequence (unpadded).\n * @return {array}\n */\n\n\nfunction build(string, l) {\n  var a = [],\n      b = [],\n      al = 2 * l / 3 | 0,\n      bl = l - al,\n      r = al + 1 >> 1,\n      i = al,\n      j = 0,\n      k,\n      lookup = [],\n      result = [];\n  if (l === 1) return [0];\n\n  while (i--) {\n    a[i] = (i * 3 >> 1) + 1;\n  }\n\n  for (i = 3; i--;) {\n    sort(string, a, i);\n  }\n\n  j = b[(a[0] / 3 | 0) + (a[0] % 3 === 1 ? 0 : r)] = 1;\n\n  for (i = 1; i < al; i++) {\n    if (string[a[i]] !== string[a[i - 1]] || string[a[i] + 1] !== string[a[i - 1] + 1] || string[a[i] + 2] !== string[a[i - 1] + 2]) j++;\n    b[(a[i] / 3 | 0) + (a[i] % 3 === 1 ? 0 : r)] = j;\n  }\n\n  if (j < al) {\n    b = build(b, al);\n\n    for (i = al; i--;) {\n      a[i] = b[i] < r ? b[i] * 3 + 1 : (b[i] - r) * 3 + 2;\n    }\n  }\n\n  for (i = al; i--;) {\n    lookup[a[i]] = i;\n  }\n\n  lookup[l] = -1;\n  lookup[l + 1] = -2;\n  b = l % 3 === 1 ? [l - 1] : [];\n\n  for (i = 0; i < al; i++) {\n    if (a[i] % 3 === 1) b.push(a[i] - 1);\n  }\n\n  sort(string, b, 0);\n\n  for (i = 0, j = 0, k = 0; i < al && j < bl;) {\n    result[k++] = compare(string, lookup, a[i], b[j]) < 0 ? a[i++] : b[j++];\n  }\n\n  while (i < al) {\n    result[k++] = a[i++];\n  }\n\n  while (j < bl) {\n    result[k++] = b[j++];\n  }\n\n  return result;\n}\n/**\n * Function used to create the array we are going to work on.\n *\n * @param  {string|array} target - Target sequence.\n * @return {array}\n */\n\n\nfunction convert(target) {\n  // Creating the alphabet array\n  var length = target.length,\n      paddingOffset = length % 3,\n      array = new Array(length + paddingOffset),\n      l,\n      i; // If we have an arbitrary sequence, we need to transform it\n\n  if (typeof target !== 'string') {\n    var uniqueTokens = Object.create(null);\n\n    for (i = 0; i < length; i++) {\n      if (!uniqueTokens[target[i]]) uniqueTokens[target[i]] = true;\n    }\n\n    var alphabet = Object.create(null),\n        sortedUniqueTokens = Object.keys(uniqueTokens).sort();\n\n    for (i = 0, l = sortedUniqueTokens.length; i < l; i++) {\n      alphabet[sortedUniqueTokens[i]] = i + 1;\n    }\n\n    for (i = 0; i < length; i++) {\n      array[i] = alphabet[target[i]];\n    }\n  } else {\n    for (i = 0; i < length; i++) {\n      array[i] = target.charCodeAt(i);\n    }\n  } // Padding the array\n\n\n  for (; i < paddingOffset; i++) {\n    array[i] = 0;\n  }\n\n  return array;\n}\n/**\n * Suffix Array.\n *\n * @constructor\n * @param {string|array} string - Sequence for which to build the suffix array.\n */\n\n\nfunction SuffixArray(string) {\n  // Properties\n  this.hasArbitrarySequence = typeof string !== 'string';\n  this.string = string;\n  this.length = string.length; // Building the array\n\n  this.array = build(convert(string), this.length);\n}\n/**\n * Convenience known methods.\n */\n\n\nSuffixArray.prototype.toString = function () {\n  return this.array.join(',');\n};\n\nSuffixArray.prototype.toJSON = function () {\n  return this.array;\n};\n\nSuffixArray.prototype.inspect = function () {\n  var array = new Array(this.length);\n\n  for (var i = 0; i < this.length; i++) {\n    array[i] = this.string.slice(this.array[i]);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(array, 'constructor', {\n    value: SuffixArray,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') SuffixArray.prototype[Symbol.for('nodejs.util.inspect.custom')] = SuffixArray.prototype.inspect;\n/**\n * Generalized Suffix Array.\n *\n * @constructor\n */\n\nfunction GeneralizedSuffixArray(strings) {\n  // Properties\n  this.hasArbitrarySequence = typeof strings[0] !== 'string';\n  this.size = strings.length;\n\n  if (this.hasArbitrarySequence) {\n    this.text = [];\n\n    for (var i = 0, l = this.size; i < l; i++) {\n      this.text.push.apply(this.text, strings[i]);\n      if (i < l - 1) this.text.push(SEPARATOR);\n    }\n  } else {\n    this.text = strings.join(SEPARATOR);\n  }\n\n  this.firstLength = strings[0].length;\n  this.length = this.text.length; // Building the array\n\n  this.array = build(convert(this.text), this.length);\n}\n/**\n * Method used to retrieve the longest common subsequence of the generalized\n * suffix array.\n *\n * @return {string|array}\n */\n\n\nGeneralizedSuffixArray.prototype.longestCommonSubsequence = function () {\n  var lcs = this.hasArbitrarySequence ? [] : '',\n      lcp,\n      i,\n      j,\n      s,\n      t;\n\n  for (i = 1; i < this.length; i++) {\n    s = this.array[i];\n    t = this.array[i - 1];\n    if (s < this.firstLength && t < this.firstLength) continue;\n    if (s > this.firstLength && t > this.firstLength) continue;\n    lcp = Math.min(this.length - s, this.length - t);\n\n    for (j = 0; j < lcp; j++) {\n      if (this.text[s + j] !== this.text[t + j]) {\n        lcp = j;\n        break;\n      }\n    }\n\n    if (lcp > lcs.length) lcs = this.text.slice(s, s + lcp);\n  }\n\n  return lcs;\n};\n/**\n * Convenience known methods.\n */\n\n\nGeneralizedSuffixArray.prototype.toString = function () {\n  return this.array.join(',');\n};\n\nGeneralizedSuffixArray.prototype.toJSON = function () {\n  return this.array;\n};\n\nGeneralizedSuffixArray.prototype.inspect = function () {\n  var array = new Array(this.length);\n\n  for (var i = 0; i < this.length; i++) {\n    array[i] = this.text.slice(this.array[i]);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(array, 'constructor', {\n    value: GeneralizedSuffixArray,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') GeneralizedSuffixArray.prototype[Symbol.for('nodejs.util.inspect.custom')] = GeneralizedSuffixArray.prototype.inspect;\n/**\n * Exporting.\n */\n\nSuffixArray.GeneralizedSuffixArray = GeneralizedSuffixArray;\nmodule.exports = SuffixArray;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/suffix-array.js"],"names":["SEPARATOR","sort","string","array","offset","l","length","buckets","i","j","b","d","bits","Math","max","push","compare","lookup","m","n","build","a","al","bl","r","k","result","convert","target","paddingOffset","Array","uniqueTokens","Object","create","alphabet","sortedUniqueTokens","keys","charCodeAt","SuffixArray","hasArbitrarySequence","prototype","toString","join","toJSON","inspect","slice","defineProperty","value","enumerable","Symbol","for","GeneralizedSuffixArray","strings","size","text","apply","firstLength","longestCommonSubsequence","lcs","lcp","s","t","min","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Suffix Array\n * =======================\n *\n * Linear time implementation of a suffix array using the recursive\n * method by Karkkainen and Sanders.\n *\n * [References]:\n * https://www.cs.helsinki.fi/u/tpkarkka/publications/jacm05-revised.pdf\n * http://people.mpi-inf.mpg.de/~sanders/programs/suffix/\n * http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.184.442&rep=rep1&type=pdf\n *\n * [Article]:\n * \"Simple Linear Work Suffix Array Construction\", Karkkainen and Sanders.\n *\n * [Note]:\n * A paper by Simon J. Puglisi, William F. Smyth & Andrew Turpin named\n * \"The Performance of Linear Time Suffix Sorting Algorithms\" seems to\n * prove that supralinear algorithm are in fact better faring for\n * \"real\" world use cases. It would be nice to check this out in JavaScript\n * because the high level of the language could change a lot to the fact.\n *\n * The current code is largely inspired by the following:\n * https://github.com/tixxit/suffixarray/blob/master/suffixarray.js\n */\n\n/**\n * Constants.\n */\nvar SEPARATOR = '\\u0001';\n\n/**\n * Function used to sort the triples.\n *\n * @param {string|array} string - Padded sequence.\n * @param {array}        array  - Array to sort (will be mutated).\n * @param {number}       offset - Index offset.\n */\nfunction sort(string, array, offset) {\n  var l = array.length,\n      buckets = [],\n      i = l,\n      j = -1,\n      b,\n      d = 0,\n      bits;\n\n  while (i--)\n    j = Math.max(string[array[i] + offset], j);\n\n  bits = j >> 24 && 32 || j >> 16 && 24 || j >> 8 && 16 || 8;\n\n  for (; d < bits; d += 4) {\n    for (i = 16; i--;)\n      buckets[i] = [];\n    for (i = l; i--;)\n      buckets[((string[array[i] + offset]) >> d) & 15].push(array[i]);\n    for (b = 0; b < 16; b++) {\n      for (j = buckets[b].length; j--;)\n        array[++i] = buckets[b][j];\n    }\n  }\n}\n\n/**\n * Comparison helper.\n */\nfunction compare(string, lookup, m, n) {\n  return (\n    (string[m] - string[n]) ||\n    (m % 3 === 2 ?\n      (string[m + 1] - string[n + 1]) || (lookup[m + 2] - lookup[n + 2]) :\n      (lookup[m + 1] - lookup[n + 1]))\n  );\n}\n\n/**\n * Recursive function used to build the suffix tree in linear time.\n *\n * @param  {string|array} string - Padded sequence.\n * @param  {number}       l      - True length of sequence (unpadded).\n * @return {array}\n */\nfunction build(string, l) {\n  var a = [],\n      b = [],\n      al = (2 * l / 3) | 0,\n      bl = l - al,\n      r = (al + 1) >> 1,\n      i = al,\n      j = 0,\n      k,\n      lookup = [],\n      result = [];\n\n  if (l === 1)\n    return [0];\n\n  while (i--)\n    a[i] = ((i * 3) >> 1) + 1;\n\n  for (i = 3; i--;)\n    sort(string, a, i);\n\n  j = b[((a[0] / 3) | 0) + (a[0] % 3 === 1 ? 0 : r)] = 1;\n\n  for (i = 1; i < al; i++) {\n    if (string[a[i]] !== string[a[i - 1]] ||\n        string[a[i] + 1] !== string[a[i - 1] + 1] ||\n        string[a[i] + 2] !== string[a[i - 1] + 2])\n      j++;\n\n    b[((a[i] / 3) | 0) + (a[i] % 3 === 1 ? 0 : r)] = j;\n  }\n\n  if (j < al) {\n    b = build(b, al);\n\n    for (i = al; i--;)\n      a[i] = b[i] < r ? b[i] * 3 + 1 : ((b[i] - r) * 3 + 2);\n  }\n\n  for (i = al; i--;)\n    lookup[a[i]] = i;\n  lookup[l] = -1;\n  lookup[l + 1] = -2;\n\n  b = l % 3 === 1 ? [l - 1] : [];\n\n  for (i = 0; i < al; i++) {\n    if (a[i] % 3 === 1)\n      b.push(a[i] - 1);\n  }\n\n  sort(string, b, 0);\n\n  for (i = 0, j = 0, k = 0; i < al && j < bl;)\n    result[k++] = (\n      compare(string, lookup, a[i], b[j]) < 0 ?\n        a[i++] :\n        b[j++]\n    );\n\n  while (i < al)\n    result[k++] = a[i++];\n\n  while (j < bl)\n    result[k++] = b[j++];\n\n  return result;\n}\n\n/**\n * Function used to create the array we are going to work on.\n *\n * @param  {string|array} target - Target sequence.\n * @return {array}\n */\nfunction convert(target) {\n\n  // Creating the alphabet array\n  var length = target.length,\n      paddingOffset = length % 3,\n      array = new Array(length + paddingOffset),\n      l,\n      i;\n\n  // If we have an arbitrary sequence, we need to transform it\n  if (typeof target !== 'string') {\n    var uniqueTokens = Object.create(null);\n\n    for (i = 0; i < length; i++) {\n      if (!uniqueTokens[target[i]])\n        uniqueTokens[target[i]] = true;\n    }\n\n    var alphabet = Object.create(null),\n        sortedUniqueTokens = Object.keys(uniqueTokens).sort();\n\n    for (i = 0, l = sortedUniqueTokens.length; i < l; i++)\n      alphabet[sortedUniqueTokens[i]] = i + 1;\n\n    for (i = 0; i < length; i++) {\n      array[i] = alphabet[target[i]];\n    }\n  }\n  else {\n    for (i = 0; i < length; i++)\n      array[i] = target.charCodeAt(i);\n  }\n\n  // Padding the array\n  for (; i < paddingOffset; i++)\n    array[i] = 0;\n\n  return array;\n}\n\n/**\n * Suffix Array.\n *\n * @constructor\n * @param {string|array} string - Sequence for which to build the suffix array.\n */\nfunction SuffixArray(string) {\n\n  // Properties\n  this.hasArbitrarySequence = typeof string !== 'string';\n  this.string = string;\n  this.length = string.length;\n\n  // Building the array\n  this.array = build(convert(string), this.length);\n}\n\n/**\n * Convenience known methods.\n */\nSuffixArray.prototype.toString = function() {\n  return this.array.join(',');\n};\n\nSuffixArray.prototype.toJSON = function() {\n  return this.array;\n};\n\nSuffixArray.prototype.inspect = function() {\n  var array = new Array(this.length);\n\n  for (var i = 0; i < this.length; i++)\n    array[i] = this.string.slice(this.array[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: SuffixArray,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  SuffixArray.prototype[Symbol.for('nodejs.util.inspect.custom')] = SuffixArray.prototype.inspect;\n\n/**\n * Generalized Suffix Array.\n *\n * @constructor\n */\nfunction GeneralizedSuffixArray(strings) {\n\n  // Properties\n  this.hasArbitrarySequence = typeof strings[0] !== 'string';\n  this.size = strings.length;\n\n  if (this.hasArbitrarySequence) {\n    this.text = [];\n\n    for (var i = 0, l = this.size; i < l; i++) {\n      this.text.push.apply(this.text, strings[i]);\n\n      if (i < l - 1)\n        this.text.push(SEPARATOR);\n    }\n  }\n  else {\n    this.text = strings.join(SEPARATOR);\n  }\n\n  this.firstLength = strings[0].length;\n  this.length = this.text.length;\n\n  // Building the array\n  this.array = build(convert(this.text), this.length);\n}\n\n/**\n * Method used to retrieve the longest common subsequence of the generalized\n * suffix array.\n *\n * @return {string|array}\n */\nGeneralizedSuffixArray.prototype.longestCommonSubsequence = function() {\n  var lcs = this.hasArbitrarySequence ? [] : '',\n      lcp,\n      i,\n      j,\n      s,\n      t;\n\n  for (i = 1; i < this.length; i++) {\n    s = this.array[i];\n    t = this.array[i - 1];\n\n    if (s < this.firstLength &&\n        t < this.firstLength)\n      continue;\n\n    if (s > this.firstLength &&\n        t > this.firstLength)\n      continue;\n\n    lcp = Math.min(this.length - s, this.length - t);\n\n    for (j = 0; j < lcp; j++) {\n      if (this.text[s + j] !== this.text[t + j]) {\n        lcp = j;\n        break;\n      }\n    }\n\n    if (lcp > lcs.length)\n      lcs = this.text.slice(s, s + lcp);\n  }\n\n  return lcs;\n};\n\n/**\n * Convenience known methods.\n */\nGeneralizedSuffixArray.prototype.toString = function() {\n  return this.array.join(',');\n};\n\nGeneralizedSuffixArray.prototype.toJSON = function() {\n  return this.array;\n};\n\nGeneralizedSuffixArray.prototype.inspect = function() {\n  var array = new Array(this.length);\n\n  for (var i = 0; i < this.length; i++)\n    array[i] = this.text.slice(this.array[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: GeneralizedSuffixArray,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  GeneralizedSuffixArray.prototype[Symbol.for('nodejs.util.inspect.custom')] = GeneralizedSuffixArray.prototype.inspect;\n\n/**\n * Exporting.\n */\nSuffixArray.GeneralizedSuffixArray = GeneralizedSuffixArray;\nmodule.exports = SuffixArray;\n"]},"metadata":{},"sourceType":"script"}