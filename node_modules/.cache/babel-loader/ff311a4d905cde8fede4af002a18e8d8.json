{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { skipToken } from '@reduxjs/toolkit/query/react';\nimport { CurrencyAmount, TradeType } from '@uniswap/sdk-core';\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice';\nimport { useMemo } from 'react';\nimport { useBlockNumber } from 'state/application/hooks';\nimport { useGetQuoteQuery } from 'state/routing/slice';\nimport { useClientSideRouter } from 'state/user/hooks';\nimport { TradeState } from './types';\nimport { computeRoutes, transformRoutesToTrade } from './utils';\n\nfunction useFreshData(data, dataBlockNumber, maxBlockAge = 10) {\n  _s();\n\n  const localBlockNumber = useBlockNumber();\n  if (!localBlockNumber) return undefined;\n\n  if (localBlockNumber - dataBlockNumber > maxBlockAge) {\n    return undefined;\n  }\n\n  return data;\n}\n/**\n * Returns query arguments for the Routing API query or undefined if the\n * query should be skipped.\n */\n\n\n_s(useFreshData, \"HxHw3/D3PwyF5+DDrDR7KuqPFl0=\", false, function () {\n  return [useBlockNumber];\n});\n\nfunction useRoutingAPIArguments({\n  tokenIn,\n  tokenOut,\n  amount,\n  tradeType\n}) {\n  _s2();\n\n  const [clientSideRouter] = useClientSideRouter();\n  return useMemo(() => !tokenIn || !tokenOut || !amount || tokenIn.equals(tokenOut) ? undefined : {\n    amount: amount.quotient.toString(),\n    tokenInAddress: tokenIn.wrapped.address,\n    tokenInChainId: tokenIn.wrapped.chainId,\n    tokenInDecimals: tokenIn.wrapped.decimals,\n    tokenInSymbol: tokenIn.wrapped.symbol,\n    tokenOutAddress: tokenOut.wrapped.address,\n    tokenOutChainId: tokenOut.wrapped.chainId,\n    tokenOutDecimals: tokenOut.wrapped.decimals,\n    tokenOutSymbol: tokenOut.wrapped.symbol,\n    useClientSideRouter: clientSideRouter,\n    type: tradeType === TradeType.EXACT_INPUT ? 'exactIn' : 'exactOut'\n  }, [amount, clientSideRouter, tokenIn, tokenOut, tradeType]);\n}\n/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\n\n\n_s2(useRoutingAPIArguments, \"M3HFijsv8srlc09rNTOq0zFo5Lc=\", false, function () {\n  return [useClientSideRouter];\n});\n\nexport function useRoutingAPITrade(tradeType, amountSpecified, otherCurrency) {\n  _s3();\n\n  var _useStablecoinAmountF;\n\n  const [currencyIn, currencyOut] = useMemo(() => tradeType === TradeType.EXACT_INPUT ? [amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency, otherCurrency] : [otherCurrency, amountSpecified === null || amountSpecified === void 0 ? void 0 : amountSpecified.currency], [amountSpecified, otherCurrency, tradeType]);\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType\n  });\n  const {\n    isLoading,\n    isError,\n    data\n  } = useGetQuoteQuery(queryArgs !== null && queryArgs !== void 0 ? queryArgs : skipToken, {\n    pollingInterval: 15000,\n    refetchOnFocus: true\n  });\n  const quoteResult = useFreshData(data, Number(data === null || data === void 0 ? void 0 : data.blockNumber) || 0);\n  const route = useMemo(() => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult), [currencyIn, currencyOut, quoteResult, tradeType]); // get USD gas cost of trade in active chains stablecoin amount\n\n  const gasUseEstimateUSD = (_useStablecoinAmountF = useStablecoinAmountFromFiatValue(quoteResult === null || quoteResult === void 0 ? void 0 : quoteResult.gasUseEstimateUSD)) !== null && _useStablecoinAmountF !== void 0 ? _useStablecoinAmountF : null;\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined\n      };\n    }\n\n    if (isLoading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined\n      };\n    }\n\n    const otherAmount = tradeType === TradeType.EXACT_INPUT ? currencyOut && quoteResult ? CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote) : undefined : currencyIn && quoteResult ? CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote) : undefined;\n\n    if (isError || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined\n      };\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD);\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade\n      };\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e);\n      return {\n        state: TradeState.INVALID,\n        trade: undefined\n      };\n    }\n  }, [currencyIn, currencyOut, isLoading, quoteResult, tradeType, isError, route, queryArgs, gasUseEstimateUSD]);\n}\n\n_s3(useRoutingAPITrade, \"ZK4DdtZx4+Cy3L2lifunUon7AC4=\", false, function () {\n  return [useRoutingAPIArguments, useGetQuoteQuery, useFreshData, useStablecoinAmountFromFiatValue];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/routing/useRoutingAPITrade.ts"],"names":["skipToken","CurrencyAmount","TradeType","useStablecoinAmountFromFiatValue","useMemo","useBlockNumber","useGetQuoteQuery","useClientSideRouter","TradeState","computeRoutes","transformRoutesToTrade","useFreshData","data","dataBlockNumber","maxBlockAge","localBlockNumber","undefined","useRoutingAPIArguments","tokenIn","tokenOut","amount","tradeType","clientSideRouter","equals","quotient","toString","tokenInAddress","wrapped","address","tokenInChainId","chainId","tokenInDecimals","decimals","tokenInSymbol","symbol","tokenOutAddress","tokenOutChainId","tokenOutDecimals","tokenOutSymbol","type","EXACT_INPUT","useRoutingAPITrade","amountSpecified","otherCurrency","currencyIn","currencyOut","currency","queryArgs","isLoading","isError","pollingInterval","refetchOnFocus","quoteResult","Number","blockNumber","route","gasUseEstimateUSD","state","INVALID","trade","LOADING","otherAmount","fromRawAmount","quote","length","NO_ROUTE_FOUND","VALID","e","console","debug"],"mappings":"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","sourcesContent":["import { skipToken } from '@reduxjs/toolkit/query/react'\nimport { Currency, CurrencyAmount, TradeType } from '@uniswap/sdk-core'\nimport { useStablecoinAmountFromFiatValue } from 'hooks/useUSDCPrice'\nimport ms from 'ms.macro'\nimport { useMemo } from 'react'\nimport { useBlockNumber } from 'state/application/hooks'\nimport { useGetQuoteQuery } from 'state/routing/slice'\nimport { useClientSideRouter } from 'state/user/hooks'\n\nimport { GetQuoteResult, InterfaceTrade, TradeState } from './types'\nimport { computeRoutes, transformRoutesToTrade } from './utils'\n\nfunction useFreshData<T>(data: T, dataBlockNumber: number, maxBlockAge = 10): T | undefined {\n  const localBlockNumber = useBlockNumber()\n\n  if (!localBlockNumber) return undefined\n  if (localBlockNumber - dataBlockNumber > maxBlockAge) {\n    return undefined\n  }\n\n  return data\n}\n\n/**\n * Returns query arguments for the Routing API query or undefined if the\n * query should be skipped.\n */\nfunction useRoutingAPIArguments({\n  tokenIn,\n  tokenOut,\n  amount,\n  tradeType,\n}: {\n  tokenIn: Currency | undefined\n  tokenOut: Currency | undefined\n  amount: CurrencyAmount<Currency> | undefined\n  tradeType: TradeType\n}) {\n  const [clientSideRouter] = useClientSideRouter()\n\n  return useMemo(\n    () =>\n      !tokenIn || !tokenOut || !amount || tokenIn.equals(tokenOut)\n        ? undefined\n        : {\n            amount: amount.quotient.toString(),\n            tokenInAddress: tokenIn.wrapped.address,\n            tokenInChainId: tokenIn.wrapped.chainId,\n            tokenInDecimals: tokenIn.wrapped.decimals,\n            tokenInSymbol: tokenIn.wrapped.symbol,\n            tokenOutAddress: tokenOut.wrapped.address,\n            tokenOutChainId: tokenOut.wrapped.chainId,\n            tokenOutDecimals: tokenOut.wrapped.decimals,\n            tokenOutSymbol: tokenOut.wrapped.symbol,\n            useClientSideRouter: clientSideRouter,\n            type: (tradeType === TradeType.EXACT_INPUT ? 'exactIn' : 'exactOut') as 'exactIn' | 'exactOut',\n          },\n    [amount, clientSideRouter, tokenIn, tokenOut, tradeType]\n  )\n}\n\n/**\n * Returns the best trade by invoking the routing api or the smart order router on the client\n * @param tradeType whether the swap is an exact in/out\n * @param amountSpecified the exact amount to swap in/out\n * @param otherCurrency the desired output/payment currency\n */\nexport function useRoutingAPITrade<TTradeType extends TradeType>(\n  tradeType: TTradeType,\n  amountSpecified?: CurrencyAmount<Currency>,\n  otherCurrency?: Currency\n): {\n  state: TradeState\n  trade: InterfaceTrade<Currency, Currency, TTradeType> | undefined\n} {\n  const [currencyIn, currencyOut]: [Currency | undefined, Currency | undefined] = useMemo(\n    () =>\n      tradeType === TradeType.EXACT_INPUT\n        ? [amountSpecified?.currency, otherCurrency]\n        : [otherCurrency, amountSpecified?.currency],\n    [amountSpecified, otherCurrency, tradeType]\n  )\n\n  const queryArgs = useRoutingAPIArguments({\n    tokenIn: currencyIn,\n    tokenOut: currencyOut,\n    amount: amountSpecified,\n    tradeType,\n  })\n\n  const { isLoading, isError, data } = useGetQuoteQuery(queryArgs ?? skipToken, {\n    pollingInterval: ms`15s`,\n    refetchOnFocus: true,\n  })\n\n  const quoteResult: GetQuoteResult | undefined = useFreshData(data, Number(data?.blockNumber) || 0)\n\n  const route = useMemo(\n    () => computeRoutes(currencyIn, currencyOut, tradeType, quoteResult),\n    [currencyIn, currencyOut, quoteResult, tradeType]\n  )\n\n  // get USD gas cost of trade in active chains stablecoin amount\n  const gasUseEstimateUSD = useStablecoinAmountFromFiatValue(quoteResult?.gasUseEstimateUSD) ?? null\n\n  return useMemo(() => {\n    if (!currencyIn || !currencyOut) {\n      return {\n        state: TradeState.INVALID,\n        trade: undefined,\n      }\n    }\n\n    if (isLoading && !quoteResult) {\n      // only on first hook render\n      return {\n        state: TradeState.LOADING,\n        trade: undefined,\n      }\n    }\n\n    const otherAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? currencyOut && quoteResult\n          ? CurrencyAmount.fromRawAmount(currencyOut, quoteResult.quote)\n          : undefined\n        : currencyIn && quoteResult\n        ? CurrencyAmount.fromRawAmount(currencyIn, quoteResult.quote)\n        : undefined\n\n    if (isError || !otherAmount || !route || route.length === 0 || !queryArgs) {\n      return {\n        state: TradeState.NO_ROUTE_FOUND,\n        trade: undefined,\n      }\n    }\n\n    try {\n      const trade = transformRoutesToTrade(route, tradeType, gasUseEstimateUSD)\n      return {\n        // always return VALID regardless of isFetching status\n        state: TradeState.VALID,\n        trade,\n      }\n    } catch (e) {\n      console.debug('transformRoutesToTrade failed: ', e)\n      return { state: TradeState.INVALID, trade: undefined }\n    }\n  }, [currencyIn, currencyOut, isLoading, quoteResult, tradeType, isError, route, queryArgs, gasUseEstimateUSD])\n}\n"]},"metadata":{},"sourceType":"module"}