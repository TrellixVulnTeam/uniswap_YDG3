{"ast":null,"code":"import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3';\nimport { V3_CORE_FACTORY_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n  /**\n   * Creates an instance of V3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  constructor(chainId, multicall2Provider, retryOptions = {\n    retries: 2,\n    minTimeout: 50,\n    maxTimeout: 500\n  }) {\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions; // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n\n    this.POOL_ADDRESS_CACHE = {};\n  }\n\n  async getPools(tokenPairs, providerConfig) {\n    const poolAddressSet = new Set();\n    const sortedTokenPairs = [];\n    const sortedPoolAddresses = [];\n\n    for (let tokenPair of tokenPairs) {\n      const [tokenA, tokenB, feeAmount] = tokenPair;\n      const {\n        poolAddress,\n        token0,\n        token1\n      } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n\n      if (poolAddressSet.has(poolAddress)) {\n        continue;\n      }\n\n      poolAddressSet.add(poolAddress);\n      sortedTokenPairs.push([token0, token1, feeAmount]);\n      sortedPoolAddresses.push(poolAddress);\n    }\n\n    log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n    const [slot0Results, liquidityResults] = await Promise.all([this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig), this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig)]);\n    log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.` : ``}`);\n    const poolAddressToPool = {};\n    const invalidPools = [];\n\n    for (let i = 0; i < sortedPoolAddresses.length; i++) {\n      const slot0Result = slot0Results[i];\n      const liquidityResult = liquidityResults[i]; // These properties tell us if a pool is valid and initialized or not.\n\n      if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) || !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) || slot0Result.result.sqrtPriceX96.eq(0)) {\n        const [token0, token1, fee] = sortedTokenPairs[i];\n        invalidPools.push([token0, token1, fee]);\n        continue;\n      }\n\n      const [token0, token1, fee] = sortedTokenPairs[i];\n      const slot0 = slot0Result.result;\n      const liquidity = liquidityResult.result[0];\n      const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n      const poolAddress = sortedPoolAddresses[i];\n      poolAddressToPool[poolAddress] = pool;\n    }\n\n    if (invalidPools.length > 0) {\n      log.info({\n        invalidPools: _.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 10000}%`)\n      }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n    }\n\n    const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n\n    log.debug({\n      poolStrs\n    }, `Found ${poolStrs.length} valid pools`);\n    return {\n      getPool: (tokenA, tokenB, feeAmount) => {\n        const {\n          poolAddress\n        } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n        return poolAddressToPool[poolAddress];\n      },\n      getPoolByAddress: address => poolAddressToPool[address],\n      getAllPools: () => Object.values(poolAddressToPool)\n    };\n  }\n\n  getPoolAddress(tokenA, tokenB, feeAmount) {\n    const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n    const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n    const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n\n    if (cachedAddress) {\n      return {\n        poolAddress: cachedAddress,\n        token0,\n        token1\n      };\n    }\n\n    const poolAddress = computePoolAddress({\n      factoryAddress: V3_CORE_FACTORY_ADDRESS,\n      tokenA: token0,\n      tokenB: token1,\n      fee: feeAmount\n    });\n    this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n    return {\n      poolAddress,\n      token0,\n      token1\n    };\n  }\n\n  async getPoolsData(poolAddresses, functionName, providerConfig) {\n    const {\n      results,\n      blockNumber\n    } = await retry(async () => {\n      return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n        addresses: poolAddresses,\n        contractInterface: IUniswapV3PoolState__factory.createInterface(),\n        functionName: functionName,\n        providerConfig\n      });\n    }, this.retryOptions);\n    log.debug(`Pool data fetched as of block ${blockNumber}`);\n    return results;\n  }\n\n}","map":{"version":3,"sources":["../../../../../src/providers/v3/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3';\nimport { V3_CORE_FACTORY_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n    /**\n     * Creates an instance of V3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (let tokenPair of tokenPairs) {\n            const [tokenA, tokenB, feeAmount] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1, feeAmount]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const [slot0Results, liquidityResults] = await Promise.all([\n            this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig),\n            this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig),\n        ]);\n        log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const slot0Result = slot0Results[i];\n            const liquidityResult = liquidityResults[i];\n            // These properties tell us if a pool is valid and initialized or not.\n            if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) ||\n                !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) ||\n                slot0Result.result.sqrtPriceX96.eq(0)) {\n                const [token0, token1, fee] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1, fee]);\n                continue;\n            }\n            const [token0, token1, fee] = sortedTokenPairs[i];\n            const slot0 = slot0Result.result;\n            const liquidity = liquidityResult.result[0];\n            const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 10000}%`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = computePoolAddress({\n            factoryAddress: V3_CORE_FACTORY_ADDRESS,\n            tokenA: token0,\n            tokenB: token1,\n            fee: feeAmount,\n        });\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjMvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsa0JBQWtCLEVBQWEsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEUsT0FBTyxFQUF5QixPQUFPLElBQUksS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXRFLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBOERqRCxNQUFNLE9BQU8sY0FBYztJQUt6Qjs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsa0JBQXNDLEVBQ3RDLGVBQW1DO1FBQzNDLE9BQU8sRUFBRSxDQUFDO1FBQ1YsVUFBVSxFQUFFLEVBQUU7UUFDZCxVQUFVLEVBQUUsR0FBRztLQUNoQjtRQU5TLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxpQkFBWSxHQUFaLFlBQVksQ0FJckI7UUFqQkgseUVBQXlFO1FBQ3pFLGtEQUFrRDtRQUMxQyx1QkFBa0IsR0FBOEIsRUFBRSxDQUFDO0lBZ0J4RCxDQUFDO0lBRUcsS0FBSyxDQUFDLFFBQVEsQ0FDbkIsVUFBdUMsRUFDdkMsY0FBK0I7UUFFL0IsTUFBTSxjQUFjLEdBQWdCLElBQUksR0FBRyxFQUFVLENBQUM7UUFDdEQsTUFBTSxnQkFBZ0IsR0FBcUMsRUFBRSxDQUFDO1FBQzlELE1BQU0sbUJBQW1CLEdBQWEsRUFBRSxD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"]},"metadata":{},"sourceType":"module"}