{"ast":null,"code":"/**\n * Mnemonist HashedArrayTree\n * ==========================\n *\n * Abstract implementation of a hashed array tree representing arrays growing\n * dynamically.\n */\n\n/**\n * Defaults.\n */\nvar DEFAULT_BLOCK_SIZE = 1024;\n/**\n * Helpers.\n */\n\nfunction powerOfTwo(x) {\n  return (x & x - 1) === 0;\n}\n/**\n * HashedArrayTree.\n *\n * @constructor\n * @param {function}      ArrayClass           - An array constructor.\n * @param {number|object} initialCapacityOrOptions - Self-explanatory.\n */\n\n\nfunction HashedArrayTree(ArrayClass, initialCapacityOrOptions) {\n  if (arguments.length < 1) throw new Error('mnemonist/hashed-array-tree: expecting at least a byte array constructor.');\n  var initialCapacity = initialCapacityOrOptions || 0,\n      blockSize = DEFAULT_BLOCK_SIZE,\n      initialLength = 0;\n\n  if (typeof initialCapacityOrOptions === 'object') {\n    initialCapacity = initialCapacityOrOptions.initialCapacity || 0;\n    initialLength = initialCapacityOrOptions.initialLength || 0;\n    blockSize = initialCapacityOrOptions.blockSize || DEFAULT_BLOCK_SIZE;\n  }\n\n  if (!blockSize || !powerOfTwo(blockSize)) throw new Error('mnemonist/hashed-array-tree: block size should be a power of two.');\n  var capacity = Math.max(initialLength, initialCapacity),\n      initialBlocks = Math.ceil(capacity / blockSize);\n  this.ArrayClass = ArrayClass;\n  this.length = initialLength;\n  this.capacity = initialBlocks * blockSize;\n  this.blockSize = blockSize;\n  this.offsetMask = blockSize - 1;\n  this.blockMask = Math.log2(blockSize); // Allocating initial blocks\n\n  this.blocks = new Array(initialBlocks);\n\n  for (var i = 0; i < initialBlocks; i++) {\n    this.blocks[i] = new this.ArrayClass(this.blockSize);\n  }\n}\n/**\n * Method used to set a value.\n *\n * @param  {number} index - Index to edit.\n * @param  {any}    value - Value.\n * @return {HashedArrayTree}\n */\n\n\nHashedArrayTree.prototype.set = function (index, value) {\n  // Out of bounds?\n  if (this.length < index) throw new Error('HashedArrayTree(' + this.ArrayClass.name + ').set: index out of bounds.');\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n  this.blocks[block][i] = value;\n  return this;\n};\n/**\n * Method used to get a value.\n *\n * @param  {number} index - Index to retrieve.\n * @return {any}\n */\n\n\nHashedArrayTree.prototype.get = function (index) {\n  if (this.length < index) return;\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n  return this.blocks[block][i];\n};\n/**\n * Method used to grow the array.\n *\n * @param  {number}          capacity - Optional capacity to accomodate.\n * @return {HashedArrayTree}\n */\n\n\nHashedArrayTree.prototype.grow = function (capacity) {\n  if (typeof capacity !== 'number') capacity = this.capacity + this.blockSize;\n  if (this.capacity >= capacity) return this;\n\n  while (this.capacity < capacity) {\n    this.blocks.push(new this.ArrayClass(this.blockSize));\n    this.capacity += this.blockSize;\n  }\n\n  return this;\n};\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {HashedArrayTree}\n */\n\n\nHashedArrayTree.prototype.resize = function (length) {\n  if (length === this.length) return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.grow(length);\n  return this;\n};\n/**\n * Method used to push a value into the array.\n *\n * @param  {any}    value - Value to push.\n * @return {number}       - Length of the array.\n */\n\n\nHashedArrayTree.prototype.push = function (value) {\n  if (this.capacity === this.length) this.grow();\n  var index = this.length;\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n  this.blocks[block][i] = value;\n  return ++this.length;\n};\n/**\n * Method used to pop the last value of the array.\n *\n * @return {number} - The popped value.\n */\n\n\nHashedArrayTree.prototype.pop = function () {\n  if (this.length === 0) return;\n  var lastBlock = this.blocks[this.blocks.length - 1];\n  var i = --this.length & this.offsetMask;\n  return lastBlock[i];\n};\n/**\n * Convenience known methods.\n */\n\n\nHashedArrayTree.prototype.inspect = function () {\n  var proxy = new this.ArrayClass(this.length),\n      block;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    block = i >> this.blockMask;\n    proxy[i] = this.blocks[block][i & this.offsetMask];\n  }\n\n  proxy.type = this.ArrayClass.name;\n  proxy.items = this.length;\n  proxy.capacity = this.capacity;\n  proxy.blockSize = this.blockSize; // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: HashedArrayTree,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') HashedArrayTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = HashedArrayTree.prototype.inspect;\n/**\n * Exporting.\n */\n\nmodule.exports = HashedArrayTree;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/hashed-array-tree.js"],"names":["DEFAULT_BLOCK_SIZE","powerOfTwo","x","HashedArrayTree","ArrayClass","initialCapacityOrOptions","arguments","length","Error","initialCapacity","blockSize","initialLength","capacity","Math","max","initialBlocks","ceil","offsetMask","blockMask","log2","blocks","Array","i","prototype","set","index","value","name","block","get","grow","push","resize","pop","lastBlock","inspect","proxy","l","type","items","Object","defineProperty","enumerable","Symbol","for","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist HashedArrayTree\n * ==========================\n *\n * Abstract implementation of a hashed array tree representing arrays growing\n * dynamically.\n */\n\n/**\n * Defaults.\n */\nvar DEFAULT_BLOCK_SIZE = 1024;\n\n/**\n * Helpers.\n */\nfunction powerOfTwo(x) {\n  return (x & (x - 1)) === 0;\n}\n\n/**\n * HashedArrayTree.\n *\n * @constructor\n * @param {function}      ArrayClass           - An array constructor.\n * @param {number|object} initialCapacityOrOptions - Self-explanatory.\n */\nfunction HashedArrayTree(ArrayClass, initialCapacityOrOptions) {\n  if (arguments.length < 1)\n    throw new Error('mnemonist/hashed-array-tree: expecting at least a byte array constructor.');\n\n  var initialCapacity = initialCapacityOrOptions || 0,\n      blockSize = DEFAULT_BLOCK_SIZE,\n      initialLength = 0;\n\n  if (typeof initialCapacityOrOptions === 'object') {\n    initialCapacity = initialCapacityOrOptions.initialCapacity || 0;\n    initialLength = initialCapacityOrOptions.initialLength || 0;\n    blockSize = initialCapacityOrOptions.blockSize || DEFAULT_BLOCK_SIZE;\n  }\n\n  if (!blockSize || !powerOfTwo(blockSize))\n    throw new Error('mnemonist/hashed-array-tree: block size should be a power of two.');\n\n  var capacity = Math.max(initialLength, initialCapacity),\n      initialBlocks = Math.ceil(capacity / blockSize);\n\n  this.ArrayClass = ArrayClass;\n  this.length = initialLength;\n  this.capacity = initialBlocks * blockSize;\n  this.blockSize = blockSize;\n  this.offsetMask = blockSize - 1;\n  this.blockMask = Math.log2(blockSize);\n\n  // Allocating initial blocks\n  this.blocks = new Array(initialBlocks);\n\n  for (var i = 0; i < initialBlocks; i++)\n    this.blocks[i] = new this.ArrayClass(this.blockSize);\n}\n\n/**\n * Method used to set a value.\n *\n * @param  {number} index - Index to edit.\n * @param  {any}    value - Value.\n * @return {HashedArrayTree}\n */\nHashedArrayTree.prototype.set = function(index, value) {\n\n  // Out of bounds?\n  if (this.length < index)\n    throw new Error('HashedArrayTree(' + this.ArrayClass.name + ').set: index out of bounds.');\n\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n\n  this.blocks[block][i] = value;\n\n  return this;\n};\n\n/**\n * Method used to get a value.\n *\n * @param  {number} index - Index to retrieve.\n * @return {any}\n */\nHashedArrayTree.prototype.get = function(index) {\n  if (this.length < index)\n    return;\n\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n\n  return this.blocks[block][i];\n};\n\n/**\n * Method used to grow the array.\n *\n * @param  {number}          capacity - Optional capacity to accomodate.\n * @return {HashedArrayTree}\n */\nHashedArrayTree.prototype.grow = function(capacity) {\n  if (typeof capacity !== 'number')\n    capacity = this.capacity + this.blockSize;\n\n  if (this.capacity >= capacity)\n    return this;\n\n  while (this.capacity < capacity) {\n    this.blocks.push(new this.ArrayClass(this.blockSize));\n    this.capacity += this.blockSize;\n  }\n\n  return this;\n};\n\n/**\n * Method used to resize the array. Won't deallocate.\n *\n * @param  {number}       length - Target length.\n * @return {HashedArrayTree}\n */\nHashedArrayTree.prototype.resize = function(length) {\n  if (length === this.length)\n    return this;\n\n  if (length < this.length) {\n    this.length = length;\n    return this;\n  }\n\n  this.length = length;\n  this.grow(length);\n\n  return this;\n};\n\n/**\n * Method used to push a value into the array.\n *\n * @param  {any}    value - Value to push.\n * @return {number}       - Length of the array.\n */\nHashedArrayTree.prototype.push = function(value) {\n  if (this.capacity === this.length)\n    this.grow();\n\n  var index = this.length;\n\n  var block = index >> this.blockMask,\n      i = index & this.offsetMask;\n\n  this.blocks[block][i] = value;\n\n  return ++this.length;\n};\n\n/**\n * Method used to pop the last value of the array.\n *\n * @return {number} - The popped value.\n */\nHashedArrayTree.prototype.pop = function() {\n  if (this.length === 0)\n    return;\n\n  var lastBlock = this.blocks[this.blocks.length - 1];\n\n  var i = (--this.length) & this.offsetMask;\n\n  return lastBlock[i];\n};\n\n/**\n * Convenience known methods.\n */\nHashedArrayTree.prototype.inspect = function() {\n  var proxy = new this.ArrayClass(this.length),\n      block;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    block = i >> this.blockMask;\n    proxy[i] = this.blocks[block][i & this.offsetMask];\n  }\n\n  proxy.type = this.ArrayClass.name;\n  proxy.items = this.length;\n  proxy.capacity = this.capacity;\n  proxy.blockSize = this.blockSize;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: HashedArrayTree,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  HashedArrayTree.prototype[Symbol.for('nodejs.util.inspect.custom')] = HashedArrayTree.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = HashedArrayTree;\n"]},"metadata":{},"sourceType":"script"}