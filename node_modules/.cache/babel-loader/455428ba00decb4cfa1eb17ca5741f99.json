{"ast":null,"code":"/* eslint no-loop-func: 0 */\n\n/**\n * Mnemonist SymSpell\n * ===================\n *\n * JavaScript implementation of the Symmetric Delete Spelling dictionary to\n * efficiently index & query expression based on edit distance.\n * Note that the current implementation target the v3.0 of the algorithm.\n *\n * [Reference]:\n * http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/\n * https://github.com/wolfgarbe/symspell\n *\n * [Author]:\n * Wolf Garbe\n */\nvar forEach = require('obliterator/foreach');\n/**\n * Constants.\n */\n\n\nvar DEFAULT_MAX_DISTANCE = 2,\n    DEFAULT_VERBOSITY = 2;\nvar VERBOSITY = new Set([// Returns only the top suggestion\n0, // Returns suggestions with the smallest edit distance\n1, // Returns every suggestion (no early termination)\n2]);\nvar VERBOSITY_EXPLANATIONS = {\n  0: 'Returns only the top suggestion',\n  1: 'Returns suggestions with the smallest edit distance',\n  2: 'Returns every suggestion (no early termination)'\n};\n/**\n * Functions.\n */\n\n/**\n * Function creating a dictionary item.\n *\n * @param  {number} [value] - An optional suggestion.\n * @return {object}         - The created item.\n */\n\nfunction createDictionaryItem(value) {\n  var suggestions = new Set();\n  if (typeof value === 'number') suggestions.add(value);\n  return {\n    suggestions,\n    count: 0\n  };\n}\n/**\n * Function creating a suggestion item.\n *\n * @return {object} - The created item.\n */\n\n\nfunction createSuggestionItem(term, distance, count) {\n  return {\n    term: term || '',\n    distance: distance || 0,\n    count: count || 0\n  };\n}\n/**\n * Simplified edit function.\n *\n * @param {string} word      - Target word.\n * @param {number} distance  - Distance.\n * @param {number} max       - Max distance.\n * @param {Set}    [deletes] - Set mutated to store deletes.\n */\n\n\nfunction edits(word, distance, max, deletes) {\n  deletes = deletes || new Set();\n  distance++;\n  var deletedItem,\n      l = word.length,\n      i;\n\n  if (l > 1) {\n    for (i = 0; i < l; i++) {\n      deletedItem = word.substring(0, i) + word.substring(i + 1);\n\n      if (!deletes.has(deletedItem)) {\n        deletes.add(deletedItem);\n        if (distance < max) edits(deletedItem, distance, max, deletes);\n      }\n    }\n  }\n\n  return deletes;\n}\n/**\n * Function used to conditionally add suggestions.\n *\n * @param {array}  words       - Words list.\n * @param {number} verbosity   - Verbosity level.\n * @param {object} item        - The target item.\n * @param {string} suggestion  - The target suggestion.\n * @param {number} int         - Integer key of the word.\n * @param {object} deletedItem - Considered deleted item.\n * @param {SymSpell}\n */\n\n\nfunction addLowestDistance(words, verbosity, item, suggestion, int, deletedItem) {\n  var first = item.suggestions.values().next().value;\n\n  if (verbosity < 2 && item.suggestions.size > 0 && words[first].length - deletedItem.length > suggestion.length - deletedItem.length) {\n    item.suggestions = new Set();\n    item.count = 0;\n  }\n\n  if (verbosity === 2 || !item.suggestions.size || words[first].length - deletedItem.length >= suggestion.length - deletedItem.length) {\n    item.suggestions.add(int);\n  }\n}\n/**\n * Custom Damerau-Levenshtein used by the algorithm.\n *\n * @param  {string} source - First string.\n * @param  {string} target - Second string.\n * @return {number}        - The distance.\n */\n\n\nfunction damerauLevenshtein(source, target) {\n  var m = source.length,\n      n = target.length,\n      H = [[]],\n      INF = m + n,\n      sd = new Map(),\n      i,\n      l,\n      j;\n  H[0][0] = INF;\n\n  for (i = 0; i <= m; i++) {\n    if (!H[i + 1]) H[i + 1] = [];\n    H[i + 1][1] = i;\n    H[i + 1][0] = INF;\n  }\n\n  for (j = 0; j <= n; j++) {\n    H[1][j + 1] = j;\n    H[0][j + 1] = INF;\n  }\n\n  var st = source + target,\n      letter;\n\n  for (i = 0, l = st.length; i < l; i++) {\n    letter = st[i];\n    if (!sd.has(letter)) sd.set(letter, 0);\n  } // Iterating\n\n\n  for (i = 1; i <= m; i++) {\n    var DB = 0;\n\n    for (j = 1; j <= n; j++) {\n      var i1 = sd.get(target[j - 1]),\n          j1 = DB;\n\n      if (source[i - 1] === target[j - 1]) {\n        H[i + 1][j + 1] = H[i][j];\n        DB = j;\n      } else {\n        H[i + 1][j + 1] = Math.min(H[i][j], H[i + 1][j], H[i][j + 1]) + 1;\n      }\n\n      H[i + 1][j + 1] = Math.min(H[i + 1][j + 1], H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));\n    }\n\n    sd.set(source[i - 1], i);\n  }\n\n  return H[m + 1][n + 1];\n}\n/**\n * Lookup function.\n *\n * @param  {object} dictionary  - A SymSpell dictionary.\n * @param  {array}  words       - Unique words list.\n * @param  {number} verbosity   - Verbosity level.\n * @param  {number} maxDistance - Maximum distance.\n * @param  {number} maxLength   - Maximum word length in the dictionary.\n * @param  {string} input       - Input string.\n * @return {array}              - The list of suggestions.\n */\n\n\nfunction lookup(dictionary, words, verbosity, maxDistance, maxLength, input) {\n  var length = input.length;\n  if (length - maxDistance > maxLength) return [];\n  var candidates = [input],\n      candidateSet = new Set(),\n      suggestionSet = new Set();\n  var suggestions = [],\n      candidate,\n      item; // Exhausting every candidates\n\n  while (candidates.length > 0) {\n    candidate = candidates.shift(); // Early termination\n\n    if (verbosity < 2 && suggestions.length > 0 && length - candidate.length > suggestions[0].distance) break;\n    item = dictionary[candidate];\n\n    if (item !== undefined) {\n      if (typeof item === 'number') item = createDictionaryItem(item);\n\n      if (item.count > 0 && !suggestionSet.has(candidate)) {\n        suggestionSet.add(candidate);\n        var suggestItem = createSuggestionItem(candidate, length - candidate.length, item.count);\n        suggestions.push(suggestItem); // Another early termination\n\n        if (verbosity < 2 && length - candidate.length === 0) break;\n      } // Iterating over the item's suggestions\n\n\n      item.suggestions.forEach(index => {\n        var suggestion = words[index]; // Do we already have this suggestion?\n\n        if (suggestionSet.has(suggestion)) return;\n        suggestionSet.add(suggestion); // Computing distance between candidate & suggestion\n\n        var distance = 0;\n\n        if (input !== suggestion) {\n          if (suggestion.length === candidate.length) {\n            distance = length - candidate.length;\n          } else if (length === candidate.length) {\n            distance = suggestion.length - candidate.length;\n          } else {\n            var ii = 0,\n                jj = 0;\n            var l = suggestion.length;\n\n            while (ii < l && ii < length && suggestion[ii] === input[ii]) {\n              ii++;\n            }\n\n            while (jj < l - ii && jj < length && suggestion[l - jj - 1] === input[length - jj - 1]) {\n              jj++;\n            }\n\n            if (ii > 0 || jj > 0) {\n              distance = damerauLevenshtein(suggestion.substr(ii, l - ii - jj), input.substr(ii, length - ii - jj));\n            } else {\n              distance = damerauLevenshtein(suggestion, input);\n            }\n          }\n        } // Removing suggestions of higher distance\n\n\n        if (verbosity < 2 && suggestions.length > 0 && suggestions[0].distance > distance) {\n          suggestions = [];\n        }\n\n        if (verbosity < 2 && suggestions.length > 0 && distance > suggestions[0].distance) {\n          return;\n        }\n\n        if (distance <= maxDistance) {\n          var target = dictionary[suggestion];\n\n          if (target !== undefined) {\n            suggestions.push(createSuggestionItem(suggestion, distance, target.count));\n          }\n        }\n      });\n    } // Adding edits\n\n\n    if (length - candidate.length < maxDistance) {\n      if (verbosity < 2 && suggestions.length > 0 && length - candidate.length >= suggestions[0].distance) continue;\n\n      for (var i = 0, l = candidate.length; i < l; i++) {\n        var deletedItem = candidate.substring(0, i) + candidate.substring(i + 1);\n\n        if (!candidateSet.has(deletedItem)) {\n          candidateSet.add(deletedItem);\n          candidates.push(deletedItem);\n        }\n      }\n    }\n  }\n\n  if (verbosity === 0) return suggestions.slice(0, 1);\n  return suggestions;\n}\n/**\n * SymSpell.\n *\n * @constructor\n */\n\n\nfunction SymSpell(options) {\n  options = options || {};\n  this.clear(); // Properties\n\n  this.maxDistance = typeof options.maxDistance === 'number' ? options.maxDistance : DEFAULT_MAX_DISTANCE;\n  this.verbosity = typeof options.verbosity === 'number' ? options.verbosity : DEFAULT_VERBOSITY; // Sanity checks\n\n  if (typeof this.maxDistance !== 'number' || this.maxDistance <= 0) throw Error('mnemonist/SymSpell.constructor: invalid `maxDistance` option. Should be a integer greater than 0.');\n  if (!VERBOSITY.has(this.verbosity)) throw Error('mnemonist/SymSpell.constructor: invalid `verbosity` option. Should be either 0, 1 or 2.');\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nSymSpell.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n  this.dictionary = Object.create(null);\n  this.maxLength = 0;\n  this.words = [];\n};\n/**\n * Method used to add a word to the index.\n *\n * @param {string} word - Word to add.\n * @param {SymSpell}\n */\n\n\nSymSpell.prototype.add = function (word) {\n  var item = this.dictionary[word];\n\n  if (item !== undefined) {\n    if (typeof item === 'number') {\n      item = createDictionaryItem(item);\n      this.dictionary[word] = item;\n    }\n\n    item.count++;\n  } else {\n    item = createDictionaryItem();\n    item.count++;\n    this.dictionary[word] = item;\n    if (word.length > this.maxLength) this.maxLength = word.length;\n  }\n\n  if (item.count === 1) {\n    var number = this.words.length;\n    this.words.push(word);\n    var deletes = edits(word, 0, this.maxDistance);\n    deletes.forEach(deletedItem => {\n      var target = this.dictionary[deletedItem];\n\n      if (target !== undefined) {\n        if (typeof target === 'number') {\n          target = createDictionaryItem(target);\n          this.dictionary[deletedItem] = target;\n        }\n\n        if (!target.suggestions.has(number)) {\n          addLowestDistance(this.words, this.verbosity, target, word, number, deletedItem);\n        }\n      } else {\n        this.dictionary[deletedItem] = number;\n      }\n    });\n  }\n\n  this.size++;\n  return this;\n};\n/**\n * Method used to search the index.\n *\n * @param  {string} input - Input query.\n * @return {array}        - The found suggestions.\n */\n\n\nSymSpell.prototype.search = function (input) {\n  return lookup(this.dictionary, this.words, this.verbosity, this.maxDistance, this.maxLength, input);\n};\n/**\n * Convenience known methods.\n */\n\n\nSymSpell.prototype.inspect = function () {\n  var array = [];\n  array.size = this.size;\n  array.maxDistance = this.maxDistance;\n  array.verbosity = this.verbosity;\n  array.behavior = VERBOSITY_EXPLANATIONS[this.verbosity];\n\n  for (var k in this.dictionary) {\n    if (typeof this.dictionary[k] === 'object' && this.dictionary[k].count) array.push([k, this.dictionary[k].count]);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(array, 'constructor', {\n    value: SymSpell,\n    enumerable: false\n  });\n  return array;\n};\n\nif (typeof Symbol !== 'undefined') SymSpell.prototype[Symbol.for('nodejs.util.inspect.custom')] = SymSpell.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {SymSpell}\n */\n\nSymSpell.from = function (iterable, options) {\n  var index = new SymSpell(options);\n  forEach(iterable, function (value) {\n    index.add(value);\n  });\n  return index;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = SymSpell;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/symspell.js"],"names":["forEach","require","DEFAULT_MAX_DISTANCE","DEFAULT_VERBOSITY","VERBOSITY","Set","VERBOSITY_EXPLANATIONS","createDictionaryItem","value","suggestions","add","count","createSuggestionItem","term","distance","edits","word","max","deletes","deletedItem","l","length","i","substring","has","addLowestDistance","words","verbosity","item","suggestion","int","first","values","next","size","damerauLevenshtein","source","target","m","n","H","INF","sd","Map","j","st","letter","set","DB","i1","get","j1","Math","min","lookup","dictionary","maxDistance","maxLength","input","candidates","candidateSet","suggestionSet","candidate","shift","undefined","suggestItem","push","index","ii","jj","substr","slice","SymSpell","options","clear","Error","prototype","Object","create","number","search","inspect","array","behavior","k","defineProperty","enumerable","Symbol","for","from","iterable","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-loop-func: 0 */\n/**\n * Mnemonist SymSpell\n * ===================\n *\n * JavaScript implementation of the Symmetric Delete Spelling dictionary to\n * efficiently index & query expression based on edit distance.\n * Note that the current implementation target the v3.0 of the algorithm.\n *\n * [Reference]:\n * http://blog.faroo.com/2012/06/07/improved-edit-distance-based-spelling-correction/\n * https://github.com/wolfgarbe/symspell\n *\n * [Author]:\n * Wolf Garbe\n */\nvar forEach = require('obliterator/foreach');\n\n/**\n * Constants.\n */\nvar DEFAULT_MAX_DISTANCE = 2,\n    DEFAULT_VERBOSITY = 2;\n\nvar VERBOSITY = new Set([\n  // Returns only the top suggestion\n  0,\n  // Returns suggestions with the smallest edit distance\n  1,\n  // Returns every suggestion (no early termination)\n  2\n]);\n\nvar VERBOSITY_EXPLANATIONS = {\n  0: 'Returns only the top suggestion',\n  1: 'Returns suggestions with the smallest edit distance',\n  2: 'Returns every suggestion (no early termination)'\n};\n\n/**\n * Functions.\n */\n\n/**\n * Function creating a dictionary item.\n *\n * @param  {number} [value] - An optional suggestion.\n * @return {object}         - The created item.\n */\nfunction createDictionaryItem(value) {\n  var suggestions = new Set();\n\n  if (typeof value === 'number')\n    suggestions.add(value);\n\n  return {\n    suggestions,\n    count: 0\n  };\n}\n\n/**\n * Function creating a suggestion item.\n *\n * @return {object} - The created item.\n */\nfunction createSuggestionItem(term, distance, count) {\n  return {\n    term: term || '',\n    distance: distance || 0,\n    count: count || 0\n  };\n}\n\n/**\n * Simplified edit function.\n *\n * @param {string} word      - Target word.\n * @param {number} distance  - Distance.\n * @param {number} max       - Max distance.\n * @param {Set}    [deletes] - Set mutated to store deletes.\n */\nfunction edits(word, distance, max, deletes) {\n  deletes = deletes || new Set();\n  distance++;\n\n  var deletedItem,\n      l = word.length,\n      i;\n\n  if (l > 1) {\n    for (i = 0; i < l; i++) {\n      deletedItem = word.substring(0, i) + word.substring(i + 1);\n\n      if (!deletes.has(deletedItem)) {\n        deletes.add(deletedItem);\n\n        if (distance < max)\n          edits(deletedItem, distance, max, deletes);\n      }\n    }\n  }\n\n  return deletes;\n}\n\n/**\n * Function used to conditionally add suggestions.\n *\n * @param {array}  words       - Words list.\n * @param {number} verbosity   - Verbosity level.\n * @param {object} item        - The target item.\n * @param {string} suggestion  - The target suggestion.\n * @param {number} int         - Integer key of the word.\n * @param {object} deletedItem - Considered deleted item.\n * @param {SymSpell}\n */\nfunction addLowestDistance(words, verbosity, item, suggestion, int, deletedItem) {\n  var first = item.suggestions.values().next().value;\n\n  if (verbosity < 2 &&\n      item.suggestions.size > 0 &&\n      words[first].length - deletedItem.length > suggestion.length - deletedItem.length) {\n    item.suggestions = new Set();\n    item.count = 0;\n  }\n\n  if (verbosity === 2 ||\n      !item.suggestions.size ||\n      words[first].length - deletedItem.length >= suggestion.length - deletedItem.length) {\n    item.suggestions.add(int);\n  }\n}\n\n/**\n * Custom Damerau-Levenshtein used by the algorithm.\n *\n * @param  {string} source - First string.\n * @param  {string} target - Second string.\n * @return {number}        - The distance.\n */\nfunction damerauLevenshtein(source, target) {\n  var m = source.length,\n      n = target.length,\n      H = [[]],\n      INF = m + n,\n      sd = new Map(),\n      i,\n      l,\n      j;\n\n  H[0][0] = INF;\n\n  for (i = 0; i <= m; i++) {\n    if (!H[i + 1])\n      H[i + 1] = [];\n    H[i + 1][1] = i;\n    H[i + 1][0] = INF;\n  }\n\n  for (j = 0; j <= n; j++) {\n    H[1][j + 1] = j;\n    H[0][j + 1] = INF;\n  }\n\n  var st = source + target,\n      letter;\n\n  for (i = 0, l = st.length; i < l; i++) {\n    letter = st[i];\n\n    if (!sd.has(letter))\n      sd.set(letter, 0);\n  }\n\n  // Iterating\n  for (i = 1; i <= m; i++) {\n    var DB = 0;\n\n    for (j = 1; j <= n; j++) {\n      var i1 = sd.get(target[j - 1]),\n          j1 = DB;\n\n      if (source[i - 1] === target[j - 1]) {\n        H[i + 1][j + 1] = H[i][j];\n        DB = j;\n      }\n      else {\n        H[i + 1][j + 1] = Math.min(\n          H[i][j],\n          H[i + 1][j],\n          H[i][j + 1]\n        ) + 1;\n      }\n\n      H[i + 1][j + 1] = Math.min(\n        H[i + 1][j + 1],\n        H[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1)\n      );\n    }\n\n    sd.set(source[i - 1], i);\n  }\n\n  return H[m + 1][n + 1];\n}\n\n/**\n * Lookup function.\n *\n * @param  {object} dictionary  - A SymSpell dictionary.\n * @param  {array}  words       - Unique words list.\n * @param  {number} verbosity   - Verbosity level.\n * @param  {number} maxDistance - Maximum distance.\n * @param  {number} maxLength   - Maximum word length in the dictionary.\n * @param  {string} input       - Input string.\n * @return {array}              - The list of suggestions.\n */\nfunction lookup(dictionary, words, verbosity, maxDistance, maxLength, input) {\n  var length = input.length;\n\n  if (length - maxDistance > maxLength)\n    return [];\n\n  var candidates = [input],\n      candidateSet = new Set(),\n      suggestionSet = new Set();\n\n  var suggestions = [],\n      candidate,\n      item;\n\n  // Exhausting every candidates\n  while (candidates.length > 0) {\n    candidate = candidates.shift();\n\n    // Early termination\n    if (\n      verbosity < 2 &&\n      suggestions.length > 0 &&\n      length - candidate.length > suggestions[0].distance\n    )\n      break;\n\n    item = dictionary[candidate];\n\n    if (item !== undefined) {\n      if (typeof item === 'number')\n        item = createDictionaryItem(item);\n\n      if (item.count > 0 && !suggestionSet.has(candidate)) {\n        suggestionSet.add(candidate);\n\n        var suggestItem = createSuggestionItem(\n          candidate,\n          length - candidate.length,\n          item.count\n        );\n\n        suggestions.push(suggestItem);\n\n        // Another early termination\n        if (verbosity < 2 && length - candidate.length === 0)\n          break;\n      }\n\n      // Iterating over the item's suggestions\n      item.suggestions.forEach(index => {\n        var suggestion = words[index];\n\n        // Do we already have this suggestion?\n        if (suggestionSet.has(suggestion))\n          return;\n\n        suggestionSet.add(suggestion);\n\n        // Computing distance between candidate & suggestion\n        var distance = 0;\n\n        if (input !== suggestion) {\n          if (suggestion.length === candidate.length) {\n            distance = length - candidate.length;\n          }\n          else if (length === candidate.length) {\n            distance = suggestion.length - candidate.length;\n          }\n          else {\n            var ii = 0,\n                jj = 0;\n\n            var l = suggestion.length;\n\n            while (\n              ii < l &&\n              ii < length &&\n              suggestion[ii] === input[ii]\n            ) {\n              ii++;\n            }\n\n            while (\n              jj < l - ii &&\n              jj < length &&\n              suggestion[l - jj - 1] === input[length - jj - 1]\n            ) {\n              jj++;\n            }\n\n            if (ii > 0 || jj > 0) {\n              distance = damerauLevenshtein(\n                suggestion.substr(ii, l - ii - jj),\n                input.substr(ii, length - ii - jj)\n              );\n            }\n            else {\n              distance = damerauLevenshtein(suggestion, input);\n            }\n          }\n        }\n\n        // Removing suggestions of higher distance\n        if (verbosity < 2 &&\n            suggestions.length > 0 &&\n            suggestions[0].distance > distance) {\n          suggestions = [];\n        }\n\n        if (verbosity < 2 &&\n            suggestions.length > 0 &&\n            distance > suggestions[0].distance) {\n          return;\n        }\n\n        if (distance <= maxDistance) {\n          var target = dictionary[suggestion];\n\n          if (target !== undefined) {\n            suggestions.push(createSuggestionItem(\n              suggestion,\n              distance,\n              target.count\n            ));\n          }\n        }\n      });\n    }\n\n    // Adding edits\n    if (length - candidate.length < maxDistance) {\n\n      if (verbosity < 2 &&\n          suggestions.length > 0 &&\n          length - candidate.length >= suggestions[0].distance)\n        continue;\n\n      for (var i = 0, l = candidate.length; i < l; i++) {\n        var deletedItem = (\n          candidate.substring(0, i) +\n          candidate.substring(i + 1)\n        );\n\n        if (!candidateSet.has(deletedItem)) {\n          candidateSet.add(deletedItem);\n          candidates.push(deletedItem);\n        }\n      }\n    }\n  }\n\n  if (verbosity === 0)\n    return suggestions.slice(0, 1);\n\n  return suggestions;\n}\n\n/**\n * SymSpell.\n *\n * @constructor\n */\nfunction SymSpell(options) {\n  options = options || {};\n\n  this.clear();\n\n  // Properties\n  this.maxDistance = typeof options.maxDistance === 'number' ?\n    options.maxDistance :\n    DEFAULT_MAX_DISTANCE;\n  this.verbosity = typeof options.verbosity === 'number' ?\n    options.verbosity :\n    DEFAULT_VERBOSITY;\n\n  // Sanity checks\n  if (typeof this.maxDistance !== 'number' || this.maxDistance <= 0)\n    throw Error('mnemonist/SymSpell.constructor: invalid `maxDistance` option. Should be a integer greater than 0.');\n\n  if (!VERBOSITY.has(this.verbosity))\n    throw Error('mnemonist/SymSpell.constructor: invalid `verbosity` option. Should be either 0, 1 or 2.');\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSymSpell.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n  this.dictionary = Object.create(null);\n  this.maxLength = 0;\n  this.words = [];\n};\n\n/**\n * Method used to add a word to the index.\n *\n * @param {string} word - Word to add.\n * @param {SymSpell}\n */\nSymSpell.prototype.add = function(word) {\n  var item = this.dictionary[word];\n\n  if (item !== undefined) {\n    if (typeof item === 'number') {\n      item = createDictionaryItem(item);\n      this.dictionary[word] = item;\n    }\n\n    item.count++;\n  }\n\n  else {\n    item = createDictionaryItem();\n    item.count++;\n\n    this.dictionary[word] = item;\n\n    if (word.length > this.maxLength)\n      this.maxLength = word.length;\n  }\n\n  if (item.count === 1) {\n    var number = this.words.length;\n    this.words.push(word);\n\n    var deletes = edits(word, 0, this.maxDistance);\n\n    deletes.forEach(deletedItem => {\n      var target = this.dictionary[deletedItem];\n\n      if (target !== undefined) {\n        if (typeof target === 'number') {\n          target = createDictionaryItem(target);\n\n          this.dictionary[deletedItem] = target;\n        }\n\n        if (!target.suggestions.has(number)) {\n          addLowestDistance(\n            this.words,\n            this.verbosity,\n            target,\n            word,\n            number,\n            deletedItem\n          );\n        }\n      }\n      else {\n        this.dictionary[deletedItem] = number;\n      }\n    });\n  }\n\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to search the index.\n *\n * @param  {string} input - Input query.\n * @return {array}        - The found suggestions.\n */\nSymSpell.prototype.search = function(input) {\n  return lookup(\n    this.dictionary,\n    this.words,\n    this.verbosity,\n    this.maxDistance,\n    this.maxLength,\n    input\n  );\n};\n\n/**\n * Convenience known methods.\n */\nSymSpell.prototype.inspect = function() {\n  var array = [];\n\n  array.size = this.size;\n  array.maxDistance = this.maxDistance;\n  array.verbosity = this.verbosity;\n  array.behavior = VERBOSITY_EXPLANATIONS[this.verbosity];\n\n  for (var k in this.dictionary) {\n    if (typeof this.dictionary[k] === 'object' && this.dictionary[k].count)\n      array.push([k, this.dictionary[k].count]);\n  }\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: SymSpell,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  SymSpell.prototype[Symbol.for('nodejs.util.inspect.custom')] = SymSpell.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @return {SymSpell}\n */\nSymSpell.from = function(iterable, options) {\n  var index = new SymSpell(options);\n\n  forEach(iterable, function(value) {\n    index.add(value);\n  });\n\n  return index;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = SymSpell;\n"]},"metadata":{},"sourceType":"script"}