{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport { BigNumber } from 'ethers';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { IQuoterV2__factory } from '../../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../../util';\nimport { QUOTER_V2_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { routeToString } from '../../util/routes';\nexport var BlockConflictError = /*#__PURE__*/function (_Error) {\n  _inherits(BlockConflictError, _Error);\n\n  var _super = _createSuper(BlockConflictError);\n\n  function BlockConflictError() {\n    var _this;\n\n    _classCallCheck(this, BlockConflictError);\n\n    _this = _super.apply(this, arguments);\n    _this.name = 'BlockConflictError';\n    return _this;\n  }\n\n  return BlockConflictError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var SuccessRateError = /*#__PURE__*/function (_Error2) {\n  _inherits(SuccessRateError, _Error2);\n\n  var _super2 = _createSuper(SuccessRateError);\n\n  function SuccessRateError() {\n    var _this2;\n\n    _classCallCheck(this, SuccessRateError);\n\n    _this2 = _super2.apply(this, arguments);\n    _this2.name = 'SuccessRateError';\n    return _this2;\n  }\n\n  return SuccessRateError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var ProviderBlockHeaderError = /*#__PURE__*/function (_Error3) {\n  _inherits(ProviderBlockHeaderError, _Error3);\n\n  var _super3 = _createSuper(ProviderBlockHeaderError);\n\n  function ProviderBlockHeaderError() {\n    var _this3;\n\n    _classCallCheck(this, ProviderBlockHeaderError);\n\n    _this3 = _super3.apply(this, arguments);\n    _this3.name = 'ProviderBlockHeaderError';\n    return _this3;\n  }\n\n  return ProviderBlockHeaderError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var ProviderTimeoutError = /*#__PURE__*/function (_Error4) {\n  _inherits(ProviderTimeoutError, _Error4);\n\n  var _super4 = _createSuper(ProviderTimeoutError);\n\n  function ProviderTimeoutError() {\n    var _this4;\n\n    _classCallCheck(this, ProviderTimeoutError);\n\n    _this4 = _super4.apply(this, arguments);\n    _this4.name = 'ProviderTimeoutError';\n    return _this4;\n  }\n\n  return ProviderTimeoutError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\n\nexport var ProviderGasError = /*#__PURE__*/function (_Error5) {\n  _inherits(ProviderGasError, _Error5);\n\n  var _super5 = _createSuper(ProviderGasError);\n\n  function ProviderGasError() {\n    var _this5;\n\n    _classCallCheck(this, ProviderGasError);\n\n    _this5 = _super5.apply(this, arguments);\n    _this5.name = 'ProviderGasError';\n    return _this5;\n  }\n\n  return ProviderGasError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes quotes for V3. For V3, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. This is because computing quotes off-chain would\n * require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class V3QuoteProvider\n */\n\nexport var V3QuoteProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of V3QuoteProvider.\n   *\n   * @param chainId The chain to get quotes for.\n   * @param provider The web 3 provider.\n   * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n   * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n   * @param retryOptions The retry options for each call to the multicall.\n   * @param batchParams The parameters for each batched call to the multicall.\n   * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n   * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n   * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n   * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n   */\n  function V3QuoteProvider(chainId, provider, // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n  multicall2Provider) {\n    var retryOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      retries: DEFAULT_BATCH_RETRIES,\n      minTimeout: 25,\n      maxTimeout: 250\n    };\n    var batchParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      multicallChunk: 150,\n      gasLimitPerCall: 1000000,\n      quoteMinSuccessRate: 0.2\n    };\n    var gasErrorFailureOverride = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n      gasLimitOverride: 1500000,\n      multicallChunk: 100\n    };\n    var successRateFailureOverrides = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {\n      gasLimitOverride: 1300000,\n      multicallChunk: 110\n    };\n    var blockNumberConfig = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {\n      baseBlockOffset: 0,\n      rollback: {\n        enabled: false\n      }\n    };\n    var quoterAddressOverride = arguments.length > 8 ? arguments[8] : undefined;\n\n    _classCallCheck(this, V3QuoteProvider);\n\n    this.chainId = chainId;\n    this.provider = provider;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions;\n    this.batchParams = batchParams;\n    this.gasErrorFailureOverride = gasErrorFailureOverride;\n    this.successRateFailureOverrides = successRateFailureOverrides;\n    this.blockNumberConfig = blockNumberConfig;\n    this.quoterAddressOverride = quoterAddressOverride;\n    var quoterAddress = quoterAddressOverride ? quoterAddressOverride : QUOTER_V2_ADDRESS;\n\n    if (!quoterAddress) {\n      throw new Error(\"No address for Uniswap QuoterV2 Contract on chain id: \".concat(chainId));\n    }\n\n    this.quoterAddress = quoterAddress;\n  }\n\n  _createClass(V3QuoteProvider, [{\n    key: \"getQuotesManyExactIn\",\n    value: function () {\n      var _getQuotesManyExactIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(amountIns, routes, providerConfig) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getQuotesManyExactIn(_x, _x2, _x3) {\n        return _getQuotesManyExactIn.apply(this, arguments);\n      }\n\n      return getQuotesManyExactIn;\n    }()\n  }, {\n    key: \"getQuotesManyExactOut\",\n    value: function () {\n      var _getQuotesManyExactOut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(amountOuts, routes, providerConfig) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getQuotesManyExactOut(_x4, _x5, _x6) {\n        return _getQuotesManyExactOut.apply(this, arguments);\n      }\n\n      return getQuotesManyExactOut;\n    }()\n  }, {\n    key: \"getQuotesManyData\",\n    value: function () {\n      var _getQuotesManyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(amounts, routes, functionName, _providerConfig) {\n        var _this6 = this;\n\n        var _a, multicallChunk, gasLimitOverride, _this$blockNumberConf, baseBlockOffset, rollback, originalBlockNumber, providerConfig, inputs, normalizedChunk, inputsChunked, quoteStates, haveRetriedForSuccessRate, haveRetriedForBlockHeader, blockHeaderRetryAttemptNumber, haveIncrementedBlockHeaderFailureCounter, blockHeaderRolledBack, haveRetriedForBlockConflictError, haveRetriedForOutOfGas, haveRetriedForTimeout, haveRetriedForUnknownReason, finalAttemptNumber, expectedCallsMade, totalCallsMade, _yield$retry, quoteResults, blockNumber, approxGasUsedPerSuccessCall, routesQuotes, _$flatMap$partition$v, _$flatMap$partition$v2, successfulQuotes, failedQuotes;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                multicallChunk = this.batchParams.multicallChunk;\n                gasLimitOverride = this.batchParams.gasLimitPerCall;\n                _this$blockNumberConf = this.blockNumberConfig, baseBlockOffset = _this$blockNumberConf.baseBlockOffset, rollback = _this$blockNumberConf.rollback; // Apply the base block offset if provided\n\n                _context5.next = 5;\n                return this.provider.getBlockNumber();\n\n              case 5:\n                originalBlockNumber = _context5.sent;\n                providerConfig = _objectSpread(_objectSpread({}, _providerConfig), {}, {\n                  blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset\n                });\n                inputs = _(routes).flatMap(function (route) {\n                  var encodedRoute = encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n                  );\n                  var routeInputs = amounts.map(function (amount) {\n                    return [encodedRoute, \"0x\".concat(amount.quotient.toString(16))];\n                  });\n                  return routeInputs;\n                }).value();\n                normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                inputsChunked = _.chunk(inputs, normalizedChunk);\n                quoteStates = _.map(inputsChunked, function (inputChunk) {\n                  return {\n                    status: 'pending',\n                    inputs: inputChunk\n                  };\n                });\n                _context5.t0 = log;\n                _context5.t1 = \"About to get \".concat(inputs.length, \" quotes in chunks of \").concat(normalizedChunk, \" [\").concat(_.map(inputsChunked, function (i) {\n                  return i.length;\n                }).join(','), \"] \").concat(gasLimitOverride ? \"with a gas limit override of \".concat(gasLimitOverride) : '', \" and block number: \");\n                _context5.next = 15;\n                return providerConfig.blockNumber;\n\n              case 15:\n                _context5.t2 = _context5.sent;\n                _context5.t3 = _context5.t1.concat.call(_context5.t1, _context5.t2, \" [Original before offset: \").concat(originalBlockNumber, \"].\");\n\n                _context5.t0.info.call(_context5.t0, _context5.t3);\n\n                haveRetriedForSuccessRate = false;\n                haveRetriedForBlockHeader = false;\n                blockHeaderRetryAttemptNumber = 0;\n                haveIncrementedBlockHeaderFailureCounter = false;\n                blockHeaderRolledBack = false;\n                haveRetriedForBlockConflictError = false;\n                haveRetriedForOutOfGas = false;\n                haveRetriedForTimeout = false;\n                haveRetriedForUnknownReason = false;\n                finalAttemptNumber = 1;\n                expectedCallsMade = quoteStates.length;\n                totalCallsMade = 0;\n                _context5.next = 32;\n                return retry( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_bail, attemptNumber) {\n                    var _this6$partitionQuote, _this6$partitionQuote2, success, failed, pending, _this6$partitionQuote3, _this6$partitionQuote4, successfulQuoteStates, failedQuoteStates, pendingQuoteStates, retryAll, blockNumberError, reasonForFailureStr, _iterator, _step, failedQuoteState, error, rollbackBlockOffset, attemptsBeforeRollback, _normalizedChunk, _inputsChunked, callResults;\n\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            haveIncrementedBlockHeaderFailureCounter = false;\n                            finalAttemptNumber = attemptNumber;\n                            _this6$partitionQuote = _this6.partitionQuotes(quoteStates), _this6$partitionQuote2 = _slicedToArray(_this6$partitionQuote, 3), success = _this6$partitionQuote2[0], failed = _this6$partitionQuote2[1], pending = _this6$partitionQuote2[2];\n                            log.info(\"Starting attempt: \".concat(attemptNumber, \".\\n          Currently \").concat(success.length, \" success, \").concat(failed.length, \" failed, \").concat(pending.length, \" pending.\\n          Gas limit override: \").concat(gasLimitOverride, \" Block number override: \").concat(providerConfig.blockNumber, \".\"));\n                            _context4.next = 6;\n                            return Promise.all(_.map(quoteStates, /*#__PURE__*/function () {\n                              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(quoteState, idx) {\n                                var inputs, results, successRateError;\n                                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                  while (1) {\n                                    switch (_context3.prev = _context3.next) {\n                                      case 0:\n                                        if (!(quoteState.status == 'success')) {\n                                          _context3.next = 2;\n                                          break;\n                                        }\n\n                                        return _context3.abrupt(\"return\", quoteState);\n\n                                      case 2:\n                                        // QuoteChunk is pending or failed, so we try again\n                                        inputs = quoteState.inputs;\n                                        _context3.prev = 3;\n                                        totalCallsMade = totalCallsMade + 1;\n                                        _context3.next = 7;\n                                        return _this6.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n                                          address: _this6.quoterAddress,\n                                          contractInterface: IQuoterV2__factory.createInterface(),\n                                          functionName: functionName,\n                                          functionParams: inputs,\n                                          providerConfig: providerConfig,\n                                          additionalConfig: {\n                                            gasLimitPerCallOverride: gasLimitOverride\n                                          }\n                                        });\n\n                                      case 7:\n                                        results = _context3.sent;\n                                        successRateError = _this6.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n\n                                        if (!successRateError) {\n                                          _context3.next = 11;\n                                          break;\n                                        }\n\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: successRateError,\n                                          results: results\n                                        });\n\n                                      case 11:\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'success',\n                                          inputs: inputs,\n                                          results: results\n                                        });\n\n                                      case 14:\n                                        _context3.prev = 14;\n                                        _context3.t0 = _context3[\"catch\"](3);\n\n                                        if (!_context3.t0.message.includes('header not found')) {\n                                          _context3.next = 18;\n                                          break;\n                                        }\n\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderBlockHeaderError(_context3.t0.message.slice(0, 500))\n                                        });\n\n                                      case 18:\n                                        if (!_context3.t0.message.includes('timeout')) {\n                                          _context3.next = 20;\n                                          break;\n                                        }\n\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderTimeoutError(\"Req \".concat(idx, \"/\").concat(quoteStates.length, \". Request had \").concat(inputs.length, \" inputs. \").concat(_context3.t0.message.slice(0, 500)))\n                                        });\n\n                                      case 20:\n                                        if (!_context3.t0.message.includes('out of gas')) {\n                                          _context3.next = 22;\n                                          break;\n                                        }\n\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new ProviderGasError(_context3.t0.message.slice(0, 500))\n                                        });\n\n                                      case 22:\n                                        return _context3.abrupt(\"return\", {\n                                          status: 'failed',\n                                          inputs: inputs,\n                                          reason: new Error(\"Unknown error from provider: \".concat(_context3.t0.message.slice(0, 500)))\n                                        });\n\n                                      case 23:\n                                      case \"end\":\n                                        return _context3.stop();\n                                    }\n                                  }\n                                }, _callee3, null, [[3, 14]]);\n                              }));\n\n                              return function (_x13, _x14) {\n                                return _ref2.apply(this, arguments);\n                              };\n                            }()));\n\n                          case 6:\n                            quoteStates = _context4.sent;\n                            _this6$partitionQuote3 = _this6.partitionQuotes(quoteStates), _this6$partitionQuote4 = _slicedToArray(_this6$partitionQuote3, 3), successfulQuoteStates = _this6$partitionQuote4[0], failedQuoteStates = _this6$partitionQuote4[1], pendingQuoteStates = _this6$partitionQuote4[2];\n\n                            if (!(pendingQuoteStates.length > 0)) {\n                              _context4.next = 10;\n                              break;\n                            }\n\n                            throw new Error('Pending quote after waiting for all promises.');\n\n                          case 10:\n                            retryAll = false;\n                            blockNumberError = _this6.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride); // If there is a block number conflict we retry all the quotes.\n\n                            // If there is a block number conflict we retry all the quotes.\n                            if (blockNumberError) {\n                              retryAll = true;\n                            }\n\n                            reasonForFailureStr = _.map(failedQuoteStates, function (failedQuoteState) {\n                              return failedQuoteState.reason.name;\n                            }).join(', ');\n\n                            if (!(failedQuoteStates.length > 0)) {\n                              _context4.next = 64;\n                              break;\n                            }\n\n                            log.info(\"On attempt \".concat(attemptNumber, \": \").concat(failedQuoteStates.length, \"/\").concat(quoteStates.length, \" quotes failed. Reasons: \").concat(reasonForFailureStr));\n                            _iterator = _createForOfIteratorHelper(failedQuoteStates);\n                            _context4.prev = 17;\n\n                            _iterator.s();\n\n                          case 19:\n                            if ((_step = _iterator.n()).done) {\n                              _context4.next = 56;\n                              break;\n                            }\n\n                            failedQuoteState = _step.value;\n                            error = failedQuoteState.reason;\n                            log.info({\n                              error: error\n                            }, \"[QuoteFetchError] Attempt \".concat(attemptNumber, \". \").concat(error.message));\n\n                            if (!(error instanceof BlockConflictError)) {\n                              _context4.next = 28;\n                              break;\n                            }\n\n                            if (!haveRetriedForBlockConflictError) {\n                              metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n                              haveRetriedForBlockConflictError = true;\n                            }\n\n                            retryAll = true;\n                            _context4.next = 54;\n                            break;\n\n                          case 28:\n                            if (!(error instanceof ProviderBlockHeaderError)) {\n                              _context4.next = 53;\n                              break;\n                            }\n\n                            if (!haveRetriedForBlockHeader) {\n                              metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n                              haveRetriedForBlockHeader = true;\n                            } // Ensure that if multiple calls fail due to block header in the current pending batch,\n                            // we only count once.\n\n\n                            // Ensure that if multiple calls fail due to block header in the current pending batch,\n                            // we only count once.\n                            if (!haveIncrementedBlockHeaderFailureCounter) {\n                              blockHeaderRetryAttemptNumber = blockHeaderRetryAttemptNumber + 1;\n                              haveIncrementedBlockHeaderFailureCounter = true;\n                            }\n\n                            if (!rollback.enabled) {\n                              _context4.next = 51;\n                              break;\n                            }\n\n                            rollbackBlockOffset = rollback.rollbackBlockOffset, attemptsBeforeRollback = rollback.attemptsBeforeRollback;\n\n                            if (!(blockHeaderRetryAttemptNumber >= attemptsBeforeRollback && !blockHeaderRolledBack)) {\n                              _context4.next = 51;\n                              break;\n                            }\n\n                            log.info(\"Attempt \".concat(attemptNumber, \". Have failed due to block header \").concat(blockHeaderRetryAttemptNumber - 1, \" times. Rolling back block number by \").concat(rollbackBlockOffset, \" for next retry\"));\n\n                            if (!providerConfig.blockNumber) {\n                              _context4.next = 43;\n                              break;\n                            }\n\n                            _context4.next = 38;\n                            return providerConfig.blockNumber;\n\n                          case 38:\n                            _context4.t1 = _context4.sent;\n                            _context4.t2 = rollbackBlockOffset;\n                            _context4.t0 = _context4.t1 + _context4.t2;\n                            _context4.next = 48;\n                            break;\n\n                          case 43:\n                            _context4.next = 45;\n                            return _this6.provider.getBlockNumber();\n\n                          case 45:\n                            _context4.t3 = _context4.sent;\n                            _context4.t4 = rollbackBlockOffset;\n                            _context4.t0 = _context4.t3 + _context4.t4;\n\n                          case 48:\n                            providerConfig.blockNumber = _context4.t0;\n                            retryAll = true;\n                            blockHeaderRolledBack = true;\n\n                          case 51:\n                            _context4.next = 54;\n                            break;\n\n                          case 53:\n                            if (error instanceof ProviderTimeoutError) {\n                              if (!haveRetriedForTimeout) {\n                                metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForTimeout = true;\n                              }\n                            } else if (error instanceof ProviderGasError) {\n                              if (!haveRetriedForOutOfGas) {\n                                metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForOutOfGas = true;\n                              }\n\n                              gasLimitOverride = _this6.gasErrorFailureOverride.gasLimitOverride;\n                              multicallChunk = _this6.gasErrorFailureOverride.multicallChunk;\n                              retryAll = true;\n                            } else if (error instanceof SuccessRateError) {\n                              if (!haveRetriedForSuccessRate) {\n                                metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForSuccessRate = true; // Low success rate can indicate too little gas given to each call.\n\n                                // Low success rate can indicate too little gas given to each call.\n                                gasLimitOverride = _this6.successRateFailureOverrides.gasLimitOverride;\n                                multicallChunk = _this6.successRateFailureOverrides.multicallChunk;\n                                retryAll = true;\n                              }\n                            } else {\n                              if (!haveRetriedForUnknownReason) {\n                                metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n                                haveRetriedForUnknownReason = true;\n                              }\n                            }\n\n                          case 54:\n                            _context4.next = 19;\n                            break;\n\n                          case 56:\n                            _context4.next = 61;\n                            break;\n\n                          case 58:\n                            _context4.prev = 58;\n                            _context4.t5 = _context4[\"catch\"](17);\n\n                            _iterator.e(_context4.t5);\n\n                          case 61:\n                            _context4.prev = 61;\n\n                            _iterator.f();\n\n                            return _context4.finish(61);\n\n                          case 64:\n                            if (retryAll) {\n                              log.info(\"Attempt \".concat(attemptNumber, \". Resetting all requests to pending for next attempt.\"));\n                              _normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                              _inputsChunked = _.chunk(inputs, _normalizedChunk);\n                              quoteStates = _.map(_inputsChunked, function (inputChunk) {\n                                return {\n                                  status: 'pending',\n                                  inputs: inputChunk\n                                };\n                              });\n                            }\n\n                            if (!(failedQuoteStates.length > 0)) {\n                              _context4.next = 70;\n                              break;\n                            }\n\n                            if (!((_this6.chainId == ChainId.ARBITRUM_ONE || _this6.chainId == ChainId.ARBITRUM_RINKEBY) && _.every(failedQuoteStates, function (failedQuoteState) {\n                              return failedQuoteState.reason instanceof ProviderGasError;\n                            }) && attemptNumber == _this6.retryOptions.retries)) {\n                              _context4.next = 69;\n                              break;\n                            }\n\n                            log.error(\"Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.\");\n                            return _context4.abrupt(\"return\", {\n                              results: [],\n                              blockNumber: BigNumber.from(0),\n                              approxGasUsedPerSuccessCall: 0\n                            });\n\n                          case 69:\n                            throw new Error(\"Failed to get \".concat(failedQuoteStates.length, \" quotes. Reasons: \").concat(reasonForFailureStr));\n\n                          case 70:\n                            callResults = _.map(successfulQuoteStates, function (quoteState) {\n                              return quoteState.results;\n                            });\n                            return _context4.abrupt(\"return\", {\n                              results: _.flatMap(callResults, function (result) {\n                                return result.results;\n                              }),\n                              blockNumber: BigNumber.from(callResults[0].blockNumber),\n                              approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, function (result) {\n                                return result.approxGasUsedPerSuccessCall;\n                              }), 100)\n                            });\n\n                          case 72:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, null, [[17, 58, 61, 64]]);\n                  }));\n\n                  return function (_x11, _x12) {\n                    return _ref.apply(this, arguments);\n                  };\n                }(), _objectSpread({\n                  retries: DEFAULT_BATCH_RETRIES\n                }, this.retryOptions));\n\n              case 32:\n                _yield$retry = _context5.sent;\n                quoteResults = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                approxGasUsedPerSuccessCall = _yield$retry.approxGasUsedPerSuccessCall;\n                routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n                metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n                metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n                _$flatMap$partition$v = _(routesQuotes).flatMap(function (routeWithQuotes) {\n                  return routeWithQuotes[1];\n                }).partition(function (quote) {\n                  return quote.quote != null;\n                }).value(), _$flatMap$partition$v2 = _slicedToArray(_$flatMap$partition$v, 2), successfulQuotes = _$flatMap$partition$v2[0], failedQuotes = _$flatMap$partition$v2[1];\n                log.info(\"Got \".concat(successfulQuotes.length, \" successful quotes, \").concat(failedQuotes.length, \" failed quotes. Took \").concat(finalAttemptNumber - 1, \" attempt loops. Total calls made to provider: \").concat(totalCallsMade, \". Have retried for timeout: \").concat(haveRetriedForTimeout));\n                return _context5.abrupt(\"return\", {\n                  routesWithQuotes: routesQuotes,\n                  blockNumber: blockNumber\n                });\n\n              case 45:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getQuotesManyData(_x7, _x8, _x9, _x10) {\n        return _getQuotesManyData.apply(this, arguments);\n      }\n\n      return getQuotesManyData;\n    }()\n  }, {\n    key: \"partitionQuotes\",\n    value: function partitionQuotes(quoteStates) {\n      var successfulQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'success';\n      });\n\n      var failedQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'failed';\n      });\n\n      var pendingQuoteStates = _.filter(quoteStates, function (quoteState) {\n        return quoteState.status == 'pending';\n      });\n\n      return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n    }\n  }, {\n    key: \"processQuoteResults\",\n    value: function processQuoteResults(quoteResults, routes, amounts) {\n      var routesQuotes = [];\n\n      var quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n\n      var debugFailedQuotes = [];\n\n      var _loop = function _loop(i) {\n        var route = routes[i];\n        var quoteResults = quotesResultsByRoute[i];\n\n        var quotes = _.map(quoteResults, function (quoteResult, index) {\n          var amount = amounts[index];\n\n          if (!quoteResult.success) {\n            var percent = 100 / amounts.length * (index + 1);\n            var amountStr = amount.toFixed(2);\n            var routeStr = routeToString(route);\n            debugFailedQuotes.push({\n              route: routeStr,\n              percent: percent,\n              amount: amountStr\n            });\n            return {\n              amount: amount,\n              quote: null,\n              sqrtPriceX96AfterList: null,\n              gasEstimate: null,\n              initializedTicksCrossedList: null\n            };\n          }\n\n          return {\n            amount: amount,\n            quote: quoteResult.result[0],\n            sqrtPriceX96AfterList: quoteResult.result[1],\n            initializedTicksCrossedList: quoteResult.result[2],\n            gasEstimate: quoteResult.result[3]\n          };\n        });\n\n        routesQuotes.push([route, quotes]);\n      };\n\n      for (var i = 0; i < quotesResultsByRoute.length; i++) {\n        _loop(i);\n      } // For routes and amounts that we failed to get a quote for, group them by route\n      // and batch them together before logging to minimize number of logs.\n\n\n      var debugChunk = 80;\n\n      _.forEach(_.chunk(debugFailedQuotes, debugChunk), function (quotes, idx) {\n        var failedQuotesByRoute = _.groupBy(quotes, function (q) {\n          return q.route;\n        });\n\n        var failedFlat = _.mapValues(failedQuotesByRoute, function (f) {\n          return _(f).map(function (f) {\n            return \"\".concat(f.percent, \"%[\").concat(f.amount, \"]\");\n          }).join(',');\n        });\n\n        log.info({\n          failedQuotes: _.map(failedFlat, function (amounts, routeStr) {\n            return \"\".concat(routeStr, \" : \").concat(amounts);\n          })\n        }, \"Failed quotes for routes Part \".concat(idx, \"/\").concat(Math.ceil(debugFailedQuotes.length / debugChunk)));\n      });\n\n      return routesQuotes;\n    }\n  }, {\n    key: \"validateBlockNumbers\",\n    value: function validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n      if (successfulQuoteStates.length <= 1) {\n        return null;\n      }\n\n      var results = _.map(successfulQuoteStates, function (quoteState) {\n        return quoteState.results;\n      });\n\n      var blockNumbers = _.map(results, function (result) {\n        return result.blockNumber;\n      });\n\n      var uniqBlocks = _(blockNumbers).map(function (blockNumber) {\n        return blockNumber.toNumber();\n      }).uniq().value();\n\n      if (uniqBlocks.length == 1) {\n        return null;\n      }\n      /* if (\n        uniqBlocks.length == 2 &&\n        Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n      ) {\n        return null;\n      } */\n\n\n      return new BlockConflictError(\"Quotes returned from different blocks. \".concat(uniqBlocks, \". \").concat(totalCalls, \" calls were made with gas limit \").concat(gasLimitOverride));\n    }\n  }, {\n    key: \"validateSuccessRate\",\n    value: function validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n      var numResults = allResults.length;\n      var numSuccessResults = allResults.filter(function (result) {\n        return result.success;\n      }).length;\n      var successRate = 1.0 * numSuccessResults / numResults;\n      var quoteMinSuccessRate = this.batchParams.quoteMinSuccessRate;\n\n      if (successRate < quoteMinSuccessRate) {\n        if (haveRetriedForSuccessRate) {\n          log.info(\"Quote success rate still below threshold despite retry. Continuing. \".concat(quoteMinSuccessRate, \": \").concat(successRate));\n          return;\n        }\n\n        return new SuccessRateError(\"Quote success rate below threshold of \".concat(quoteMinSuccessRate, \": \").concat(successRate));\n      }\n    }\n  }]);\n\n  return V3QuoteProvider;\n}();","map":{"version":3,"sources":["../../../../../src/providers/v3/quote-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encodeRouteToPath } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport { BigNumber } from 'ethers';\nimport _ from 'lodash';\nimport stats from 'stats-lite';\nimport { IQuoterV2__factory } from '../../types/v3/factories/IQuoterV2__factory';\nimport { ChainId, metric, MetricLoggerUnit } from '../../util';\nimport { QUOTER_V2_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { routeToString } from '../../util/routes';\nexport class BlockConflictError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BlockConflictError';\n    }\n}\nexport class SuccessRateError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SuccessRateError';\n    }\n}\nexport class ProviderBlockHeaderError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderBlockHeaderError';\n    }\n}\nexport class ProviderTimeoutError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderTimeoutError';\n    }\n}\n/**\n * This error typically means that the gas used by the multicall has\n * exceeded the total call gas limit set by the node provider.\n *\n * This can be resolved by modifying BatchParams to request fewer\n * quotes per call, or to set a lower gas limit per quote.\n *\n * @export\n * @class ProviderGasError\n */\nexport class ProviderGasError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ProviderGasError';\n    }\n}\nconst DEFAULT_BATCH_RETRIES = 2;\n/**\n * Computes quotes for V3. For V3, quotes are computed on-chain using\n * the 'QuoterV2' smart contract. This is because computing quotes off-chain would\n * require fetching all the tick data for each pool, which is a lot of data.\n *\n * To minimize the number of requests for quotes we use a Multicall contract. Generally\n * the number of quotes to fetch exceeds the maximum we can fit in a single multicall\n * while staying under gas limits, so we also batch these quotes across multiple multicalls.\n *\n * The biggest challenge with the quote provider is dealing with various gas limits.\n * Each provider sets a limit on the amount of gas a call can consume (on Infura this\n * is approximately 10x the block max size), so we must ensure each multicall does not\n * exceed this limit. Additionally, each quote on V3 can consume a large number of gas if\n * the pool lacks liquidity and the swap would cause all the ticks to be traversed.\n *\n * To ensure we don't exceed the node's call limit, we limit the gas used by each quote to\n * a specific value, and we limit the number of quotes in each multicall request. Users of this\n * class should set BatchParams such that multicallChunk * gasLimitPerCall is less than their node\n * providers total gas limit per call.\n *\n * @export\n * @class V3QuoteProvider\n */\nexport class V3QuoteProvider {\n    /**\n     * Creates an instance of V3QuoteProvider.\n     *\n     * @param chainId The chain to get quotes for.\n     * @param provider The web 3 provider.\n     * @param multicall2Provider The multicall provider to use to get the quotes on-chain.\n     * Only supports the Uniswap Multicall contract as it needs the gas limitting functionality.\n     * @param retryOptions The retry options for each call to the multicall.\n     * @param batchParams The parameters for each batched call to the multicall.\n     * @param gasErrorFailureOverride The gas and chunk parameters to use when retrying a batch that failed due to out of gas.\n     * @param successRateFailureOverrides The parameters for retries when we fail to get quotes.\n     * @param blockNumberConfig Parameters for adjusting which block we get quotes from, and how to handle block header not found errors.\n     * @param [quoterAddressOverride] Overrides the address of the quoter contract to use.\n     */\n    constructor(chainId, provider, \n    // Only supports Uniswap Multicall as it needs the gas limitting functionality.\n    multicall2Provider, retryOptions = {\n        retries: DEFAULT_BATCH_RETRIES,\n        minTimeout: 25,\n        maxTimeout: 250,\n    }, batchParams = {\n        multicallChunk: 150,\n        gasLimitPerCall: 1000000,\n        quoteMinSuccessRate: 0.2,\n    }, gasErrorFailureOverride = {\n        gasLimitOverride: 1500000,\n        multicallChunk: 100,\n    }, successRateFailureOverrides = {\n        gasLimitOverride: 1300000,\n        multicallChunk: 110,\n    }, blockNumberConfig = {\n        baseBlockOffset: 0,\n        rollback: { enabled: false },\n    }, quoterAddressOverride) {\n        this.chainId = chainId;\n        this.provider = provider;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        this.batchParams = batchParams;\n        this.gasErrorFailureOverride = gasErrorFailureOverride;\n        this.successRateFailureOverrides = successRateFailureOverrides;\n        this.blockNumberConfig = blockNumberConfig;\n        this.quoterAddressOverride = quoterAddressOverride;\n        const quoterAddress = quoterAddressOverride\n            ? quoterAddressOverride\n            : QUOTER_V2_ADDRESS;\n        if (!quoterAddress) {\n            throw new Error(`No address for Uniswap QuoterV2 Contract on chain id: ${chainId}`);\n        }\n        this.quoterAddress = quoterAddress;\n    }\n    async getQuotesManyExactIn(amountIns, routes, providerConfig) {\n        return this.getQuotesManyData(amountIns, routes, 'quoteExactInput', providerConfig);\n    }\n    async getQuotesManyExactOut(amountOuts, routes, providerConfig) {\n        return this.getQuotesManyData(amountOuts, routes, 'quoteExactOutput', providerConfig);\n    }\n    async getQuotesManyData(amounts, routes, functionName, _providerConfig) {\n        var _a;\n        let multicallChunk = this.batchParams.multicallChunk;\n        let gasLimitOverride = this.batchParams.gasLimitPerCall;\n        const { baseBlockOffset, rollback } = this.blockNumberConfig;\n        // Apply the base block offset if provided\n        const originalBlockNumber = await this.provider.getBlockNumber();\n        const providerConfig = {\n            ..._providerConfig,\n            blockNumber: (_a = _providerConfig === null || _providerConfig === void 0 ? void 0 : _providerConfig.blockNumber) !== null && _a !== void 0 ? _a : originalBlockNumber + baseBlockOffset,\n        };\n        const inputs = _(routes)\n            .flatMap((route) => {\n            const encodedRoute = encodeRouteToPath(route, functionName == 'quoteExactOutput' // For exactOut must be true to ensure the routes are reversed.\n            );\n            const routeInputs = amounts.map((amount) => [\n                encodedRoute,\n                `0x${amount.quotient.toString(16)}`,\n            ]);\n            return routeInputs;\n        })\n            .value();\n        const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n        const inputsChunked = _.chunk(inputs, normalizedChunk);\n        let quoteStates = _.map(inputsChunked, (inputChunk) => {\n            return {\n                status: 'pending',\n                inputs: inputChunk,\n            };\n        });\n        log.info(`About to get ${inputs.length} quotes in chunks of ${normalizedChunk} [${_.map(inputsChunked, (i) => i.length).join(',')}] ${gasLimitOverride\n            ? `with a gas limit override of ${gasLimitOverride}`\n            : ''} and block number: ${await providerConfig.blockNumber} [Original before offset: ${originalBlockNumber}].`);\n        let haveRetriedForSuccessRate = false;\n        let haveRetriedForBlockHeader = false;\n        let blockHeaderRetryAttemptNumber = 0;\n        let haveIncrementedBlockHeaderFailureCounter = false;\n        let blockHeaderRolledBack = false;\n        let haveRetriedForBlockConflictError = false;\n        let haveRetriedForOutOfGas = false;\n        let haveRetriedForTimeout = false;\n        let haveRetriedForUnknownReason = false;\n        let finalAttemptNumber = 1;\n        let expectedCallsMade = quoteStates.length;\n        let totalCallsMade = 0;\n        const { results: quoteResults, blockNumber, approxGasUsedPerSuccessCall, } = await retry(async (_bail, attemptNumber) => {\n            haveIncrementedBlockHeaderFailureCounter = false;\n            finalAttemptNumber = attemptNumber;\n            const [success, failed, pending] = this.partitionQuotes(quoteStates);\n            log.info(`Starting attempt: ${attemptNumber}.\n          Currently ${success.length} success, ${failed.length} failed, ${pending.length} pending.\n          Gas limit override: ${gasLimitOverride} Block number override: ${providerConfig.blockNumber}.`);\n            quoteStates = await Promise.all(_.map(quoteStates, async (quoteState, idx) => {\n                if (quoteState.status == 'success') {\n                    return quoteState;\n                }\n                // QuoteChunk is pending or failed, so we try again\n                const { inputs } = quoteState;\n                try {\n                    totalCallsMade = totalCallsMade + 1;\n                    const results = await this.multicall2Provider.callSameFunctionOnContractWithMultipleParams({\n                        address: this.quoterAddress,\n                        contractInterface: IQuoterV2__factory.createInterface(),\n                        functionName,\n                        functionParams: inputs,\n                        providerConfig,\n                        additionalConfig: {\n                            gasLimitPerCallOverride: gasLimitOverride,\n                        },\n                    });\n                    const successRateError = this.validateSuccessRate(results.results, haveRetriedForSuccessRate);\n                    if (successRateError) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: successRateError,\n                            results,\n                        };\n                    }\n                    return {\n                        status: 'success',\n                        inputs,\n                        results,\n                    };\n                }\n                catch (err) {\n                    // Error from providers have huge messages that include all the calldata and fill the logs.\n                    // Catch them and rethrow with shorter message.\n                    if (err.message.includes('header not found')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderBlockHeaderError(err.message.slice(0, 500)),\n                        };\n                    }\n                    if (err.message.includes('timeout')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderTimeoutError(`Req ${idx}/${quoteStates.length}. Request had ${inputs.length} inputs. ${err.message.slice(0, 500)}`),\n                        };\n                    }\n                    if (err.message.includes('out of gas')) {\n                        return {\n                            status: 'failed',\n                            inputs,\n                            reason: new ProviderGasError(err.message.slice(0, 500)),\n                        };\n                    }\n                    return {\n                        status: 'failed',\n                        inputs,\n                        reason: new Error(`Unknown error from provider: ${err.message.slice(0, 500)}`),\n                    };\n                }\n            }));\n            const [successfulQuoteStates, failedQuoteStates, pendingQuoteStates] = this.partitionQuotes(quoteStates);\n            if (pendingQuoteStates.length > 0) {\n                throw new Error('Pending quote after waiting for all promises.');\n            }\n            let retryAll = false;\n            const blockNumberError = this.validateBlockNumbers(successfulQuoteStates, inputsChunked.length, gasLimitOverride);\n            // If there is a block number conflict we retry all the quotes.\n            if (blockNumberError) {\n                retryAll = true;\n            }\n            const reasonForFailureStr = _.map(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason.name).join(', ');\n            if (failedQuoteStates.length > 0) {\n                log.info(`On attempt ${attemptNumber}: ${failedQuoteStates.length}/${quoteStates.length} quotes failed. Reasons: ${reasonForFailureStr}`);\n                for (const failedQuoteState of failedQuoteStates) {\n                    const { reason: error } = failedQuoteState;\n                    log.info({ error }, `[QuoteFetchError] Attempt ${attemptNumber}. ${error.message}`);\n                    if (error instanceof BlockConflictError) {\n                        if (!haveRetriedForBlockConflictError) {\n                            metric.putMetric('QuoteBlockConflictErrorRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockConflictError = true;\n                        }\n                        retryAll = true;\n                    }\n                    else if (error instanceof ProviderBlockHeaderError) {\n                        if (!haveRetriedForBlockHeader) {\n                            metric.putMetric('QuoteBlockHeaderNotFoundRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForBlockHeader = true;\n                        }\n                        // Ensure that if multiple calls fail due to block header in the current pending batch,\n                        // we only count once.\n                        if (!haveIncrementedBlockHeaderFailureCounter) {\n                            blockHeaderRetryAttemptNumber =\n                                blockHeaderRetryAttemptNumber + 1;\n                            haveIncrementedBlockHeaderFailureCounter = true;\n                        }\n                        if (rollback.enabled) {\n                            const { rollbackBlockOffset, attemptsBeforeRollback } = rollback;\n                            if (blockHeaderRetryAttemptNumber >= attemptsBeforeRollback &&\n                                !blockHeaderRolledBack) {\n                                log.info(`Attempt ${attemptNumber}. Have failed due to block header ${blockHeaderRetryAttemptNumber - 1} times. Rolling back block number by ${rollbackBlockOffset} for next retry`);\n                                providerConfig.blockNumber = providerConfig.blockNumber\n                                    ? (await providerConfig.blockNumber) + rollbackBlockOffset\n                                    : (await this.provider.getBlockNumber()) +\n                                        rollbackBlockOffset;\n                                retryAll = true;\n                                blockHeaderRolledBack = true;\n                            }\n                        }\n                    }\n                    else if (error instanceof ProviderTimeoutError) {\n                        if (!haveRetriedForTimeout) {\n                            metric.putMetric('QuoteTimeoutRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForTimeout = true;\n                        }\n                    }\n                    else if (error instanceof ProviderGasError) {\n                        if (!haveRetriedForOutOfGas) {\n                            metric.putMetric('QuoteOutOfGasExceptionRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForOutOfGas = true;\n                        }\n                        gasLimitOverride = this.gasErrorFailureOverride.gasLimitOverride;\n                        multicallChunk = this.gasErrorFailureOverride.multicallChunk;\n                        retryAll = true;\n                    }\n                    else if (error instanceof SuccessRateError) {\n                        if (!haveRetriedForSuccessRate) {\n                            metric.putMetric('QuoteSuccessRateRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForSuccessRate = true;\n                            // Low success rate can indicate too little gas given to each call.\n                            gasLimitOverride =\n                                this.successRateFailureOverrides.gasLimitOverride;\n                            multicallChunk =\n                                this.successRateFailureOverrides.multicallChunk;\n                            retryAll = true;\n                        }\n                    }\n                    else {\n                        if (!haveRetriedForUnknownReason) {\n                            metric.putMetric('QuoteUnknownReasonRetry', 1, MetricLoggerUnit.Count);\n                            haveRetriedForUnknownReason = true;\n                        }\n                    }\n                }\n            }\n            if (retryAll) {\n                log.info(`Attempt ${attemptNumber}. Resetting all requests to pending for next attempt.`);\n                const normalizedChunk = Math.ceil(inputs.length / Math.ceil(inputs.length / multicallChunk));\n                const inputsChunked = _.chunk(inputs, normalizedChunk);\n                quoteStates = _.map(inputsChunked, (inputChunk) => {\n                    return {\n                        status: 'pending',\n                        inputs: inputChunk,\n                    };\n                });\n            }\n            if (failedQuoteStates.length > 0) {\n                // TODO: Work with Arbitrum to find a solution for making large multicalls with gas limits that always\n                // successfully.\n                //\n                // On Arbitrum we can not set a gas limit for every call in the multicall and guarantee that\n                // we will not run out of gas on the node. This is because they have a different way of accounting\n                // for gas, that seperates storage and compute gas costs, and we can not cover both in a single limit.\n                //\n                // To work around this and avoid throwing errors when really we just couldn't get a quote, we catch this\n                // case and return 0 quotes found.\n                if ((this.chainId == ChainId.ARBITRUM_ONE ||\n                    this.chainId == ChainId.ARBITRUM_RINKEBY) &&\n                    _.every(failedQuoteStates, (failedQuoteState) => failedQuoteState.reason instanceof ProviderGasError) &&\n                    attemptNumber == this.retryOptions.retries) {\n                    log.error(`Failed to get quotes on Arbitrum due to provider gas error issue. Overriding error to return 0 quotes.`);\n                    return {\n                        results: [],\n                        blockNumber: BigNumber.from(0),\n                        approxGasUsedPerSuccessCall: 0,\n                    };\n                }\n                throw new Error(`Failed to get ${failedQuoteStates.length} quotes. Reasons: ${reasonForFailureStr}`);\n            }\n            const callResults = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n            return {\n                results: _.flatMap(callResults, (result) => result.results),\n                blockNumber: BigNumber.from(callResults[0].blockNumber),\n                approxGasUsedPerSuccessCall: stats.percentile(_.map(callResults, (result) => result.approxGasUsedPerSuccessCall), 100),\n            };\n        }, {\n            retries: DEFAULT_BATCH_RETRIES,\n            ...this.retryOptions,\n        });\n        const routesQuotes = this.processQuoteResults(quoteResults, routes, amounts);\n        metric.putMetric('QuoteApproxGasUsedPerSuccessfulCall', approxGasUsedPerSuccessCall, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetryLoops', finalAttemptNumber - 1, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteTotalCallsToProvider', totalCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteExpectedCallsToProvider', expectedCallsMade, MetricLoggerUnit.Count);\n        metric.putMetric('QuoteNumRetriedCalls', totalCallsMade - expectedCallsMade, MetricLoggerUnit.Count);\n        const [successfulQuotes, failedQuotes] = _(routesQuotes)\n            .flatMap((routeWithQuotes) => routeWithQuotes[1])\n            .partition((quote) => quote.quote != null)\n            .value();\n        log.info(`Got ${successfulQuotes.length} successful quotes, ${failedQuotes.length} failed quotes. Took ${finalAttemptNumber - 1} attempt loops. Total calls made to provider: ${totalCallsMade}. Have retried for timeout: ${haveRetriedForTimeout}`);\n        return { routesWithQuotes: routesQuotes, blockNumber };\n    }\n    partitionQuotes(quoteStates) {\n        const successfulQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'success');\n        const failedQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'failed');\n        const pendingQuoteStates = _.filter(quoteStates, (quoteState) => quoteState.status == 'pending');\n        return [successfulQuoteStates, failedQuoteStates, pendingQuoteStates];\n    }\n    processQuoteResults(quoteResults, routes, amounts) {\n        const routesQuotes = [];\n        const quotesResultsByRoute = _.chunk(quoteResults, amounts.length);\n        const debugFailedQuotes = [];\n        for (let i = 0; i < quotesResultsByRoute.length; i++) {\n            const route = routes[i];\n            const quoteResults = quotesResultsByRoute[i];\n            const quotes = _.map(quoteResults, (quoteResult, index) => {\n                const amount = amounts[index];\n                if (!quoteResult.success) {\n                    const percent = (100 / amounts.length) * (index + 1);\n                    const amountStr = amount.toFixed(2);\n                    const routeStr = routeToString(route);\n                    debugFailedQuotes.push({\n                        route: routeStr,\n                        percent,\n                        amount: amountStr,\n                    });\n                    return {\n                        amount,\n                        quote: null,\n                        sqrtPriceX96AfterList: null,\n                        gasEstimate: null,\n                        initializedTicksCrossedList: null,\n                    };\n                }\n                return {\n                    amount,\n                    quote: quoteResult.result[0],\n                    sqrtPriceX96AfterList: quoteResult.result[1],\n                    initializedTicksCrossedList: quoteResult.result[2],\n                    gasEstimate: quoteResult.result[3],\n                };\n            });\n            routesQuotes.push([route, quotes]);\n        }\n        // For routes and amounts that we failed to get a quote for, group them by route\n        // and batch them together before logging to minimize number of logs.\n        const debugChunk = 80;\n        _.forEach(_.chunk(debugFailedQuotes, debugChunk), (quotes, idx) => {\n            const failedQuotesByRoute = _.groupBy(quotes, (q) => q.route);\n            const failedFlat = _.mapValues(failedQuotesByRoute, (f) => _(f)\n                .map((f) => `${f.percent}%[${f.amount}]`)\n                .join(','));\n            log.info({\n                failedQuotes: _.map(failedFlat, (amounts, routeStr) => `${routeStr} : ${amounts}`),\n            }, `Failed quotes for routes Part ${idx}/${Math.ceil(debugFailedQuotes.length / debugChunk)}`);\n        });\n        return routesQuotes;\n    }\n    validateBlockNumbers(successfulQuoteStates, totalCalls, gasLimitOverride) {\n        if (successfulQuoteStates.length <= 1) {\n            return null;\n        }\n        const results = _.map(successfulQuoteStates, (quoteState) => quoteState.results);\n        const blockNumbers = _.map(results, (result) => result.blockNumber);\n        const uniqBlocks = _(blockNumbers)\n            .map((blockNumber) => blockNumber.toNumber())\n            .uniq()\n            .value();\n        if (uniqBlocks.length == 1) {\n            return null;\n        }\n        /* if (\n          uniqBlocks.length == 2 &&\n          Math.abs(uniqBlocks[0]! - uniqBlocks[1]!) <= 1\n        ) {\n          return null;\n        } */\n        return new BlockConflictError(`Quotes returned from different blocks. ${uniqBlocks}. ${totalCalls} calls were made with gas limit ${gasLimitOverride}`);\n    }\n    validateSuccessRate(allResults, haveRetriedForSuccessRate) {\n        const numResults = allResults.length;\n        const numSuccessResults = allResults.filter((result) => result.success).length;\n        const successRate = (1.0 * numSuccessResults) / numResults;\n        const { quoteMinSuccessRate } = this.batchParams;\n        if (successRate < quoteMinSuccessRate) {\n            if (haveRetriedForSuccessRate) {\n                log.info(`Quote success rate still below threshold despite retry. Continuing. ${quoteMinSuccessRate}: ${successRate}`);\n                return;\n            }\n            return new SuccessRateError(`Quote success rate below threshold of ${quoteMinSuccessRate}: ${successRate}`);\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVvdGUtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvcHJvdmlkZXJzL3YzL3F1b3RlLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFBeUIsT0FBTyxJQUFJLEtBQUssRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN0RSxPQUFPLEVBQUUsU0FBUyxFQUFhLE1BQU0sUUFBUSxDQUFDO0FBQzlDLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxZQUFZLENBQUM7QUFFL0IsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDakYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDL0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFekQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQThCbEQsTUFBTSxPQUFPLGtCQUFtQixTQUFRLEtBQUs7SUFBN0M7O1FBQ1MsU0FBSSxHQUFHLG9CQUFvQixDQUFDO0lBQ3JDLENBQUM7Q0FBQTtBQUNELE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxLQUFLO0lBQTNDOztRQUNTLFNBQUksR0FBRyxrQkFBa0IsQ0FBQztJQUNuQyxDQUFDO0NBQUE7QUFFRCxNQUFNLE9BQU8sd0JBQXlCLFNBQVEsS0FBSztJQUFuRDs7UUFDUyxTQUFJLEdBQUcsMEJBQTBCLENBQUM7SUFDM0MsQ0FBQztDQUFBO0FBRUQsTUFBTSxPQUFPLG9CQUFxQixTQUFRLEtBQUs7SUFBL0M7O1FBQ1MsU0FBSSxHQUFHLHNCQUFzQixDQUFDO0lBQ3ZD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"]},"metadata":{},"sourceType":"module"}