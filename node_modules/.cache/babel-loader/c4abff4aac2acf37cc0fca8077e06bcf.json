{"ast":null,"code":"/**\n * Mnemonist Trie\n * ===============\n *\n * JavaScript Trie implementation based upon plain objects. As such this\n * structure is more a convenience building upon the trie's advantages than\n * a real performant alternative to already existing structures.\n *\n * Note that the Trie is based upon the TrieMap since the underlying machine\n * is the very same. The Trie just does not let you set values and only\n * considers the existence of the given prefixes.\n */\nvar forEach = require('obliterator/foreach'),\n    TrieMap = require('./trie-map.js');\n/**\n * Constants.\n */\n\n\nvar SENTINEL = String.fromCharCode(0);\n/**\n * Trie.\n *\n * @constructor\n */\n\nfunction Trie(Token) {\n  this.mode = Token === Array ? 'array' : 'string';\n  this.clear();\n} // Re-using TrieMap's prototype\n\n\nfor (var methodName in TrieMap.prototype) {\n  Trie.prototype[methodName] = TrieMap.prototype[methodName];\n} // Dropping irrelevant methods\n\n\ndelete Trie.prototype.set;\ndelete Trie.prototype.get;\ndelete Trie.prototype.values;\ndelete Trie.prototype.entries;\n/**\n * Method used to add the given prefix to the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @return {TrieMap}\n */\n\nTrie.prototype.add = function (prefix) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token] || (node[token] = {});\n  } // Do we need to increase size?\n\n\n  if (!(SENTINEL in node)) this.size++;\n  node[SENTINEL] = true;\n  return this;\n};\n/**\n * Method used to retrieve every item in the trie with the given prefix.\n *\n * @param  {string|array} prefix - Prefix to query.\n * @return {array}\n */\n\n\nTrie.prototype.find = function (prefix) {\n  var isString = typeof prefix === 'string';\n  var node = this.root,\n      matches = [],\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n    if (typeof node === 'undefined') return matches;\n  } // Performing DFS from prefix\n\n\n  var nodeStack = [node],\n      prefixStack = [prefix],\n      k;\n\n  while (nodeStack.length) {\n    prefix = prefixStack.pop();\n    node = nodeStack.pop();\n\n    for (k in node) {\n      if (k === SENTINEL) {\n        matches.push(prefix);\n        continue;\n      }\n\n      nodeStack.push(node[k]);\n      prefixStack.push(isString ? prefix + k : prefix.concat(k));\n    }\n  }\n\n  return matches;\n};\n/**\n * Attaching the #.keys method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') Trie.prototype[Symbol.iterator] = Trie.prototype.keys;\n/**\n * Convenience known methods.\n */\n\nTrie.prototype.inspect = function () {\n  var proxy = new Set();\n  var iterator = this.keys(),\n      step;\n\n  while (step = iterator.next(), !step.done) {\n    proxy.add(step.value);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: Trie,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') Trie.prototype[Symbol.for('nodejs.util.inspect.custom')] = Trie.prototype.inspect;\n\nTrie.prototype.toJSON = function () {\n  return this.root;\n};\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a trie.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {Trie}\n */\n\n\nTrie.from = function (iterable) {\n  var trie = new Trie();\n  forEach(iterable, function (value) {\n    trie.add(value);\n  });\n  return trie;\n};\n/**\n * Exporting.\n */\n\n\nTrie.SENTINEL = SENTINEL;\nmodule.exports = Trie;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/trie.js"],"names":["forEach","require","TrieMap","SENTINEL","String","fromCharCode","Trie","Token","mode","Array","clear","methodName","prototype","set","get","values","entries","add","prefix","node","root","token","i","l","length","size","find","isString","matches","nodeStack","prefixStack","k","pop","push","concat","Symbol","iterator","keys","inspect","proxy","Set","step","next","done","value","Object","defineProperty","enumerable","for","toJSON","from","iterable","trie","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Trie\n * ===============\n *\n * JavaScript Trie implementation based upon plain objects. As such this\n * structure is more a convenience building upon the trie's advantages than\n * a real performant alternative to already existing structures.\n *\n * Note that the Trie is based upon the TrieMap since the underlying machine\n * is the very same. The Trie just does not let you set values and only\n * considers the existence of the given prefixes.\n */\nvar forEach = require('obliterator/foreach'),\n    TrieMap = require('./trie-map.js');\n\n/**\n * Constants.\n */\nvar SENTINEL = String.fromCharCode(0);\n\n/**\n * Trie.\n *\n * @constructor\n */\nfunction Trie(Token) {\n  this.mode = Token === Array ? 'array' : 'string';\n  this.clear();\n}\n\n// Re-using TrieMap's prototype\nfor (var methodName in TrieMap.prototype)\n  Trie.prototype[methodName] = TrieMap.prototype[methodName];\n\n// Dropping irrelevant methods\ndelete Trie.prototype.set;\ndelete Trie.prototype.get;\ndelete Trie.prototype.values;\ndelete Trie.prototype.entries;\n\n/**\n * Method used to add the given prefix to the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @return {TrieMap}\n */\nTrie.prototype.add = function(prefix) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n\n    node = node[token] || (node[token] = {});\n  }\n\n  // Do we need to increase size?\n  if (!(SENTINEL in node))\n    this.size++;\n\n  node[SENTINEL] = true;\n\n  return this;\n};\n\n/**\n * Method used to retrieve every item in the trie with the given prefix.\n *\n * @param  {string|array} prefix - Prefix to query.\n * @return {array}\n */\nTrie.prototype.find = function(prefix) {\n  var isString = typeof prefix === 'string';\n\n  var node = this.root,\n      matches = [],\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n\n    if (typeof node === 'undefined')\n      return matches;\n  }\n\n  // Performing DFS from prefix\n  var nodeStack = [node],\n      prefixStack = [prefix],\n      k;\n\n  while (nodeStack.length) {\n    prefix = prefixStack.pop();\n    node = nodeStack.pop();\n\n    for (k in node) {\n      if (k === SENTINEL) {\n        matches.push(prefix);\n        continue;\n      }\n\n      nodeStack.push(node[k]);\n      prefixStack.push(isString ? prefix + k : prefix.concat(k));\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Attaching the #.keys method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  Trie.prototype[Symbol.iterator] = Trie.prototype.keys;\n\n/**\n * Convenience known methods.\n */\nTrie.prototype.inspect = function() {\n  var proxy = new Set();\n\n  var iterator = this.keys(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    proxy.add(step.value);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Trie,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Trie.prototype[Symbol.for('nodejs.util.inspect.custom')] = Trie.prototype.inspect;\n\nTrie.prototype.toJSON = function() {\n  return this.root;\n};\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a trie.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {Trie}\n */\nTrie.from = function(iterable) {\n  var trie = new Trie();\n\n  forEach(iterable, function(value) {\n    trie.add(value);\n  });\n\n  return trie;\n};\n\n/**\n * Exporting.\n */\nTrie.SENTINEL = SENTINEL;\nmodule.exports = Trie;\n"]},"metadata":{},"sourceType":"script"}