{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from 'react';\nimport { ADDITIONAL_BASES, BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants/routing';\nexport function useAllCurrencyCombinations(currencyA, currencyB) {\n  _s();\n\n  const chainId = currencyA === null || currencyA === void 0 ? void 0 : currencyA.chainId;\n  const [tokenA, tokenB] = chainId ? [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped] : [undefined, undefined];\n  const bases = useMemo(() => {\n    var _BASES_TO_CHECK_TRADE, _ADDITIONAL_BASES$cha, _ADDITIONAL_BASES$cha2, _ADDITIONAL_BASES$cha3, _ADDITIONAL_BASES$cha4;\n\n    if (!chainId || chainId !== (tokenB === null || tokenB === void 0 ? void 0 : tokenB.chainId)) return [];\n    const common = (_BASES_TO_CHECK_TRADE = BASES_TO_CHECK_TRADES_AGAINST[chainId]) !== null && _BASES_TO_CHECK_TRADE !== void 0 ? _BASES_TO_CHECK_TRADE : [];\n    const additionalA = tokenA ? (_ADDITIONAL_BASES$cha = (_ADDITIONAL_BASES$cha2 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha2 === void 0 ? void 0 : _ADDITIONAL_BASES$cha2[tokenA.address]) !== null && _ADDITIONAL_BASES$cha !== void 0 ? _ADDITIONAL_BASES$cha : [] : [];\n    const additionalB = tokenB ? (_ADDITIONAL_BASES$cha3 = (_ADDITIONAL_BASES$cha4 = ADDITIONAL_BASES[chainId]) === null || _ADDITIONAL_BASES$cha4 === void 0 ? void 0 : _ADDITIONAL_BASES$cha4[tokenB.address]) !== null && _ADDITIONAL_BASES$cha3 !== void 0 ? _ADDITIONAL_BASES$cha3 : [] : [];\n    return [...common, ...additionalA, ...additionalB];\n  }, [chainId, tokenA, tokenB]);\n  const basePairs = useMemo(() => bases.flatMap(base => bases.map(otherBase => [base, otherBase])) // though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n  .filter(([t0, t1]) => !t0.equals(t1)), [bases]);\n  return useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs] // filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n  .filter(([t0, t1]) => !t0.equals(t1)) // filter out duplicate pairs\n  .filter(([t0, t1], i, otherPairs) => {\n    // find the first index in the array at which there are the same 2 tokens as the current\n    const firstIndexInOtherPairs = otherPairs.findIndex(([t0Other, t1Other]) => {\n      return t0.equals(t0Other) && t1.equals(t1Other) || t0.equals(t1Other) && t1.equals(t0Other);\n    }); // only accept the first occurrence of the same 2 tokens\n\n    return firstIndexInOtherPairs === i;\n  }) // optionally filter out some pairs for tokens with custom bases defined\n  .filter(([tokenA, tokenB]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    const customBasesA = customBases === null || customBases === void 0 ? void 0 : customBases[tokenA.address];\n    const customBasesB = customBases === null || customBases === void 0 ? void 0 : customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n}\n\n_s(useAllCurrencyCombinations, \"9+cy0ZEVvyGXWfwuHjYoZs4R9uY=\");","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useAllCurrencyCombinations.ts"],"names":["useMemo","ADDITIONAL_BASES","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","useAllCurrencyCombinations","currencyA","currencyB","chainId","tokenA","tokenB","wrapped","undefined","bases","common","additionalA","address","additionalB","basePairs","flatMap","base","map","otherBase","filter","t0","t1","equals","i","otherPairs","firstIndexInOtherPairs","findIndex","t0Other","t1Other","customBases","customBasesA","customBasesB","find"],"mappings":"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","sourcesContent":["import { Currency, Token } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\n\nimport { ADDITIONAL_BASES, BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants/routing'\n\nexport function useAllCurrencyCombinations(currencyA?: Currency, currencyB?: Currency): [Token, Token][] {\n  const chainId = currencyA?.chainId\n\n  const [tokenA, tokenB] = chainId ? [currencyA?.wrapped, currencyB?.wrapped] : [undefined, undefined]\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId || chainId !== tokenB?.chainId) return []\n\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\n\n    return [...common, ...additionalA, ...additionalB]\n  }, [chainId, tokenA, tokenB])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      bases\n        .flatMap((base): [Token, Token][] => bases.map((otherBase) => [base, otherBase]))\n        // though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n        .filter(([t0, t1]) => !t0.equals(t1)),\n    [bases]\n  )\n\n  return useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB] as [Token, Token],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            // filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n            .filter(([t0, t1]) => !t0.equals(t1))\n            // filter out duplicate pairs\n            .filter(([t0, t1], i, otherPairs) => {\n              // find the first index in the array at which there are the same 2 tokens as the current\n              const firstIndexInOtherPairs = otherPairs.findIndex(([t0Other, t1Other]) => {\n                return (t0.equals(t0Other) && t1.equals(t1Other)) || (t0.equals(t1Other) && t1.equals(t0Other))\n              })\n              // only accept the first occurrence of the same 2 tokens\n              return firstIndexInOtherPairs === i\n            })\n            // optionally filter out some pairs for tokens with custom bases defined\n            .filter(([tokenA, tokenB]) => {\n              if (!chainId) return true\n              const customBases = CUSTOM_BASES[chainId]\n\n              const customBasesA: Token[] | undefined = customBases?.[tokenA.address]\n              const customBasesB: Token[] | undefined = customBases?.[tokenB.address]\n\n              if (!customBasesA && !customBasesB) return true\n\n              if (customBasesA && !customBasesA.find((base) => tokenB.equals(base))) return false\n              if (customBasesB && !customBasesB.find((base) => tokenA.equals(base))) return false\n\n              return true\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}