{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { updateVersion } from '../global/actions';\nimport { addTransaction, checkedTransaction, clearAllTransactions, finalizeTransaction } from './actions';\n\nconst now = () => new Date().getTime();\n\nexport const initialState = {};\nexport default createReducer(initialState, builder => builder.addCase(updateVersion, transactions => {\n  // in case there are any transactions in the store with the old format, remove them\n  Object.keys(transactions).forEach(chainId => {\n    const chainTransactions = transactions[chainId];\n    Object.keys(chainTransactions).forEach(hash => {\n      if (!('info' in chainTransactions[hash])) {\n        // clear old transactions that don't have the right format\n        delete chainTransactions[hash];\n      }\n    });\n  });\n}).addCase(addTransaction, (transactions, {\n  payload: {\n    chainId,\n    from,\n    hash,\n    info\n  }\n}) => {\n  var _transactions$chainId, _transactions$chainId2;\n\n  if ((_transactions$chainId = transactions[chainId]) === null || _transactions$chainId === void 0 ? void 0 : _transactions$chainId[hash]) {\n    throw Error('Attempted to add existing transaction.');\n  }\n\n  const txs = (_transactions$chainId2 = transactions[chainId]) !== null && _transactions$chainId2 !== void 0 ? _transactions$chainId2 : {};\n  txs[hash] = {\n    hash,\n    info,\n    from,\n    addedTime: now()\n  };\n  transactions[chainId] = txs;\n}).addCase(clearAllTransactions, (transactions, {\n  payload: {\n    chainId\n  }\n}) => {\n  if (!transactions[chainId]) return;\n  transactions[chainId] = {};\n}).addCase(checkedTransaction, (transactions, {\n  payload: {\n    chainId,\n    hash,\n    blockNumber\n  }\n}) => {\n  var _transactions$chainId3;\n\n  const tx = (_transactions$chainId3 = transactions[chainId]) === null || _transactions$chainId3 === void 0 ? void 0 : _transactions$chainId3[hash];\n\n  if (!tx) {\n    return;\n  }\n\n  if (!tx.lastCheckedBlockNumber) {\n    tx.lastCheckedBlockNumber = blockNumber;\n  } else {\n    tx.lastCheckedBlockNumber = Math.max(blockNumber, tx.lastCheckedBlockNumber);\n  }\n}).addCase(finalizeTransaction, (transactions, {\n  payload: {\n    hash,\n    chainId,\n    receipt\n  }\n}) => {\n  var _transactions$chainId4;\n\n  const tx = (_transactions$chainId4 = transactions[chainId]) === null || _transactions$chainId4 === void 0 ? void 0 : _transactions$chainId4[hash];\n\n  if (!tx) {\n    return;\n  }\n\n  tx.receipt = receipt;\n  tx.confirmedTime = now();\n}));","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/transactions/reducer.ts"],"names":["createReducer","updateVersion","addTransaction","checkedTransaction","clearAllTransactions","finalizeTransaction","now","Date","getTime","initialState","builder","addCase","transactions","Object","keys","forEach","chainId","chainTransactions","hash","payload","from","info","Error","txs","addedTime","blockNumber","tx","lastCheckedBlockNumber","Math","max","receipt","confirmedTime"],"mappings":"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","sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\n\nimport { updateVersion } from '../global/actions'\nimport {\n  addTransaction,\n  checkedTransaction,\n  clearAllTransactions,\n  finalizeTransaction,\n  SerializableTransactionReceipt,\n  TransactionInfo,\n} from './actions'\n\nconst now = () => new Date().getTime()\n\nexport interface TransactionDetails {\n  hash: string\n  receipt?: SerializableTransactionReceipt\n  lastCheckedBlockNumber?: number\n  addedTime: number\n  confirmedTime?: number\n  from: string\n  info: TransactionInfo\n}\n\nexport interface TransactionState {\n  [chainId: number]: {\n    [txHash: string]: TransactionDetails\n  }\n}\n\nexport const initialState: TransactionState = {}\n\nexport default createReducer(initialState, (builder) =>\n  builder\n    .addCase(updateVersion, (transactions) => {\n      // in case there are any transactions in the store with the old format, remove them\n      Object.keys(transactions).forEach((chainId) => {\n        const chainTransactions = transactions[chainId as unknown as number]\n        Object.keys(chainTransactions).forEach((hash) => {\n          if (!('info' in chainTransactions[hash])) {\n            // clear old transactions that don't have the right format\n            delete chainTransactions[hash]\n          }\n        })\n      })\n    })\n    .addCase(addTransaction, (transactions, { payload: { chainId, from, hash, info } }) => {\n      if (transactions[chainId]?.[hash]) {\n        throw Error('Attempted to add existing transaction.')\n      }\n      const txs = transactions[chainId] ?? {}\n      txs[hash] = { hash, info, from, addedTime: now() }\n      transactions[chainId] = txs\n    })\n    .addCase(clearAllTransactions, (transactions, { payload: { chainId } }) => {\n      if (!transactions[chainId]) return\n      transactions[chainId] = {}\n    })\n    .addCase(checkedTransaction, (transactions, { payload: { chainId, hash, blockNumber } }) => {\n      const tx = transactions[chainId]?.[hash]\n      if (!tx) {\n        return\n      }\n      if (!tx.lastCheckedBlockNumber) {\n        tx.lastCheckedBlockNumber = blockNumber\n      } else {\n        tx.lastCheckedBlockNumber = Math.max(blockNumber, tx.lastCheckedBlockNumber)\n      }\n    })\n    .addCase(finalizeTransaction, (transactions, { payload: { hash, chainId, receipt } }) => {\n      const tx = transactions[chainId]?.[hash]\n      if (!tx) {\n        return\n      }\n      tx.receipt = receipt\n      tx.confirmedTime = now()\n    })\n)\n"]},"metadata":{},"sourceType":"module"}