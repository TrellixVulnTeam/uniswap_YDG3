{"ast":null,"code":"import { BigNumber } from '@ethersproject/bignumber';\nimport _ from 'lodash';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { IV2GasModelFactory, usdGasTokensByChain } from '../gas-model'; // Constant cost for doing any swap regardless of pools.\n\nconst BASE_SWAP_COST = BigNumber.from(115000); // Constant per extra hop in the route.\n\nconst COST_PER_EXTRA_HOP = BigNumber.from(20000);\n/**\n * Computes a gas estimate for a V2 swap using heuristics.\n * Considers number of hops in the route and the typical base cost for a swap.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * Note, certain tokens e.g. rebasing/fee-on-transfer, may incur higher gas costs than\n * what we estimate here. This is because they run extra logic on token transfer.\n *\n * @export\n * @class V2HeuristicGasModelFactory\n */\n\nexport class V2HeuristicGasModelFactory extends IV2GasModelFactory {\n  constructor() {\n    super();\n  }\n\n  async buildGasModel(chainId, gasPriceWei, poolProvider, token) {\n    if (token.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n      const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n      return {\n        estimateGasCost: routeWithValidQuote => {\n          const {\n            gasCostInEth,\n            gasUse\n          } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n          const ethToken0 = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n          const ethTokenPrice = ethToken0 ? usdPool.token0Price : usdPool.token1Price;\n          const gasCostInTermsOfUSD = ethTokenPrice.quote(gasCostInEth);\n          return {\n            gasEstimate: gasUse,\n            gasCostInToken: gasCostInEth,\n            gasCostInUSD: gasCostInTermsOfUSD\n          };\n        }\n      };\n    } // If the quote token is not WETH, we convert the gas cost to be in terms of the quote token.\n    // We do this by getting the highest liquidity <token>/ETH pool.\n\n\n    const ethPool = await this.getEthPool(chainId, token, poolProvider);\n    const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n    return {\n      estimateGasCost: routeWithValidQuote => {\n        const usdToken = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address ? usdPool.token1 : usdPool.token0;\n        const {\n          gasCostInEth,\n          gasUse\n        } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n\n        if (!ethPool) {\n          log.info('Unable to find ETH pool with the quote token to produce gas adjusted costs. Route will not account for gas.');\n          return {\n            gasEstimate: gasUse,\n            gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n            gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0)\n          };\n        }\n\n        const ethToken0 = ethPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n        const ethTokenPrice = ethToken0 ? ethPool.token0Price : ethPool.token1Price;\n        let gasCostInTermsOfQuoteToken;\n\n        try {\n          gasCostInTermsOfQuoteToken = ethTokenPrice.quote(gasCostInEth);\n        } catch (err) {\n          log.error({\n            ethTokenPriceBase: ethTokenPrice.baseCurrency,\n            ethTokenPriceQuote: ethTokenPrice.quoteCurrency,\n            gasCostInEth: gasCostInEth.currency\n          }, 'Debug eth price token issue');\n          throw err;\n        }\n\n        const ethToken0USDPool = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n        const ethTokenPriceUSDPool = ethToken0USDPool ? usdPool.token0Price : usdPool.token1Price;\n        let gasCostInTermsOfUSD;\n\n        try {\n          gasCostInTermsOfUSD = ethTokenPriceUSDPool.quote(gasCostInEth);\n        } catch (err) {\n          log.error({\n            usdT1: usdPool.token0.symbol,\n            usdT2: usdPool.token1.symbol,\n            gasCostInEthToken: gasCostInEth.currency.symbol\n          }, 'Failed to compute USD gas price');\n          throw err;\n        }\n\n        return {\n          gasEstimate: gasUse,\n          gasCostInToken: gasCostInTermsOfQuoteToken,\n          gasCostInUSD: gasCostInTermsOfUSD\n        };\n      }\n    };\n  }\n\n  estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n    const hops = routeWithValidQuote.route.pairs.length;\n    const gasUse = BASE_SWAP_COST.add(COST_PER_EXTRA_HOP.mul(hops - 1));\n    const totalGasCostWei = gasPriceWei.mul(gasUse);\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n    const gasCostInEth = CurrencyAmount.fromRawAmount(weth, totalGasCostWei.toString());\n    return {\n      gasCostInEth,\n      gasUse\n    };\n  }\n\n  async getEthPool(chainId, token, poolProvider) {\n    const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n    const poolAccessor = await poolProvider.getPools([[weth, token]]);\n    const pool = poolAccessor.getPool(weth, token);\n\n    if (!pool) {\n      log.error({\n        weth,\n        token\n      }, `Could not find a WETH pool with ${token.symbol} for computing gas costs.`);\n      return null;\n    }\n\n    return pool;\n  }\n\n  async getHighestLiquidityUSDPool(chainId, poolProvider) {\n    const usdTokens = usdGasTokensByChain[chainId];\n\n    if (!usdTokens) {\n      throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n    }\n\n    const usdPools = _.map(usdTokens, usdToken => [usdToken, WRAPPED_NATIVE_CURRENCY[chainId]]);\n\n    const poolAccessor = await poolProvider.getPools(usdPools);\n    const pools = poolAccessor.getAllPools();\n\n    if (pools.length == 0) {\n      log.error({\n        pools\n      }, `Could not find a USD/WETH pool for computing gas costs.`);\n      throw new Error(`Can't find USD/WETH pool for computing gas costs.`);\n    }\n\n    const maxPool = _.maxBy(pools, pool => {\n      if (pool.token0.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n        return parseFloat(pool.reserve0.toSignificant(2));\n      } else {\n        return parseFloat(pool.reserve1.toSignificant(2));\n      }\n    });\n\n    return maxPool;\n  }\n\n}","map":{"version":3,"sources":["../../../../../../../src/routers/alpha-router/gas-models/v2/v2-heuristic-gas-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BigNumber } from '@ethersproject/bignumber';\nimport _ from 'lodash';\nimport { log, WRAPPED_NATIVE_CURRENCY } from '../../../../util';\nimport { CurrencyAmount } from '../../../../util/amounts';\nimport { IV2GasModelFactory, usdGasTokensByChain, } from '../gas-model';\n// Constant cost for doing any swap regardless of pools.\nconst BASE_SWAP_COST = BigNumber.from(115000);\n// Constant per extra hop in the route.\nconst COST_PER_EXTRA_HOP = BigNumber.from(20000);\n/**\n * Computes a gas estimate for a V2 swap using heuristics.\n * Considers number of hops in the route and the typical base cost for a swap.\n *\n * We compute gas estimates off-chain because\n *  1/ Calling eth_estimateGas for a swaps requires the caller to have\n *     the full balance token being swapped, and approvals.\n *  2/ Tracking gas used using a wrapper contract is not accurate with Multicall\n *     due to EIP-2929. We would have to make a request for every swap we wanted to estimate.\n *  3/ For V2 we simulate all our swaps off-chain so have no way to track gas used.\n *\n * Note, certain tokens e.g. rebasing/fee-on-transfer, may incur higher gas costs than\n * what we estimate here. This is because they run extra logic on token transfer.\n *\n * @export\n * @class V2HeuristicGasModelFactory\n */\nexport class V2HeuristicGasModelFactory extends IV2GasModelFactory {\n    constructor() {\n        super();\n    }\n    async buildGasModel(chainId, gasPriceWei, poolProvider, token) {\n        if (token.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n            const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n            return {\n                estimateGasCost: (routeWithValidQuote) => {\n                    const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                    const ethToken0 = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                    const ethTokenPrice = ethToken0\n                        ? usdPool.token0Price\n                        : usdPool.token1Price;\n                    const gasCostInTermsOfUSD = ethTokenPrice.quote(gasCostInEth);\n                    return {\n                        gasEstimate: gasUse,\n                        gasCostInToken: gasCostInEth,\n                        gasCostInUSD: gasCostInTermsOfUSD,\n                    };\n                },\n            };\n        }\n        // If the quote token is not WETH, we convert the gas cost to be in terms of the quote token.\n        // We do this by getting the highest liquidity <token>/ETH pool.\n        const ethPool = await this.getEthPool(chainId, token, poolProvider);\n        const usdPool = await this.getHighestLiquidityUSDPool(chainId, poolProvider);\n        return {\n            estimateGasCost: (routeWithValidQuote) => {\n                const usdToken = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address\n                    ? usdPool.token1\n                    : usdPool.token0;\n                const { gasCostInEth, gasUse } = this.estimateGas(routeWithValidQuote, gasPriceWei, chainId);\n                if (!ethPool) {\n                    log.info('Unable to find ETH pool with the quote token to produce gas adjusted costs. Route will not account for gas.');\n                    return {\n                        gasEstimate: gasUse,\n                        gasCostInToken: CurrencyAmount.fromRawAmount(token, 0),\n                        gasCostInUSD: CurrencyAmount.fromRawAmount(usdToken, 0),\n                    };\n                }\n                const ethToken0 = ethPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                const ethTokenPrice = ethToken0\n                    ? ethPool.token0Price\n                    : ethPool.token1Price;\n                let gasCostInTermsOfQuoteToken;\n                try {\n                    gasCostInTermsOfQuoteToken = ethTokenPrice.quote(gasCostInEth);\n                }\n                catch (err) {\n                    log.error({\n                        ethTokenPriceBase: ethTokenPrice.baseCurrency,\n                        ethTokenPriceQuote: ethTokenPrice.quoteCurrency,\n                        gasCostInEth: gasCostInEth.currency,\n                    }, 'Debug eth price token issue');\n                    throw err;\n                }\n                const ethToken0USDPool = usdPool.token0.address == WRAPPED_NATIVE_CURRENCY[chainId].address;\n                const ethTokenPriceUSDPool = ethToken0USDPool\n                    ? usdPool.token0Price\n                    : usdPool.token1Price;\n                let gasCostInTermsOfUSD;\n                try {\n                    gasCostInTermsOfUSD = ethTokenPriceUSDPool.quote(gasCostInEth);\n                }\n                catch (err) {\n                    log.error({\n                        usdT1: usdPool.token0.symbol,\n                        usdT2: usdPool.token1.symbol,\n                        gasCostInEthToken: gasCostInEth.currency.symbol,\n                    }, 'Failed to compute USD gas price');\n                    throw err;\n                }\n                return {\n                    gasEstimate: gasUse,\n                    gasCostInToken: gasCostInTermsOfQuoteToken,\n                    gasCostInUSD: gasCostInTermsOfUSD,\n                };\n            },\n        };\n    }\n    estimateGas(routeWithValidQuote, gasPriceWei, chainId) {\n        const hops = routeWithValidQuote.route.pairs.length;\n        const gasUse = BASE_SWAP_COST.add(COST_PER_EXTRA_HOP.mul(hops - 1));\n        const totalGasCostWei = gasPriceWei.mul(gasUse);\n        const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n        const gasCostInEth = CurrencyAmount.fromRawAmount(weth, totalGasCostWei.toString());\n        return { gasCostInEth, gasUse };\n    }\n    async getEthPool(chainId, token, poolProvider) {\n        const weth = WRAPPED_NATIVE_CURRENCY[chainId];\n        const poolAccessor = await poolProvider.getPools([[weth, token]]);\n        const pool = poolAccessor.getPool(weth, token);\n        if (!pool) {\n            log.error({ weth, token }, `Could not find a WETH pool with ${token.symbol} for computing gas costs.`);\n            return null;\n        }\n        return pool;\n    }\n    async getHighestLiquidityUSDPool(chainId, poolProvider) {\n        const usdTokens = usdGasTokensByChain[chainId];\n        if (!usdTokens) {\n            throw new Error(`Could not find a USD token for computing gas costs on ${chainId}`);\n        }\n        const usdPools = _.map(usdTokens, (usdToken) => [\n            usdToken,\n            WRAPPED_NATIVE_CURRENCY[chainId],\n        ]);\n        const poolAccessor = await poolProvider.getPools(usdPools);\n        const pools = poolAccessor.getAllPools();\n        if (pools.length == 0) {\n            log.error({ pools }, `Could not find a USD/WETH pool for computing gas costs.`);\n            throw new Error(`Can't find USD/WETH pool for computing gas costs.`);\n        }\n        const maxPool = _.maxBy(pools, (pool) => {\n            if (pool.token0.equals(WRAPPED_NATIVE_CURRENCY[chainId])) {\n                return parseFloat(pool.reserve0.toSignificant(2));\n            }\n            else {\n                return parseFloat(pool.reserve1.toSignificant(2));\n            }\n        });\n        return maxPool;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidjItaGV1cmlzdGljLWdhcy1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9yb3V0ZXJzL2FscGhhLXJvdXRlci9nYXMtbW9kZWxzL3YyL3YyLWhldXJpc3RpYy1nYXMtbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBR3JELE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUV2QixPQUFPLEVBQVcsR0FBRyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDekUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTFELE9BQU8sRUFFTCxrQkFBa0IsRUFDbEIsbUJBQW1CLEdBQ3BCLE1BQU0sY0FBYyxDQUFDO0FBRXRCLHdEQUF3RDtBQUN4RCxNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBRTlDLHVDQUF1QztBQUN2QyxNQUFNLGtCQUFrQixHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFakQ7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsa0JBQWtCO0lBQ2hFO1FBQ0UsS0FBSyxFQUFFLENBQUM7SUFDVixDQUFDO0lBRU0sS0FBSyxDQUFDLGFBQWEsQ0FDeEIsT0FBZ0IsRUFDaEIsV0FBc0IsRUFDdEIsWUFBNkIsRUFDN0IsS0FBWTtRQUVaLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUUsQ0FBQyxFQUFFO1lBQ25ELE1BQU0sT0FBTyxHQUFTLE1BQU0sSUFBSSxDQUFDLDBCQUEwQixDQUN6RCxPQUFPLEVBQ1AsWUFBWSxDQUNiLENBQUM7WUFFRixPQUFPO2dCQUNMLGVBQWUsRUFBRSxDQUFDLG1CQUEwQyxFQUFFLEVB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"]},"metadata":{},"sourceType":"module"}