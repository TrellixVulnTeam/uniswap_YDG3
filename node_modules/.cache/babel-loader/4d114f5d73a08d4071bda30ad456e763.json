{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { Route } from '@uniswap/v3-sdk';\nimport { useMemo } from 'react';\nimport { useV3SwapPools } from './useV3SwapPools';\nimport { useActiveWeb3React } from './web3';\n/**\n * Returns true if poolA is equivalent to poolB\n * @param poolA one of the two pools\n * @param poolB the other pool\n */\n\nfunction poolEquals(poolA, poolB) {\n  return poolA === poolB || poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1) && poolA.fee === poolB.fee;\n}\n\nfunction computeAllRoutes(currencyIn, currencyOut, pools, chainId, currentPath = [], allPaths = [], startCurrencyIn = currencyIn, maxHops = 2) {\n  const tokenIn = currencyIn === null || currencyIn === void 0 ? void 0 : currencyIn.wrapped;\n  const tokenOut = currencyOut === null || currencyOut === void 0 ? void 0 : currencyOut.wrapped;\n  if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut');\n\n  for (const pool of pools) {\n    if (!pool.involvesToken(tokenIn) || currentPath.find(pathPool => poolEquals(pool, pathPool))) continue;\n    const outputToken = pool.token0.equals(tokenIn) ? pool.token1 : pool.token0;\n\n    if (outputToken.equals(tokenOut)) {\n      allPaths.push(new Route([...currentPath, pool], startCurrencyIn, currencyOut));\n    } else if (maxHops > 1) {\n      computeAllRoutes(outputToken, currencyOut, pools, chainId, [...currentPath, pool], allPaths, startCurrencyIn, maxHops - 1);\n    }\n  }\n\n  return allPaths;\n}\n/**\n * Returns all the routes from an input currency to an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\n\n\nexport function useAllV3Routes(currencyIn, currencyOut) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const {\n    pools,\n    loading: poolsLoading\n  } = useV3SwapPools(currencyIn, currencyOut);\n  return useMemo(() => {\n    if (poolsLoading || !chainId || !pools || !currencyIn || !currencyOut) return {\n      loading: true,\n      routes: []\n    };\n    const routes = computeAllRoutes(currencyIn, currencyOut, pools, chainId, [], [], currencyIn, 2);\n    return {\n      loading: false,\n      routes\n    };\n  }, [chainId, currencyIn, currencyOut, pools, poolsLoading]);\n}\n\n_s(useAllV3Routes, \"CKqU+FpEsgNZSIhPU+j0vVNbiI8=\", false, function () {\n  return [useActiveWeb3React, useV3SwapPools];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useAllV3Routes.ts"],"names":["Route","useMemo","useV3SwapPools","useActiveWeb3React","poolEquals","poolA","poolB","token0","equals","token1","fee","computeAllRoutes","currencyIn","currencyOut","pools","chainId","currentPath","allPaths","startCurrencyIn","maxHops","tokenIn","wrapped","tokenOut","Error","pool","involvesToken","find","pathPool","outputToken","push","useAllV3Routes","loading","poolsLoading","routes"],"mappings":"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","sourcesContent":["import { Currency } from '@uniswap/sdk-core'\nimport { Pool, Route } from '@uniswap/v3-sdk'\nimport { useMemo } from 'react'\n\nimport { useV3SwapPools } from './useV3SwapPools'\nimport { useActiveWeb3React } from './web3'\n\n/**\n * Returns true if poolA is equivalent to poolB\n * @param poolA one of the two pools\n * @param poolB the other pool\n */\nfunction poolEquals(poolA: Pool, poolB: Pool): boolean {\n  return (\n    poolA === poolB ||\n    (poolA.token0.equals(poolB.token0) && poolA.token1.equals(poolB.token1) && poolA.fee === poolB.fee)\n  )\n}\n\nfunction computeAllRoutes(\n  currencyIn: Currency,\n  currencyOut: Currency,\n  pools: Pool[],\n  chainId: number,\n  currentPath: Pool[] = [],\n  allPaths: Route<Currency, Currency>[] = [],\n  startCurrencyIn: Currency = currencyIn,\n  maxHops = 2\n): Route<Currency, Currency>[] {\n  const tokenIn = currencyIn?.wrapped\n  const tokenOut = currencyOut?.wrapped\n  if (!tokenIn || !tokenOut) throw new Error('Missing tokenIn/tokenOut')\n\n  for (const pool of pools) {\n    if (!pool.involvesToken(tokenIn) || currentPath.find((pathPool) => poolEquals(pool, pathPool))) continue\n\n    const outputToken = pool.token0.equals(tokenIn) ? pool.token1 : pool.token0\n    if (outputToken.equals(tokenOut)) {\n      allPaths.push(new Route([...currentPath, pool], startCurrencyIn, currencyOut))\n    } else if (maxHops > 1) {\n      computeAllRoutes(\n        outputToken,\n        currencyOut,\n        pools,\n        chainId,\n        [...currentPath, pool],\n        allPaths,\n        startCurrencyIn,\n        maxHops - 1\n      )\n    }\n  }\n\n  return allPaths\n}\n\n/**\n * Returns all the routes from an input currency to an output currency\n * @param currencyIn the input currency\n * @param currencyOut the output currency\n */\nexport function useAllV3Routes(\n  currencyIn?: Currency,\n  currencyOut?: Currency\n): { loading: boolean; routes: Route<Currency, Currency>[] } {\n  const { chainId } = useActiveWeb3React()\n  const { pools, loading: poolsLoading } = useV3SwapPools(currencyIn, currencyOut)\n\n  return useMemo(() => {\n    if (poolsLoading || !chainId || !pools || !currencyIn || !currencyOut) return { loading: true, routes: [] }\n\n    const routes = computeAllRoutes(currencyIn, currencyOut, pools, chainId, [], [], currencyIn, 2)\n    return { loading: false, routes }\n  }, [chainId, currencyIn, currencyOut, pools, poolsLoading])\n}\n"]},"metadata":{},"sourceType":"module"}