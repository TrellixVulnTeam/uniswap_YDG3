{"ast":null,"code":"/**\n * Mnemonist Bloom Filter\n * =======================\n *\n * Bloom Filter implementation relying on MurmurHash3.\n */\nvar murmurhash3 = require('./utils/murmurhash3.js'),\n    forEach = require('obliterator/foreach');\n/**\n * Constants.\n */\n\n\nvar LN2_SQUARED = Math.LN2 * Math.LN2;\n/**\n * Defaults.\n */\n\nvar DEFAULTS = {\n  errorRate: 0.005\n};\n/**\n * Function used to convert a string into a Uint16 byte array.\n *\n * @param  {string}      string - Target string.\n * @return {Uint16Array}\n */\n\nfunction stringToByteArray(string) {\n  var array = new Uint16Array(string.length),\n      i,\n      l;\n\n  for (i = 0, l = string.length; i < l; i++) array[i] = string.charCodeAt(i);\n\n  return array;\n}\n/**\n * Function used to hash the given byte array.\n *\n * @param  {number}      length - Length of the filter's byte array.\n * @param  {number}      seed   - Seed to use for the hash function.\n * @param  {Uint16Array}        - Byte array representing the string.\n * @return {number}             - The hash.\n *\n * @note length * 8 should probably already be computed as well as seeds.\n */\n\n\nfunction hashArray(length, seed, array) {\n  var hash = murmurhash3(seed * 0xFBA4C795 & 0xFFFFFFFF, array);\n  return hash % (length * 8);\n}\n/**\n * Bloom Filter.\n *\n * @constructor\n * @param {number|object} capacityOrOptions - Capacity or options.\n */\n\n\nfunction BloomFilter(capacityOrOptions) {\n  var options = {};\n  if (!capacityOrOptions) throw new Error('mnemonist/BloomFilter.constructor: a BloomFilter must be created with a capacity.');\n  if (typeof capacityOrOptions === 'object') options = capacityOrOptions;else options.capacity = capacityOrOptions; // Handling capacity\n\n  if (typeof options.capacity !== 'number' || options.capacity <= 0) throw new Error('mnemonist/BloomFilter.constructor: `capacity` option should be a positive integer.');\n  this.capacity = options.capacity; // Handling error rate\n\n  this.errorRate = options.errorRate || DEFAULTS.errorRate;\n  if (typeof this.errorRate !== 'number' || options.errorRate <= 0) throw new Error('mnemonist/BloomFilter.constructor: `errorRate` option should be a positive float.');\n  this.clear();\n}\n/**\n * Method used to clear the filter.\n *\n * @return {undefined}\n */\n\n\nBloomFilter.prototype.clear = function () {\n  // Optimizing number of bits & number of hash functions\n  var bits = -1 / LN2_SQUARED * this.capacity * Math.log(this.errorRate),\n      length = bits / 8 | 0;\n  this.hashFunctions = length * 8 / this.capacity * Math.LN2 | 0; // Creating the data array\n\n  this.data = new Uint8Array(length);\n  return;\n};\n/**\n * Method used to add an string to the filter.\n *\n * @param  {string} string - Item to add.\n * @return {BloomFilter}\n *\n * @note Should probably create a hash function working directly on a string.\n */\n\n\nBloomFilter.prototype.add = function (string) {\n  // Converting the string to a byte array\n  var array = stringToByteArray(string); // Applying the n hash functions\n\n  for (var i = 0, l = this.hashFunctions; i < l; i++) {\n    var index = hashArray(this.data.length, i, array),\n        position = 1 << (7 & index);\n    this.data[index >> 3] |= position;\n  }\n\n  return this;\n};\n/**\n * Method used to test the given string.\n *\n * @param  {string} string - Item to test.\n * @return {boolean}\n */\n\n\nBloomFilter.prototype.test = function (string) {\n  // Converting the string to a byte array\n  var array = stringToByteArray(string); // Applying the n hash functions\n\n  for (var i = 0, l = this.hashFunctions; i < l; i++) {\n    var index = hashArray(this.data.length, i, array);\n    if (!(this.data[index >> 3] & 1 << (7 & index))) return false;\n  }\n\n  return true;\n};\n/**\n * Convenience known methods.\n */\n\n\nBloomFilter.prototype.toJSON = function () {\n  return this.data;\n};\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a filter.\n *\n * @param  {Iterable}    iterable - Target iterable.\n * @return {BloomFilter}\n */\n\n\nBloomFilter.from = function (iterable, options) {\n  if (!options) {\n    options = iterable.length || iterable.size;\n    if (typeof options !== 'number') throw new Error('BloomFilter.from: could not infer the filter\\'s capacity. Try passing it as second argument.');\n  }\n\n  var filter = new BloomFilter(options);\n  forEach(iterable, function (value) {\n    filter.add(value);\n  });\n  return filter;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = BloomFilter;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/bloom-filter.js"],"names":["murmurhash3","require","forEach","LN2_SQUARED","Math","LN2","DEFAULTS","errorRate","stringToByteArray","string","array","Uint16Array","length","i","l","charCodeAt","hashArray","seed","hash","BloomFilter","capacityOrOptions","options","Error","capacity","clear","prototype","bits","log","hashFunctions","data","Uint8Array","add","index","position","test","toJSON","from","iterable","size","filter","value","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Bloom Filter\n * =======================\n *\n * Bloom Filter implementation relying on MurmurHash3.\n */\nvar murmurhash3 = require('./utils/murmurhash3.js'),\n    forEach = require('obliterator/foreach');\n\n/**\n * Constants.\n */\nvar LN2_SQUARED = Math.LN2 * Math.LN2;\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  errorRate: 0.005\n};\n\n/**\n * Function used to convert a string into a Uint16 byte array.\n *\n * @param  {string}      string - Target string.\n * @return {Uint16Array}\n */\nfunction stringToByteArray(string) {\n  var array = new Uint16Array(string.length),\n      i,\n      l;\n\n  for (i = 0, l = string.length; i < l; i++)\n    array[i] = string.charCodeAt(i);\n\n  return array;\n}\n\n/**\n * Function used to hash the given byte array.\n *\n * @param  {number}      length - Length of the filter's byte array.\n * @param  {number}      seed   - Seed to use for the hash function.\n * @param  {Uint16Array}        - Byte array representing the string.\n * @return {number}             - The hash.\n *\n * @note length * 8 should probably already be computed as well as seeds.\n */\nfunction hashArray(length, seed, array) {\n  var hash = murmurhash3((seed * 0xFBA4C795) & 0xFFFFFFFF, array);\n\n  return hash % (length * 8);\n}\n\n/**\n * Bloom Filter.\n *\n * @constructor\n * @param {number|object} capacityOrOptions - Capacity or options.\n */\nfunction BloomFilter(capacityOrOptions) {\n  var options = {};\n\n  if (!capacityOrOptions)\n    throw new Error('mnemonist/BloomFilter.constructor: a BloomFilter must be created with a capacity.');\n\n  if (typeof capacityOrOptions === 'object')\n    options = capacityOrOptions;\n  else\n    options.capacity = capacityOrOptions;\n\n  // Handling capacity\n  if (typeof options.capacity !== 'number' || options.capacity <= 0)\n    throw new Error('mnemonist/BloomFilter.constructor: `capacity` option should be a positive integer.');\n\n  this.capacity = options.capacity;\n\n  // Handling error rate\n  this.errorRate = options.errorRate || DEFAULTS.errorRate;\n\n  if (typeof this.errorRate !== 'number' || options.errorRate <= 0)\n    throw new Error('mnemonist/BloomFilter.constructor: `errorRate` option should be a positive float.');\n\n  this.clear();\n}\n\n/**\n * Method used to clear the filter.\n *\n * @return {undefined}\n */\nBloomFilter.prototype.clear = function() {\n\n  // Optimizing number of bits & number of hash functions\n  var bits = -1 / LN2_SQUARED * this.capacity * Math.log(this.errorRate),\n      length = (bits / 8) | 0;\n\n  this.hashFunctions = (length * 8 / this.capacity * Math.LN2) | 0;\n\n  // Creating the data array\n  this.data = new Uint8Array(length);\n\n  return;\n};\n\n/**\n * Method used to add an string to the filter.\n *\n * @param  {string} string - Item to add.\n * @return {BloomFilter}\n *\n * @note Should probably create a hash function working directly on a string.\n */\nBloomFilter.prototype.add = function(string) {\n\n  // Converting the string to a byte array\n  var array = stringToByteArray(string);\n\n  // Applying the n hash functions\n  for (var i = 0, l = this.hashFunctions; i < l; i++) {\n    var index = hashArray(this.data.length, i, array),\n        position = (1 << (7 & index));\n\n    this.data[index >> 3] |= position;\n  }\n\n  return this;\n};\n\n/**\n * Method used to test the given string.\n *\n * @param  {string} string - Item to test.\n * @return {boolean}\n */\nBloomFilter.prototype.test = function(string) {\n\n  // Converting the string to a byte array\n  var array = stringToByteArray(string);\n\n  // Applying the n hash functions\n  for (var i = 0, l = this.hashFunctions; i < l; i++) {\n    var index = hashArray(this.data.length, i, array);\n\n    if (!(this.data[index >> 3] & (1 << (7 & index))))\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Convenience known methods.\n */\nBloomFilter.prototype.toJSON = function() {\n  return this.data;\n};\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a filter.\n *\n * @param  {Iterable}    iterable - Target iterable.\n * @return {BloomFilter}\n */\nBloomFilter.from = function(iterable, options) {\n  if (!options) {\n    options = iterable.length || iterable.size;\n\n    if (typeof options !== 'number')\n      throw new Error('BloomFilter.from: could not infer the filter\\'s capacity. Try passing it as second argument.');\n  }\n\n  var filter = new BloomFilter(options);\n\n  forEach(iterable, function(value) {\n    filter.add(value);\n  });\n\n  return filter;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = BloomFilter;\n"]},"metadata":{},"sourceType":"script"}