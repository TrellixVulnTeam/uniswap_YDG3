{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { Trans } from \"@lingui/react\";\nimport { Interface } from '@ethersproject/abi';\nimport { abi as STAKING_REWARDS_ABI } from '@uniswap/liquidity-staker/build/StakingRewards.json';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport { Pair } from '@uniswap/v2-sdk';\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp';\nimport JSBI from 'jsbi';\nimport { useMemo } from 'react';\nimport { DAI, UNI, USDC, USDT, WBTC, WRAPPED_NATIVE_CURRENCY } from '../../constants/tokens';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { NEVER_RELOAD, useMultipleContractSingleData } from '../multicall/hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst STAKING_REWARDS_INTERFACE = new Interface(STAKING_REWARDS_ABI);\nexport const STAKING_GENESIS = 1600387200;\nexport const REWARDS_DURATION_DAYS = 60;\nexport const STAKING_REWARDS_INFO = {\n  1: [{\n    tokens: [WRAPPED_NATIVE_CURRENCY[1], DAI],\n    stakingRewardAddress: '0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[1], USDC],\n    stakingRewardAddress: '0x7FBa4B8Dc5E7616e59622806932DBea72537A56b'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[1], USDT],\n    stakingRewardAddress: '0x6C3e4cb2E96B01F4b866965A91ed4437839A121a'\n  }, {\n    tokens: [WRAPPED_NATIVE_CURRENCY[1], WBTC],\n    stakingRewardAddress: '0xCA35e32e7926b96A9988f61d510E038108d8068e'\n  }]\n};\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy) {\n  _s();\n\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React(); // detect if staking is ended\n\n  const currentBlockTimestamp = useCurrentBlockTimestamp();\n  const info = useMemo(() => {\n    var _STAKING_REWARDS_INFO, _STAKING_REWARDS_INFO2;\n\n    return chainId ? (_STAKING_REWARDS_INFO = (_STAKING_REWARDS_INFO2 = STAKING_REWARDS_INFO[chainId]) === null || _STAKING_REWARDS_INFO2 === void 0 ? void 0 : _STAKING_REWARDS_INFO2.filter(stakingRewardInfo => pairToFilterBy === undefined ? true : pairToFilterBy === null ? false : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]))) !== null && _STAKING_REWARDS_INFO !== void 0 ? _STAKING_REWARDS_INFO : [] : [];\n  }, [chainId, pairToFilterBy]);\n  const uni = chainId ? UNI[chainId] : undefined;\n  const rewardsAddresses = useMemo(() => info.map(({\n    stakingRewardAddress\n  }) => stakingRewardAddress), [info]);\n  const accountArg = useMemo(() => [account !== null && account !== void 0 ? account : undefined], [account]); // get all the info from the staking rewards contracts\n\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply'); // tokens per second, constants\n\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (!chainId || !uni) return [];\n    return rewardsAddresses.reduce((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index]; // these get fetched regardless of account\n\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const periodFinishState = periodFinishes[index];\n\n      if ( // these may be undefined if not logged in\n      !(balanceState === null || balanceState === void 0 ? void 0 : balanceState.loading) && !(earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.loading) && // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading && periodFinishState && !periodFinishState.loading) {\n        var _balanceState$result$, _balanceState$result, _totalSupplyState$res, _rewardRateState$resu, _periodFinishState$re, _periodFinishState$re2, _earnedAmountState$re, _earnedAmountState$re2;\n\n        if ((balanceState === null || balanceState === void 0 ? void 0 : balanceState.error) || (earnedAmountState === null || earnedAmountState === void 0 ? void 0 : earnedAmountState.error) || totalSupplyState.error || rewardRateState.error || periodFinishState.error) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        } // get the LP token\n\n\n        const tokens = info[index].tokens;\n        const dummyPair = new Pair(CurrencyAmount.fromRawAmount(tokens[0], '0'), CurrencyAmount.fromRawAmount(tokens[1], '0')); // check for account, if no account set to 0\n\n        const stakedAmount = CurrencyAmount.fromRawAmount(dummyPair.liquidityToken, JSBI.BigInt((_balanceState$result$ = balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result = balanceState.result) === null || _balanceState$result === void 0 ? void 0 : _balanceState$result[0]) !== null && _balanceState$result$ !== void 0 ? _balanceState$result$ : 0));\n        const totalStakedAmount = CurrencyAmount.fromRawAmount(dummyPair.liquidityToken, JSBI.BigInt((_totalSupplyState$res = totalSupplyState.result) === null || _totalSupplyState$res === void 0 ? void 0 : _totalSupplyState$res[0]));\n        const totalRewardRate = CurrencyAmount.fromRawAmount(uni, JSBI.BigInt((_rewardRateState$resu = rewardRateState.result) === null || _rewardRateState$resu === void 0 ? void 0 : _rewardRateState$resu[0]));\n\n        const getHypotheticalRewardRate = (stakedAmount, totalStakedAmount, totalRewardRate) => {\n          return CurrencyAmount.fromRawAmount(uni, JSBI.greaterThan(totalStakedAmount.quotient, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(totalRewardRate.quotient, stakedAmount.quotient), totalStakedAmount.quotient) : JSBI.BigInt(0));\n        };\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, totalRewardRate);\n        const periodFinishSeconds = (_periodFinishState$re = periodFinishState.result) === null || _periodFinishState$re === void 0 ? void 0 : (_periodFinishState$re2 = _periodFinishState$re[0]) === null || _periodFinishState$re2 === void 0 ? void 0 : _periodFinishState$re2.toNumber();\n        const periodFinishMs = periodFinishSeconds * 1000; // compare period end timestamp vs current block timestamp (in seconds)\n\n        const active = periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : true;\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: info[index].tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          earnedAmount: CurrencyAmount.fromRawAmount(uni, JSBI.BigInt((_earnedAmountState$re = earnedAmountState === null || earnedAmountState === void 0 ? void 0 : (_earnedAmountState$re2 = earnedAmountState.result) === null || _earnedAmountState$re2 === void 0 ? void 0 : _earnedAmountState$re2[0]) !== null && _earnedAmountState$re !== void 0 ? _earnedAmountState$re : 0)),\n          rewardRate: individualRewardRate,\n          totalRewardRate,\n          stakedAmount,\n          totalStakedAmount,\n          getHypotheticalRewardRate,\n          active\n        });\n      }\n\n      return memo;\n    }, []);\n  }, [balances, chainId, currentBlockTimestamp, earnedAmounts, info, periodFinishes, rewardRates, rewardsAddresses, totalSupplies, uni]);\n}\n\n_s(useStakingInfo, \"AQQJ3p899cWqZLKMAsfbq7mseLo=\", false, function () {\n  return [useActiveWeb3React, useCurrentBlockTimestamp, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData];\n});\n\nexport function useTotalUniEarned() {\n  _s2();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const uni = chainId ? UNI[chainId] : undefined;\n  const stakingInfos = useStakingInfo();\n  return useMemo(() => {\n    var _stakingInfos$reduce;\n\n    if (!uni) return undefined;\n    return (_stakingInfos$reduce = stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.reduce((accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount), CurrencyAmount.fromRawAmount(uni, '0'))) !== null && _stakingInfos$reduce !== void 0 ? _stakingInfos$reduce : CurrencyAmount.fromRawAmount(uni, '0');\n  }, [stakingInfos, uni]);\n} // based on typed value\n\n_s2(useTotalUniEarned, \"ne0sqTEC8cSF4yDqUF4Xdz4iTEo=\", false, function () {\n  return [useActiveWeb3React, useStakingInfo];\n});\n\nexport function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  _s3();\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const parsedInput = tryParseAmount(typedValue, stakingToken);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.quotient, userLiquidityUnstaked.quotient) ? parsedInput : undefined;\n  let error;\n\n  if (!account) {\n    error = /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Connect Wallet\"\n    }, void 0, false, void 0, this);\n  }\n\n  if (!parsedAmount) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : /*#__PURE__*/_jsxDEV(Trans, {\n      id: \"Enter an amount\"\n    }, void 0, false, void 0, this);\n  }\n\n  return {\n    parsedAmount,\n    error\n  };\n}\n\n_s3(useDerivedStakeInfo, \"SBDWLFuvTxBgnBUfJpXeYDOlPck=\", false, function () {\n  return [useActiveWeb3React];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/stake/hooks.tsx"],"names":["Interface","abi","STAKING_REWARDS_ABI","CurrencyAmount","Pair","useCurrentBlockTimestamp","JSBI","useMemo","DAI","UNI","USDC","USDT","WBTC","WRAPPED_NATIVE_CURRENCY","useActiveWeb3React","NEVER_RELOAD","useMultipleContractSingleData","tryParseAmount","STAKING_REWARDS_INTERFACE","STAKING_GENESIS","REWARDS_DURATION_DAYS","STAKING_REWARDS_INFO","tokens","stakingRewardAddress","useStakingInfo","pairToFilterBy","chainId","account","currentBlockTimestamp","info","filter","stakingRewardInfo","undefined","involvesToken","uni","rewardsAddresses","map","accountArg","balances","earnedAmounts","totalSupplies","rewardRates","periodFinishes","reduce","memo","rewardsAddress","index","balanceState","earnedAmountState","totalSupplyState","rewardRateState","periodFinishState","loading","error","console","dummyPair","fromRawAmount","stakedAmount","liquidityToken","BigInt","result","totalStakedAmount","totalRewardRate","getHypotheticalRewardRate","greaterThan","quotient","divide","multiply","individualRewardRate","periodFinishSeconds","toNumber","periodFinishMs","active","push","periodFinish","Date","earnedAmount","rewardRate","useTotalUniEarned","stakingInfos","accumulator","stakingInfo","add","useDerivedStakeInfo","typedValue","stakingToken","userLiquidityUnstaked","parsedInput","parsedAmount","lessThanOrEqual"],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { Trans } from '@lingui/macro'\nimport { abi as STAKING_REWARDS_ABI } from '@uniswap/liquidity-staker/build/StakingRewards.json'\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport { Pair } from '@uniswap/v2-sdk'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport JSBI from 'jsbi'\nimport { ReactNode, useMemo } from 'react'\n\nimport { DAI, UNI, USDC, USDT, WBTC, WRAPPED_NATIVE_CURRENCY } from '../../constants/tokens'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { NEVER_RELOAD, useMultipleContractSingleData } from '../multicall/hooks'\nimport { tryParseAmount } from '../swap/hooks'\n\nconst STAKING_REWARDS_INTERFACE = new Interface(STAKING_REWARDS_ABI)\n\nexport const STAKING_GENESIS = 1600387200\n\nexport const REWARDS_DURATION_DAYS = 60\n\nexport const STAKING_REWARDS_INFO: {\n  [chainId: number]: {\n    tokens: [Token, Token]\n    stakingRewardAddress: string\n  }[]\n} = {\n  1: [\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[1], DAI],\n      stakingRewardAddress: '0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[1], USDC],\n      stakingRewardAddress: '0x7FBa4B8Dc5E7616e59622806932DBea72537A56b',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[1], USDT],\n      stakingRewardAddress: '0x6C3e4cb2E96B01F4b866965A91ed4437839A121a',\n    },\n    {\n      tokens: [WRAPPED_NATIVE_CURRENCY[1], WBTC],\n      stakingRewardAddress: '0xCA35e32e7926b96A9988f61d510E038108d8068e',\n    },\n  ],\n}\n\nexport interface StakingInfo {\n  // the address of the reward contract\n  stakingRewardAddress: string\n  // the tokens involved in this pair\n  tokens: [Token, Token]\n  // the amount of token currently staked, or undefined if no account\n  stakedAmount: CurrencyAmount<Token>\n  // the amount of reward token earned by the active account, or undefined if no account\n  earnedAmount: CurrencyAmount<Token>\n  // the total amount of token staked in the contract\n  totalStakedAmount: CurrencyAmount<Token>\n  // the amount of token distributed per second to all LPs, constant\n  totalRewardRate: CurrencyAmount<Token>\n  // the current amount of token distributed to the active account per second.\n  // equivalent to percent of total supply * reward rate\n  rewardRate: CurrencyAmount<Token>\n  // when the period ends\n  periodFinish: Date | undefined\n  // if pool is active\n  active: boolean\n  // calculates a hypothetical amount of token distributed to the active account per second.\n  getHypotheticalRewardRate: (\n    stakedAmount: CurrencyAmount<Token>,\n    totalStakedAmount: CurrencyAmount<Token>,\n    totalRewardRate: CurrencyAmount<Token>\n  ) => CurrencyAmount<Token>\n}\n\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy?: Pair | null): StakingInfo[] {\n  const { chainId, account } = useActiveWeb3React()\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp()\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? STAKING_REWARDS_INFO[chainId]?.filter((stakingRewardInfo) =>\n            pairToFilterBy === undefined\n              ? true\n              : pairToFilterBy === null\n              ? false\n              : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n                pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])\n          ) ?? []\n        : [],\n    [chainId, pairToFilterBy]\n  )\n\n  const uni = chainId ? UNI[chainId] : undefined\n\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n\n  const accountArg = useMemo(() => [account ?? undefined], [account])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n  const periodFinishes = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  return useMemo(() => {\n    if (!chainId || !uni) return []\n\n    return rewardsAddresses.reduce<StakingInfo[]>((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index]\n      const earnedAmountState = earnedAmounts[index]\n\n      // these get fetched regardless of account\n      const totalSupplyState = totalSupplies[index]\n      const rewardRateState = rewardRates[index]\n      const periodFinishState = periodFinishes[index]\n\n      if (\n        // these may be undefined if not logged in\n        !balanceState?.loading &&\n        !earnedAmountState?.loading &&\n        // always need these\n        totalSupplyState &&\n        !totalSupplyState.loading &&\n        rewardRateState &&\n        !rewardRateState.loading &&\n        periodFinishState &&\n        !periodFinishState.loading\n      ) {\n        if (\n          balanceState?.error ||\n          earnedAmountState?.error ||\n          totalSupplyState.error ||\n          rewardRateState.error ||\n          periodFinishState.error\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        // get the LP token\n        const tokens = info[index].tokens\n        const dummyPair = new Pair(\n          CurrencyAmount.fromRawAmount(tokens[0], '0'),\n          CurrencyAmount.fromRawAmount(tokens[1], '0')\n        )\n\n        // check for account, if no account set to 0\n\n        const stakedAmount = CurrencyAmount.fromRawAmount(\n          dummyPair.liquidityToken,\n          JSBI.BigInt(balanceState?.result?.[0] ?? 0)\n        )\n        const totalStakedAmount = CurrencyAmount.fromRawAmount(\n          dummyPair.liquidityToken,\n          JSBI.BigInt(totalSupplyState.result?.[0])\n        )\n        const totalRewardRate = CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(rewardRateState.result?.[0]))\n\n        const getHypotheticalRewardRate = (\n          stakedAmount: CurrencyAmount<Token>,\n          totalStakedAmount: CurrencyAmount<Token>,\n          totalRewardRate: CurrencyAmount<Token>\n        ): CurrencyAmount<Token> => {\n          return CurrencyAmount.fromRawAmount(\n            uni,\n            JSBI.greaterThan(totalStakedAmount.quotient, JSBI.BigInt(0))\n              ? JSBI.divide(JSBI.multiply(totalRewardRate.quotient, stakedAmount.quotient), totalStakedAmount.quotient)\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, totalRewardRate)\n\n        const periodFinishSeconds = periodFinishState.result?.[0]?.toNumber()\n        const periodFinishMs = periodFinishSeconds * 1000\n\n        // compare period end timestamp vs current block timestamp (in seconds)\n        const active =\n          periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : true\n\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: info[index].tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          earnedAmount: CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0)),\n          rewardRate: individualRewardRate,\n          totalRewardRate,\n          stakedAmount,\n          totalStakedAmount,\n          getHypotheticalRewardRate,\n          active,\n        })\n      }\n      return memo\n    }, [])\n  }, [\n    balances,\n    chainId,\n    currentBlockTimestamp,\n    earnedAmounts,\n    info,\n    periodFinishes,\n    rewardRates,\n    rewardsAddresses,\n    totalSupplies,\n    uni,\n  ])\n}\n\nexport function useTotalUniEarned(): CurrencyAmount<Token> | undefined {\n  const { chainId } = useActiveWeb3React()\n  const uni = chainId ? UNI[chainId] : undefined\n  const stakingInfos = useStakingInfo()\n\n  return useMemo(() => {\n    if (!uni) return undefined\n    return (\n      stakingInfos?.reduce(\n        (accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount),\n        CurrencyAmount.fromRawAmount(uni, '0')\n      ) ?? CurrencyAmount.fromRawAmount(uni, '0')\n    )\n  }, [stakingInfos, uni])\n}\n\n// based on typed value\nexport function useDerivedStakeInfo(\n  typedValue: string,\n  stakingToken: Token | undefined,\n  userLiquidityUnstaked: CurrencyAmount<Token> | undefined\n): {\n  parsedAmount?: CurrencyAmount<Token>\n  error?: ReactNode\n} {\n  const { account } = useActiveWeb3React()\n\n  const parsedInput: CurrencyAmount<Token> | undefined = tryParseAmount(typedValue, stakingToken)\n\n  const parsedAmount =\n    parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.quotient, userLiquidityUnstaked.quotient)\n      ? parsedInput\n      : undefined\n\n  let error: ReactNode | undefined\n  if (!account) {\n    error = <Trans>Connect Wallet</Trans>\n  }\n  if (!parsedAmount) {\n    error = error ?? <Trans>Enter an amount</Trans>\n  }\n\n  return {\n    parsedAmount,\n    error,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}