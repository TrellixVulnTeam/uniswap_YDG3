{"ast":null,"code":"import _toConsumableArray from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useMemo}from'react';import{ADDITIONAL_BASES,BASES_TO_CHECK_TRADES_AGAINST,CUSTOM_BASES}from'../constants/routing';export function useAllCurrencyCombinations(currencyA,currencyB){var chainId=currencyA===null||currencyA===void 0?void 0:currencyA.chainId;var _ref=chainId?[currencyA===null||currencyA===void 0?void 0:currencyA.wrapped,currencyB===null||currencyB===void 0?void 0:currencyB.wrapped]:[undefined,undefined],_ref2=_slicedToArray(_ref,2),tokenA=_ref2[0],tokenB=_ref2[1];var bases=useMemo(function(){var _BASES_TO_CHECK_TRADE,_ADDITIONAL_BASES$cha,_ADDITIONAL_BASES$cha2,_ADDITIONAL_BASES$cha3,_ADDITIONAL_BASES$cha4;if(!chainId||chainId!==(tokenB===null||tokenB===void 0?void 0:tokenB.chainId))return[];var common=(_BASES_TO_CHECK_TRADE=BASES_TO_CHECK_TRADES_AGAINST[chainId])!==null&&_BASES_TO_CHECK_TRADE!==void 0?_BASES_TO_CHECK_TRADE:[];var additionalA=tokenA?(_ADDITIONAL_BASES$cha=(_ADDITIONAL_BASES$cha2=ADDITIONAL_BASES[chainId])===null||_ADDITIONAL_BASES$cha2===void 0?void 0:_ADDITIONAL_BASES$cha2[tokenA.address])!==null&&_ADDITIONAL_BASES$cha!==void 0?_ADDITIONAL_BASES$cha:[]:[];var additionalB=tokenB?(_ADDITIONAL_BASES$cha3=(_ADDITIONAL_BASES$cha4=ADDITIONAL_BASES[chainId])===null||_ADDITIONAL_BASES$cha4===void 0?void 0:_ADDITIONAL_BASES$cha4[tokenB.address])!==null&&_ADDITIONAL_BASES$cha3!==void 0?_ADDITIONAL_BASES$cha3:[]:[];return[].concat(_toConsumableArray(common),_toConsumableArray(additionalA),_toConsumableArray(additionalB));},[chainId,tokenA,tokenB]);var basePairs=useMemo(function(){return bases.flatMap(function(base){return bases.map(function(otherBase){return[base,otherBase];});})// though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n.filter(function(_ref3){var _ref4=_slicedToArray(_ref3,2),t0=_ref4[0],t1=_ref4[1];return!t0.equals(t1);});},[bases]);return useMemo(function(){return tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB]].concat(_toConsumableArray(bases.map(function(base){return[tokenA,base];})),_toConsumableArray(bases.map(function(base){return[tokenB,base];})),_toConsumableArray(basePairs))// filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n.filter(function(_ref5){var _ref6=_slicedToArray(_ref5,2),t0=_ref6[0],t1=_ref6[1];return!t0.equals(t1);})// filter out duplicate pairs\n.filter(function(_ref7,i,otherPairs){var _ref8=_slicedToArray(_ref7,2),t0=_ref8[0],t1=_ref8[1];// find the first index in the array at which there are the same 2 tokens as the current\nvar firstIndexInOtherPairs=otherPairs.findIndex(function(_ref9){var _ref10=_slicedToArray(_ref9,2),t0Other=_ref10[0],t1Other=_ref10[1];return t0.equals(t0Other)&&t1.equals(t1Other)||t0.equals(t1Other)&&t1.equals(t0Other);});// only accept the first occurrence of the same 2 tokens\nreturn firstIndexInOtherPairs===i;})// optionally filter out some pairs for tokens with custom bases defined\n.filter(function(_ref11){var _ref12=_slicedToArray(_ref11,2),tokenA=_ref12[0],tokenB=_ref12[1];if(!chainId)return true;var customBases=CUSTOM_BASES[chainId];var customBasesA=customBases===null||customBases===void 0?void 0:customBases[tokenA.address];var customBasesB=customBases===null||customBases===void 0?void 0:customBases[tokenB.address];if(!customBasesA&&!customBasesB)return true;if(customBasesA&&!customBasesA.find(function(base){return tokenB.equals(base);}))return false;if(customBasesB&&!customBasesB.find(function(base){return tokenA.equals(base);}))return false;return true;}):[];},[tokenA,tokenB,bases,basePairs,chainId]);}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useAllCurrencyCombinations.ts"],"names":["useMemo","ADDITIONAL_BASES","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","useAllCurrencyCombinations","currencyA","currencyB","chainId","wrapped","undefined","tokenA","tokenB","bases","common","additionalA","address","additionalB","basePairs","flatMap","base","map","otherBase","filter","t0","t1","equals","i","otherPairs","firstIndexInOtherPairs","findIndex","t0Other","t1Other","customBases","customBasesA","customBasesB","find"],"mappings":"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","sourcesContent":["import { Currency, Token } from '@uniswap/sdk-core'\nimport { useMemo } from 'react'\n\nimport { ADDITIONAL_BASES, BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants/routing'\n\nexport function useAllCurrencyCombinations(currencyA?: Currency, currencyB?: Currency): [Token, Token][] {\n  const chainId = currencyA?.chainId\n\n  const [tokenA, tokenB] = chainId ? [currencyA?.wrapped, currencyB?.wrapped] : [undefined, undefined]\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId || chainId !== tokenB?.chainId) return []\n\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\n\n    return [...common, ...additionalA, ...additionalB]\n  }, [chainId, tokenA, tokenB])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      bases\n        .flatMap((base): [Token, Token][] => bases.map((otherBase) => [base, otherBase]))\n        // though redundant with the first filter below, that expression runs more often, so this is probably worthwhile\n        .filter(([t0, t1]) => !t0.equals(t1)),\n    [bases]\n  )\n\n  return useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB] as [Token, Token],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            // filter out invalid pairs comprised of the same asset (e.g. WETH<>WETH)\n            .filter(([t0, t1]) => !t0.equals(t1))\n            // filter out duplicate pairs\n            .filter(([t0, t1], i, otherPairs) => {\n              // find the first index in the array at which there are the same 2 tokens as the current\n              const firstIndexInOtherPairs = otherPairs.findIndex(([t0Other, t1Other]) => {\n                return (t0.equals(t0Other) && t1.equals(t1Other)) || (t0.equals(t1Other) && t1.equals(t0Other))\n              })\n              // only accept the first occurrence of the same 2 tokens\n              return firstIndexInOtherPairs === i\n            })\n            // optionally filter out some pairs for tokens with custom bases defined\n            .filter(([tokenA, tokenB]) => {\n              if (!chainId) return true\n              const customBases = CUSTOM_BASES[chainId]\n\n              const customBasesA: Token[] | undefined = customBases?.[tokenA.address]\n              const customBasesB: Token[] | undefined = customBases?.[tokenB.address]\n\n              if (!customBasesA && !customBasesB) return true\n\n              if (customBasesA && !customBasesA.find((base) => tokenB.equals(base))) return false\n              if (customBasesB && !customBasesB.find((base) => tokenA.equals(base))) return false\n\n              return true\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}