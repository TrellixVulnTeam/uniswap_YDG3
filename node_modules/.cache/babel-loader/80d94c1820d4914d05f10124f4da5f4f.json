{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar JSBI = _interopDefault(require('jsbi'));\n\nvar abi = require('@ethersproject/abi');\n\nvar invariant = _interopDefault(require('tiny-invariant'));\n\nvar IApproveAndCall_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json');\n\nvar v3Sdk = require('@uniswap/v3-sdk');\n\nvar IMulticallExtended_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json');\n\nvar sdkCore = require('@uniswap/sdk-core');\n\nvar IPeripheryPaymentsWithFeeExtended_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json');\n\nvar ISwapRouter02_json = require('@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json');\n\nvar v2Sdk = require('@uniswap/v2-sdk');\n\nvar MSG_SENDER = '0x0000000000000000000000000000000000000001';\nvar ADDRESS_THIS = '0x0000000000000000000000000000000000000002';\nvar ZERO = /*#__PURE__*/JSBI.BigInt(0);\nvar ONE = /*#__PURE__*/JSBI.BigInt(1);\n\n(function (ApprovalTypes) {\n  ApprovalTypes[ApprovalTypes[\"NOT_REQUIRED\"] = 0] = \"NOT_REQUIRED\";\n  ApprovalTypes[ApprovalTypes[\"MAX\"] = 1] = \"MAX\";\n  ApprovalTypes[ApprovalTypes[\"MAX_MINUS_ONE\"] = 2] = \"MAX_MINUS_ONE\";\n  ApprovalTypes[ApprovalTypes[\"ZERO_THEN_MAX\"] = 3] = \"ZERO_THEN_MAX\";\n  ApprovalTypes[ApprovalTypes[\"ZERO_THEN_MAX_MINUS_ONE\"] = 4] = \"ZERO_THEN_MAX_MINUS_ONE\";\n})(exports.ApprovalTypes || (exports.ApprovalTypes = {})); // type guard\n\n\nfunction isMint(options) {\n  return Object.keys(options).some(function (k) {\n    return k === 'recipient';\n  });\n}\n\nvar ApproveAndCall = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function ApproveAndCall() {}\n\n  ApproveAndCall.encodeApproveMax = function encodeApproveMax(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address]);\n  };\n\n  ApproveAndCall.encodeApproveMaxMinusOne = function encodeApproveMaxMinusOne(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address]);\n  };\n\n  ApproveAndCall.encodeApproveZeroThenMax = function encodeApproveZeroThenMax(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address]);\n  };\n\n  ApproveAndCall.encodeApproveZeroThenMaxMinusOne = function encodeApproveZeroThenMaxMinusOne(token) {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address]);\n  };\n\n  ApproveAndCall.encodeCallPositionManager = function encodeCallPositionManager(calldatas) {\n    !(calldatas.length > 0) ? invariant(false, 'NULL_CALLDATA') : void 0;\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas);\n    } else {\n      var encodedMulticall = v3Sdk.NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas]);\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall]);\n    }\n  }\n  /**\r\n   * Encode adding liquidity to a position in the nft manager contract\r\n   * @param position Forcasted position with expected amount out from swap\r\n   * @param minimalPosition Forcasted position with custom minimal token amounts\r\n   * @param addLiquidityOptions Options for adding liquidity\r\n   * @param slippageTolerance Defines maximum slippage\r\n   */\n  ;\n\n  ApproveAndCall.encodeAddLiquidity = function encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, slippageTolerance) {\n    var _position$mintAmounts = position.mintAmountsWithSlippage(slippageTolerance),\n        amount0Min = _position$mintAmounts.amount0,\n        amount1Min = _position$mintAmounts.amount1; // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n\n\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient;\n    }\n\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient;\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [{\n        token0: position.pool.token0.address,\n        token1: position.pool.token1.address,\n        fee: position.pool.fee,\n        tickLower: position.tickLower,\n        tickUpper: position.tickUpper,\n        amount0Min: v3Sdk.toHex(amount0Min),\n        amount1Min: v3Sdk.toHex(amount1Min),\n        recipient: addLiquidityOptions.recipient\n      }]);\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [{\n        token0: position.pool.token0.address,\n        token1: position.pool.token1.address,\n        amount0Min: v3Sdk.toHex(amount0Min),\n        amount1Min: v3Sdk.toHex(amount1Min),\n        tokenId: v3Sdk.toHex(addLiquidityOptions.tokenId)\n      }]);\n    }\n  };\n\n  ApproveAndCall.encodeApprove = function encodeApprove(token, approvalType) {\n    switch (approvalType) {\n      case exports.ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped);\n\n      case exports.ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped);\n\n      case exports.ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped);\n\n      case exports.ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped);\n\n      default:\n        throw 'Error: invalid ApprovalType';\n    }\n  };\n\n  return ApproveAndCall;\n}();\n\nApproveAndCall.INTERFACE = /*#__PURE__*/new abi.Interface(IApproveAndCall_json.abi);\n\nfunction validateAndParseBytes32(bytes32) {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(bytes32 + \" is not valid bytes32.\");\n  }\n\n  return bytes32.toLowerCase();\n}\n\nvar MulticallExtended = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function MulticallExtended() {}\n\n  MulticallExtended.encodeMulticall = function encodeMulticall(calldatas, validation) {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return v3Sdk.Multicall.encodeMulticall(calldatas);\n    } // if there is validation, we have to normalize calldatas\n\n\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas];\n    } // this means the validation value should be a previousBlockhash\n\n\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      var previousBlockhash = validateAndParseBytes32(validation);\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [previousBlockhash, calldatas]);\n    } else {\n      var deadline = v3Sdk.toHex(validation);\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas]);\n    }\n  };\n\n  return MulticallExtended;\n}();\n\nMulticallExtended.INTERFACE = /*#__PURE__*/new abi.Interface(IMulticallExtended_json.abi);\n\nfunction encodeFeeBips(fee) {\n  return v3Sdk.toHex(fee.multiply(10000).quotient);\n}\n\nvar PaymentsExtended = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function PaymentsExtended() {}\n\n  PaymentsExtended.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return v3Sdk.Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions);\n    }\n\n    if (!!feeOptions) {\n      var feeBips = encodeFeeBips(feeOptions.fee);\n      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [v3Sdk.toHex(amountMinimum), feeBips, feeRecipient]);\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [v3Sdk.toHex(amountMinimum)]);\n    }\n  };\n\n  PaymentsExtended.encodeSweepToken = function encodeSweepToken(token, amountMinimum, recipient, feeOptions) {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return v3Sdk.Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions);\n    }\n\n    if (!!feeOptions) {\n      var feeBips = encodeFeeBips(feeOptions.fee);\n      var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [token.address, v3Sdk.toHex(amountMinimum), feeBips, feeRecipient]);\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [token.address, v3Sdk.toHex(amountMinimum)]);\n    }\n  };\n\n  PaymentsExtended.encodePull = function encodePull(token, amount) {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, v3Sdk.toHex(amount)]);\n  };\n\n  PaymentsExtended.encodeWrapETH = function encodeWrapETH(amount) {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [v3Sdk.toHex(amount)]);\n  };\n\n  return PaymentsExtended;\n}();\n\nPaymentsExtended.INTERFACE = /*#__PURE__*/new abi.Interface(IPeripheryPaymentsWithFeeExtended_json.abi);\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function (obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n\n    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n\n    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n\n    function Generator() {}\n\n    function GeneratorFunction() {}\n\n    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n\n\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function () {\n      return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    define(Gp, \"constructor\", GeneratorFunctionPrototype);\n    define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"); // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    }; // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n\n\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n\n      var previousPromise;\n\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n\n        return previousPromise = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      } // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n\n\n      this._invoke = enqueue;\n    }\n\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n      return this;\n    });\n    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          } // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n          return doneResult();\n        }\n\n        context.method = method;\n        context.arg = arg;\n\n        while (true) {\n          var delegate = context.delegate;\n\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted; // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    } // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n\n        return ContinueSentinel;\n      }\n\n      var record = tryCatch(method, delegate.iterator, context.arg);\n\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      var info = record.arg;\n\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n        context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      } // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n\n\n      context.delegate = null;\n      return ContinueSentinel;\n    } // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n\n\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\"); // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n    define(Gp, iteratorSymbol, function () {\n      return this;\n    });\n    define(Gp, \"toString\", function () {\n      return \"[object Generator]\";\n    });\n\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n\n      this.tryEntries.push(entry);\n    }\n\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n\n    exports.keys = function (object) {\n      var keys = [];\n\n      for (var key in object) {\n        keys.push(key);\n      }\n\n      keys.reverse(); // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        } // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n\n\n        next.done = true;\n        return next;\n      };\n    };\n\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n              next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n\n            next.value = undefined$1;\n            next.done = true;\n            return next;\n          };\n\n          return next.next = next;\n        }\n      } // Return an iterator with no values.\n\n\n      return {\n        next: doneResult\n      };\n    }\n\n    exports.values = values;\n\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n\n    Context.prototype = {\n      constructor: Context,\n      reset: function (skipTempReset) {\n        this.prev = 0;\n        this.next = 0; // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function () {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n\n        return this.rval;\n      },\n      dispatchException: function (exception) {\n        if (this.done) {\n          throw exception;\n        }\n\n        var context = this;\n\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n\n          return !!caught;\n        }\n\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function (type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n\n        return this.complete(record);\n      },\n      complete: function (record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n\n        return ContinueSentinel;\n      },\n      finish: function (finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function (tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n\n            return thrown;\n          }\n        } // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n\n\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function (iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n\n        return ContinueSentinel;\n      }\n    }; // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n\n    return exports;\n  }( // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") {\n      globalThis.regeneratorRuntime = runtime;\n    } else {\n      Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n    }\n  }\n});\n\n(function (Protocol) {\n  Protocol[\"V2\"] = \"V2\";\n  Protocol[\"V3\"] = \"V3\";\n})(exports.Protocol || (exports.Protocol = {}));\n\nvar RouteV2 = /*#__PURE__*/function (_V2RouteSDK) {\n  _inheritsLoose(RouteV2, _V2RouteSDK);\n\n  function RouteV2(v2Route) {\n    var _this;\n\n    _this = _V2RouteSDK.call(this, v2Route.pairs, v2Route.input, v2Route.output) || this;\n    _this.protocol = exports.Protocol.V2;\n    _this.pools = _this.pairs;\n    return _this;\n  }\n\n  return RouteV2;\n}(v2Sdk.Route); // V3 route wrapper\n\n\nvar RouteV3 = /*#__PURE__*/function (_V3RouteSDK) {\n  _inheritsLoose(RouteV3, _V3RouteSDK);\n\n  function RouteV3(v3Route) {\n    var _this2;\n\n    _this2 = _V3RouteSDK.call(this, v3Route.pools, v3Route.input, v3Route.output) || this;\n    _this2.protocol = exports.Protocol.V3;\n    _this2.path = v3Route.tokenPath;\n    return _this2;\n  }\n\n  return RouteV3;\n}(v3Sdk.Route);\n\nvar Trade = /*#__PURE__*/function () {\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  function Trade(_ref) {\n    var v2Routes = _ref.v2Routes,\n        v3Routes = _ref.v3Routes,\n        tradeType = _ref.tradeType;\n    this.swaps = [];\n    this.routes = []; // wrap v2 routes\n\n    for (var _iterator = _createForOfIteratorHelperLoose(v2Routes), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          routev2 = _step$value.routev2,\n          inputAmount = _step$value.inputAmount,\n          outputAmount = _step$value.outputAmount;\n      var route = new RouteV2(routev2);\n      this.routes.push(route);\n      this.swaps.push({\n        route: route,\n        inputAmount: inputAmount,\n        outputAmount: outputAmount\n      });\n    } // wrap v3 routes\n\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(v3Routes), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          routev3 = _step2$value.routev3,\n          _inputAmount = _step2$value.inputAmount,\n          _outputAmount = _step2$value.outputAmount;\n\n      var _route = new RouteV3(routev3);\n\n      this.routes.push(_route);\n      this.swaps.push({\n        route: _route,\n        inputAmount: _inputAmount,\n        outputAmount: _outputAmount\n      });\n    }\n\n    this.tradeType = tradeType; // each route must have the same input and output currency\n\n    var inputCurrency = this.swaps[0].inputAmount.currency;\n    var outputCurrency = this.swaps[0].outputAmount.currency;\n    !this.swaps.every(function (_ref2) {\n      var route = _ref2.route;\n      return inputCurrency.wrapped.equals(route.input.wrapped);\n    }) ? invariant(false, 'INPUT_CURRENCY_MATCH') : void 0;\n    !this.swaps.every(function (_ref3) {\n      var route = _ref3.route;\n      return outputCurrency.wrapped.equals(route.output.wrapped);\n    }) ? invariant(false, 'OUTPUT_CURRENCY_MATCH') : void 0; // pools must be unique inter protocols\n\n    var numPools = this.swaps.map(function (_ref4) {\n      var route = _ref4.route;\n      return route.pools.length;\n    }).reduce(function (total, cur) {\n      return total + cur;\n    }, 0);\n    var poolAddressSet = new Set();\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(this.swaps), _step3; !(_step3 = _iterator3()).done;) {\n      var _route2 = _step3.value.route;\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(_route2.pools), _step4; !(_step4 = _iterator4()).done;) {\n        var pool = _step4.value;\n\n        if (_route2.protocol == exports.Protocol.V3) {\n          poolAddressSet.add(v3Sdk.Pool.getAddress(pool.token0, pool.token1, pool.fee));\n        } else {\n          var pair = pool;\n          poolAddressSet.add(v2Sdk.Pair.getAddress(pair.token0, pair.token1));\n        }\n      }\n    }\n\n    !(numPools == poolAddressSet.size) ? invariant(false, 'POOLS_DUPLICATED') : void 0;\n  }\n\n  var _proto = Trade.prototype;\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount out\r\n   */\n\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {\n    if (amountOut === void 0) {\n      amountOut = this.outputAmount;\n    }\n\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0;\n\n    if (this.tradeType === sdkCore.TradeType.EXACT_OUTPUT) {\n      return amountOut;\n    } else {\n      var slippageAdjustedAmountOut = new sdkCore.Fraction(ONE).add(slippageTolerance).invert().multiply(amountOut.quotient).quotient;\n      return sdkCore.CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n   * @returns The amount in\r\n   */\n  ;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {\n    if (amountIn === void 0) {\n      amountIn = this.inputAmount;\n    }\n\n    !!slippageTolerance.lessThan(ZERO) ? invariant(false, 'SLIPPAGE_TOLERANCE') : void 0;\n\n    if (this.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n      return amountIn;\n    } else {\n      var slippageAdjustedAmountIn = new sdkCore.Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;\n      return sdkCore.CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Return the execution price after accounting for slippage tolerance\r\n   * @param slippageTolerance the allowed tolerated slippage\r\n   * @returns The execution price\r\n   */\n  ;\n\n  _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {\n    return new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  };\n\n  Trade.fromRoutes = /*#__PURE__*/function () {\n    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(v2Routes, v3Routes, tradeType) {\n      var populatedV2Routes, populatedV3Routes, _iterator5, _step5, _step5$value, routev2, amount, v2Trade, inputAmount, outputAmount, _iterator6, _step6, _step6$value, routev3, _amount, v3Trade, _inputAmount2, _outputAmount2;\n\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              populatedV2Routes = [];\n              populatedV3Routes = [];\n\n              for (_iterator5 = _createForOfIteratorHelperLoose(v2Routes); !(_step5 = _iterator5()).done;) {\n                _step5$value = _step5.value, routev2 = _step5$value.routev2, amount = _step5$value.amount;\n                v2Trade = new v2Sdk.Trade(routev2, amount, tradeType);\n                inputAmount = v2Trade.inputAmount, outputAmount = v2Trade.outputAmount;\n                populatedV2Routes.push({\n                  routev2: routev2,\n                  inputAmount: inputAmount,\n                  outputAmount: outputAmount\n                });\n              }\n\n              _iterator6 = _createForOfIteratorHelperLoose(v3Routes);\n\n            case 4:\n              if ((_step6 = _iterator6()).done) {\n                _context.next = 13;\n                break;\n              }\n\n              _step6$value = _step6.value, routev3 = _step6$value.routev3, _amount = _step6$value.amount;\n              _context.next = 8;\n              return v3Sdk.Trade.fromRoute(routev3, _amount, tradeType);\n\n            case 8:\n              v3Trade = _context.sent;\n              _inputAmount2 = v3Trade.inputAmount, _outputAmount2 = v3Trade.outputAmount;\n              populatedV3Routes.push({\n                routev3: routev3,\n                inputAmount: _inputAmount2,\n                outputAmount: _outputAmount2\n              });\n\n            case 11:\n              _context.next = 4;\n              break;\n\n            case 13:\n              return _context.abrupt(\"return\", new Trade({\n                v2Routes: populatedV2Routes,\n                v3Routes: populatedV3Routes,\n                tradeType: tradeType\n              }));\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function fromRoutes(_x, _x2, _x3) {\n      return _fromRoutes.apply(this, arguments);\n    }\n\n    return fromRoutes;\n  }();\n\n  Trade.fromRoute = /*#__PURE__*/function () {\n    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(route, amount, tradeType) {\n      var v2Routes, v3Routes, v2Trade, inputAmount, outputAmount, v3Trade, _inputAmount3, _outputAmount3;\n\n      return runtime_1.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(route instanceof v2Sdk.Route)) {\n                _context2.next = 7;\n                break;\n              }\n\n              v2Trade = new v2Sdk.Trade(route, amount, tradeType);\n              inputAmount = v2Trade.inputAmount, outputAmount = v2Trade.outputAmount;\n              v2Routes = [{\n                routev2: route,\n                inputAmount: inputAmount,\n                outputAmount: outputAmount\n              }];\n              v3Routes = [];\n              _context2.next = 13;\n              break;\n\n            case 7:\n              _context2.next = 9;\n              return v3Sdk.Trade.fromRoute(route, amount, tradeType);\n\n            case 9:\n              v3Trade = _context2.sent;\n              _inputAmount3 = v3Trade.inputAmount, _outputAmount3 = v3Trade.outputAmount;\n              v3Routes = [{\n                routev3: route,\n                inputAmount: _inputAmount3,\n                outputAmount: _outputAmount3\n              }];\n              v2Routes = [];\n\n            case 13:\n              return _context2.abrupt(\"return\", new Trade({\n                v2Routes: v2Routes,\n                v3Routes: v3Routes,\n                tradeType: tradeType\n              }));\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function fromRoute(_x4, _x5, _x6) {\n      return _fromRoute.apply(this, arguments);\n    }\n\n    return fromRoute;\n  }();\n\n  _createClass(Trade, [{\n    key: \"inputAmount\",\n    get: function get() {\n      if (this._inputAmount) {\n        return this._inputAmount;\n      }\n\n      var inputCurrency = this.swaps[0].inputAmount.currency;\n      var totalInputFromRoutes = this.swaps.map(function (_ref5) {\n        var inputAmount = _ref5.inputAmount;\n        return inputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(inputCurrency, 0));\n      this._inputAmount = totalInputFromRoutes;\n      return this._inputAmount;\n    }\n  }, {\n    key: \"outputAmount\",\n    get: function get() {\n      if (this._outputAmount) {\n        return this._outputAmount;\n      }\n\n      var outputCurrency = this.swaps[0].outputAmount.currency;\n      var totalOutputFromRoutes = this.swaps.map(function (_ref6) {\n        var outputAmount = _ref6.outputAmount;\n        return outputAmount;\n      }).reduce(function (total, cur) {\n        return total.add(cur);\n      }, sdkCore.CurrencyAmount.fromRawAmount(outputCurrency, 0));\n      this._outputAmount = totalOutputFromRoutes;\n      return this._outputAmount;\n    }\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\n\n  }, {\n    key: \"executionPrice\",\n    get: function get() {\n      var _this$_executionPrice;\n\n      return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    }\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\n\n  }, {\n    key: \"priceImpact\",\n    get: function get() {\n      if (this._priceImpact) {\n        return this._priceImpact;\n      }\n\n      var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);\n\n      for (var _iterator7 = _createForOfIteratorHelperLoose(this.swaps), _step7; !(_step7 = _iterator7()).done;) {\n        var _step7$value = _step7.value,\n            route = _step7$value.route,\n            inputAmount = _step7$value.inputAmount;\n        var midPrice = route.midPrice;\n        spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));\n      }\n\n      var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);\n      this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator);\n      return this._priceImpact;\n    }\n  }]);\n\n  return Trade;\n}();\n\nvar ZERO$1 = /*#__PURE__*/JSBI.BigInt(0);\n/**\r\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\r\n */\n\nvar SwapRouter = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function SwapRouter() {}\n\n  SwapRouter.encodeV2Swap = function encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck) {\n    var amountIn = v3Sdk.toHex(trade.maximumAmountIn(options.slippageTolerance).quotient);\n    var amountOut = v3Sdk.toHex(trade.minimumAmountOut(options.slippageTolerance).quotient);\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var recipient = routerMustCustody ? ADDRESS_THIS : typeof options.recipient === 'undefined' ? MSG_SENDER : sdkCore.validateAndParseAddress(options.recipient);\n\n    if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n      var exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient];\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams);\n    } else {\n      var exactOutputParams = [amountOut, amountIn, path, recipient];\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams);\n    }\n  };\n\n  SwapRouter.encodeV3Swap = function encodeV3Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck) {\n    var calldatas = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(trade.swaps), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n          route = _step$value.route,\n          inputAmount = _step$value.inputAmount,\n          outputAmount = _step$value.outputAmount;\n      var amountIn = v3Sdk.toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);\n      var amountOut = v3Sdk.toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient); // flag for whether the trade is single hop or not\n\n      var singleHop = route.pools.length === 1;\n      var recipient = routerMustCustody ? ADDRESS_THIS : typeof options.recipient === 'undefined' ? MSG_SENDER : sdkCore.validateAndParseAddress(options.recipient);\n\n      if (singleHop) {\n        if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n          var exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient: recipient,\n            amountIn: amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));\n        } else {\n          var exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient: recipient,\n            amountOut: amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]));\n        }\n      } else {\n        var path = v3Sdk.encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);\n\n        if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {\n          var exactInputParams = {\n            path: path,\n            recipient: recipient,\n            amountIn: amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]));\n        } else {\n          var exactOutputParams = {\n            path: path,\n            recipient: recipient,\n            amountOut: amountOut,\n            amountInMaximum: amountIn\n          };\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]));\n        }\n      }\n    }\n\n    return calldatas;\n  };\n\n  SwapRouter.encodeSwaps = function encodeSwaps(trades, options, isSwapAndAdd) {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual V2Trade and V3Trade objects.\n    if (trades instanceof Trade) {\n      !trades.swaps.every(function (swap) {\n        return swap.route.protocol == exports.Protocol.V3 || swap.route.protocol == exports.Protocol.V2;\n      }) ? invariant(false, 'UNSUPPORTED_PROTOCOL') : void 0;\n      var v2Andv3Trades = [];\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(trades.swaps), _step2; !(_step2 = _iterator2()).done;) {\n        var _step2$value = _step2.value,\n            route = _step2$value.route,\n            inputAmount = _step2$value.inputAmount,\n            outputAmount = _step2$value.outputAmount;\n\n        if (route.protocol == exports.Protocol.V2) {\n          v2Andv3Trades.push(new v2Sdk.Trade(route, trades.tradeType == sdkCore.TradeType.EXACT_INPUT ? inputAmount : outputAmount, trades.tradeType));\n        } else if (route.protocol == exports.Protocol.V3) {\n          v2Andv3Trades.push(v3Sdk.Trade.createUncheckedTrade({\n            route: route,\n            inputAmount: inputAmount,\n            outputAmount: outputAmount,\n            tradeType: trades.tradeType\n          }));\n        }\n      }\n\n      trades = v2Andv3Trades;\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades];\n    }\n\n    var numberOfTrades = trades.reduce(function (numberOfTrades, trade) {\n      return numberOfTrades + (trade instanceof v3Sdk.Trade ? trade.swaps.length : 1);\n    }, 0);\n    var sampleTrade = trades[0]; // All trades should have the same starting/ending currency and trade type\n\n    !trades.every(function (trade) {\n      return trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency);\n    }) ? invariant(false, 'TOKEN_IN_DIFF') : void 0;\n    !trades.every(function (trade) {\n      return trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency);\n    }) ? invariant(false, 'TOKEN_OUT_DIFF') : void 0;\n    !trades.every(function (trade) {\n      return trade.tradeType === sampleTrade.tradeType;\n    }) ? invariant(false, 'TRADE_TYPE_DIFF') : void 0;\n    var calldatas = [];\n    var inputIsNative = sampleTrade.inputAmount.currency.isNative;\n    var outputIsNative = sampleTrade.outputAmount.currency.isNative; // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n\n    var performAggregatedSlippageCheck = sampleTrade.tradeType === sdkCore.TradeType.EXACT_INPUT && numberOfTrades > 2; // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n\n    var routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck; // encode permit if necessary\n\n    if (options.inputTokenPermit) {\n      !sampleTrade.inputAmount.currency.isToken ? invariant(false, 'NON_TOKEN_PERMIT') : void 0;\n      calldatas.push(v3Sdk.SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));\n    }\n\n    for (var _iterator3 = _createForOfIteratorHelperLoose(trades), _step3; !(_step3 = _iterator3()).done;) {\n      var trade = _step3.value;\n\n      if (trade instanceof v2Sdk.Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck));\n      } else {\n        for (var _iterator4 = _createForOfIteratorHelperLoose(SwapRouter.encodeV3Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck)), _step4; !(_step4 = _iterator4()).done;) {\n          var calldata = _step4.value;\n          calldatas.push(calldata);\n        }\n      }\n    }\n\n    var ZERO_IN = sdkCore.CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0);\n    var ZERO_OUT = sdkCore.CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0);\n    var minimumAmountOut = trades.reduce(function (sum, trade) {\n      return sum.add(trade.minimumAmountOut(options.slippageTolerance));\n    }, ZERO_OUT);\n    var quoteAmountOut = trades.reduce(function (sum, trade) {\n      return sum.add(trade.outputAmount);\n    }, ZERO_OUT);\n    var totalAmountIn = trades.reduce(function (sum, trade) {\n      return sum.add(trade.maximumAmountIn(options.slippageTolerance));\n    }, ZERO_IN);\n    return {\n      calldatas: calldatas,\n      sampleTrade: sampleTrade,\n      routerMustCustody: routerMustCustody,\n      inputIsNative: inputIsNative,\n      outputIsNative: outputIsNative,\n      totalAmountIn: totalAmountIn,\n      minimumAmountOut: minimumAmountOut,\n      quoteAmountOut: quoteAmountOut\n    };\n  }\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n  ;\n\n  SwapRouter.swapCallParameters = function swapCallParameters(trades, options) {\n    var _SwapRouter$encodeSwa = SwapRouter.encodeSwaps(trades, options),\n        calldatas = _SwapRouter$encodeSwa.calldatas,\n        sampleTrade = _SwapRouter$encodeSwa.sampleTrade,\n        routerMustCustody = _SwapRouter$encodeSwa.routerMustCustody,\n        inputIsNative = _SwapRouter$encodeSwa.inputIsNative,\n        outputIsNative = _SwapRouter$encodeSwa.outputIsNative,\n        totalAmountIn = _SwapRouter$encodeSwa.totalAmountIn,\n        minimumAmountOut = _SwapRouter$encodeSwa.minimumAmountOut; // unwrap or sweep\n\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee));\n      } else {\n        calldatas.push(PaymentsExtended.encodeSweepToken(sampleTrade.outputAmount.currency.wrapped, minimumAmountOut.quotient, options.recipient, options.fee));\n      }\n    } // must refund when paying in ETH, but with an uncertain input amount\n\n\n    if (inputIsNative && sampleTrade.tradeType === sdkCore.TradeType.EXACT_OUTPUT) {\n      calldatas.push(v3Sdk.Payments.encodeRefundETH());\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: v3Sdk.toHex(inputIsNative ? totalAmountIn.quotient : ZERO$1)\n    };\n  }\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n  ;\n\n  SwapRouter.swapAndAddCallParameters = function swapAndAddCallParameters(trades, options, position, addLiquidityOptions, tokenInApprovalType, tokenOutApprovalType) {\n    var _SwapRouter$encodeSwa2 = SwapRouter.encodeSwaps(trades, options, true),\n        calldatas = _SwapRouter$encodeSwa2.calldatas,\n        inputIsNative = _SwapRouter$encodeSwa2.inputIsNative,\n        outputIsNative = _SwapRouter$encodeSwa2.outputIsNative,\n        sampleTrade = _SwapRouter$encodeSwa2.sampleTrade,\n        totalAmountSwapped = _SwapRouter$encodeSwa2.totalAmountIn,\n        quoteAmountOut = _SwapRouter$encodeSwa2.quoteAmountOut,\n        minimumAmountOut = _SwapRouter$encodeSwa2.minimumAmountOut; // encode output token permit if necessary\n\n\n    if (options.outputTokenPermit) {\n      !quoteAmountOut.currency.isToken ? invariant(false, 'NON_TOKEN_PERMIT_OUTPUT') : void 0;\n      calldatas.push(v3Sdk.SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit));\n    }\n\n    var chainId = sampleTrade.route.chainId;\n    var zeroForOne = position.pool.token0 === totalAmountSwapped.currency.wrapped;\n\n    var _SwapRouter$getPositi = SwapRouter.getPositionAmounts(position, zeroForOne),\n        positionAmountIn = _SwapRouter$getPositi.positionAmountIn,\n        positionAmountOut = _SwapRouter$getPositi.positionAmountOut; // if tokens are native they will be converted to WETH9\n\n\n    var tokenIn = inputIsNative ? sdkCore.WETH9[chainId] : positionAmountIn.currency.wrapped;\n    var tokenOut = outputIsNative ? sdkCore.WETH9[chainId] : positionAmountOut.currency.wrapped; // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n\n    var amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped);\n\n    if (amountOutRemaining.greaterThan(sdkCore.CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient)) : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient));\n    } // if input is native, convert to WETH9, else pull ERC20 token\n\n\n    inputIsNative ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient)) : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient)); // approve token balances to NFTManager\n\n    if (tokenInApprovalType !== exports.ApprovalTypes.NOT_REQUIRED) calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType));\n    if (tokenOutApprovalType !== exports.ApprovalTypes.NOT_REQUIRED) calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType)); // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n\n    var minimalPosition = v3Sdk.Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false\n    }); // encode NFTManager add liquidity\n\n    calldatas.push(ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)); // sweep remaining tokens\n\n    inputIsNative ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO$1)) : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO$1));\n    outputIsNative ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO$1)) : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO$1));\n    var value;\n\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient;\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient;\n    } else {\n      value = ZERO$1;\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString()\n    };\n  };\n\n  SwapRouter.getPositionAmounts = function getPositionAmounts(position, zeroForOne) {\n    var _position$mintAmounts = position.mintAmounts,\n        amount0 = _position$mintAmounts.amount0,\n        amount1 = _position$mintAmounts.amount1;\n    var currencyAmount0 = sdkCore.CurrencyAmount.fromRawAmount(position.pool.token0, amount0);\n    var currencyAmount1 = sdkCore.CurrencyAmount.fromRawAmount(position.pool.token1, amount1);\n\n    var _ref = zeroForOne ? [currencyAmount0, currencyAmount1] : [currencyAmount1, currencyAmount0],\n        positionAmountIn = _ref[0],\n        positionAmountOut = _ref[1];\n\n    return {\n      positionAmountIn: positionAmountIn,\n      positionAmountOut: positionAmountOut\n    };\n  };\n\n  return SwapRouter;\n}();\n\nSwapRouter.INTERFACE = /*#__PURE__*/new abi.Interface(ISwapRouter02_json.abi);\nexports.ADDRESS_THIS = ADDRESS_THIS;\nexports.ApproveAndCall = ApproveAndCall;\nexports.MSG_SENDER = MSG_SENDER;\nexports.MulticallExtended = MulticallExtended;\nexports.ONE = ONE;\nexports.PaymentsExtended = PaymentsExtended;\nexports.RouteV2 = RouteV2;\nexports.RouteV3 = RouteV3;\nexports.SwapRouter = SwapRouter;\nexports.Trade = Trade;\nexports.ZERO = ZERO;\nexports.isMint = isMint;","map":{"version":3,"sources":["../src/constants.ts","../src/approveAndCall.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../node_modules/regenerator-runtime/runtime.js","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/swapRouter.ts"],"names":["MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","ONE","ApprovalTypes","isMint","options","k","ApproveAndCall","Interface","abi","token","calldatas","encodedMulticall","NonfungiblePositionManager","amount0Min","amount1Min","position","minimalPosition","token0","token1","fee","tickLower","tickUpper","toHex","recipient","addLiquidityOptions","tokenId","bytes32","MulticallExtended","Multicall","Array","validation","previousBlockhash","validateAndParseBytes32","deadline","PaymentsExtended","Payments","feeBips","encodeFeeBips","feeOptions","feeRecipient","validateAndParseAddress","undefined","Protocol","RouteV2","V2RouteSDK","v2Route","RouteV3","V3RouteSDK","v3Route","Trade","v2Routes","v3Routes","tradeType","routev2","inputAmount","outputAmount","route","routev3","inputCurrency","outputCurrency","numPools","total","poolAddressSet","pool","Pool","pair","Pair","totalInputFromRoutes","CurrencyAmount","totalOutputFromRoutes","Price","spotOutputAmount","midPrice","priceImpact","Percent","minimumAmountOut","amountOut","slippageTolerance","TradeType","slippageAdjustedAmountOut","Fraction","maximumAmountIn","amountIn","slippageAdjustedAmountIn","worstExecutionPrice","populatedV2Routes","populatedV3Routes","amount","v2Trade","V2TradeSDK","v3Trade","V3TradeSDK","SwapRouter","trade","path","routerMustCustody","exactInputParams","performAggregatedSlippageCheck","exactOutputParams","singleHop","exactInputSingleParams","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","exactOutputSingleParams","amountInMaximum","encodeRouteToPath","trades","swap","v2Andv3Trades","V2Trade","numberOfTrades","V3Trade","sampleTrade","inputIsNative","outputIsNative","SelfPermit","calldata","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","value","totalAmountSwapped","chainId","zeroForOne","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","tokenInApprovalType","tokenOutApprovalType","amount0","amount1","useFullPrecision","currencyAmount0","currencyAmount1"],"mappings":"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","sourcesContent":["import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n","import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n}\n","import { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { Protocol } from './protocol'\nimport { IRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (route.protocol == Protocol.V3) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1))\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n      v3Routes = []\n    } else {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n      v2Routes = []\n    }\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      tradeType,\n    })\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\n\nconst ZERO = JSBI.BigInt(0)\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual V2Trade and V3Trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every((swap) => swap.route.protocol == Protocol.V3 || swap.route.protocol == Protocol.V2),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let v2Andv3Trades: (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          v2Andv3Trades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          v2Andv3Trades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        }\n      }\n      trades = v2Andv3Trades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) => numberOfTrades + (trade instanceof V3Trade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH, but with an uncertain input amount\n    if (inputIsNative && sampleTrade.tradeType === TradeType.EXACT_OUTPUT) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0 === totalAmountSwapped.currency.wrapped\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): { positionAmountIn: CurrencyAmount<Currency>; positionAmountOut: CurrencyAmount<Currency> } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}