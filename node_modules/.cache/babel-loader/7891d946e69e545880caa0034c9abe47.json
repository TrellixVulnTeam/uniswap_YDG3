{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { Interface } from '@ethersproject/abi';\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport { abi as IUniswapV2PairABI } from '@uniswap/v2-core/build/IUniswapV2Pair.json';\nimport { computePairAddress, Pair } from '@uniswap/v2-sdk';\nimport { useMemo } from 'react';\nimport { V2_FACTORY_ADDRESSES } from '../constants/addresses';\nimport { useMultipleContractSingleData } from '../state/multicall/hooks';\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\nexport let PairState;\n\n(function (PairState) {\n  PairState[PairState[\"LOADING\"] = 0] = \"LOADING\";\n  PairState[PairState[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PairState[PairState[\"EXISTS\"] = 2] = \"EXISTS\";\n  PairState[PairState[\"INVALID\"] = 3] = \"INVALID\";\n})(PairState || (PairState = {}));\n\nexport function useV2Pairs(currencies) {\n  _s();\n\n  const tokens = useMemo(() => currencies.map(([currencyA, currencyB]) => [currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped]), [currencies]);\n  const pairAddresses = useMemo(() => tokens.map(([tokenA, tokenB]) => {\n    return tokenA && tokenB && tokenA.chainId === tokenB.chainId && !tokenA.equals(tokenB) && V2_FACTORY_ADDRESSES[tokenA.chainId] ? computePairAddress({\n      factoryAddress: V2_FACTORY_ADDRESSES[tokenA.chainId],\n      tokenA,\n      tokenB\n    }) : undefined;\n  }), [tokens]);\n  const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves');\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const {\n        result: reserves,\n        loading\n      } = result;\n      const tokenA = tokens[i][0];\n      const tokenB = tokens[i][1];\n      if (loading) return [PairState.LOADING, null];\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null];\n      if (!reserves) return [PairState.NOT_EXISTS, null];\n      const {\n        reserve0,\n        reserve1\n      } = reserves;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n      return [PairState.EXISTS, new Pair(CurrencyAmount.fromRawAmount(token0, reserve0.toString()), CurrencyAmount.fromRawAmount(token1, reserve1.toString()))];\n    });\n  }, [results, tokens]);\n}\n\n_s(useV2Pairs, \"ZDQnCWgzg6DySe1FP83w6Y8Rdqg=\", false, function () {\n  return [useMultipleContractSingleData];\n});\n\nexport function useV2Pair(tokenA, tokenB) {\n  _s2();\n\n  const inputs = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB]);\n  return useV2Pairs(inputs)[0];\n}\n\n_s2(useV2Pair, \"a7HN08wySA9amXbycgcvsMx0d1I=\", false, function () {\n  return [useV2Pairs];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useV2Pairs.ts"],"names":["Interface","CurrencyAmount","abi","IUniswapV2PairABI","computePairAddress","Pair","useMemo","V2_FACTORY_ADDRESSES","useMultipleContractSingleData","PAIR_INTERFACE","PairState","useV2Pairs","currencies","tokens","map","currencyA","currencyB","wrapped","pairAddresses","tokenA","tokenB","chainId","equals","factoryAddress","undefined","results","result","i","reserves","loading","LOADING","INVALID","NOT_EXISTS","reserve0","reserve1","token0","token1","sortsBefore","EXISTS","fromRawAmount","toString","useV2Pair","inputs"],"mappings":"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","sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount } from '@uniswap/sdk-core'\nimport { abi as IUniswapV2PairABI } from '@uniswap/v2-core/build/IUniswapV2Pair.json'\nimport { computePairAddress, Pair } from '@uniswap/v2-sdk'\nimport { useMemo } from 'react'\n\nimport { V2_FACTORY_ADDRESSES } from '../constants/addresses'\nimport { useMultipleContractSingleData } from '../state/multicall/hooks'\n\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI)\n\nexport enum PairState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function useV2Pairs(currencies: [Currency | undefined, Currency | undefined][]): [PairState, Pair | null][] {\n  const tokens = useMemo(\n    () => currencies.map(([currencyA, currencyB]) => [currencyA?.wrapped, currencyB?.wrapped]),\n    [currencies]\n  )\n\n  const pairAddresses = useMemo(\n    () =>\n      tokens.map(([tokenA, tokenB]) => {\n        return tokenA &&\n          tokenB &&\n          tokenA.chainId === tokenB.chainId &&\n          !tokenA.equals(tokenB) &&\n          V2_FACTORY_ADDRESSES[tokenA.chainId]\n          ? computePairAddress({ factoryAddress: V2_FACTORY_ADDRESSES[tokenA.chainId], tokenA, tokenB })\n          : undefined\n      }),\n    [tokens]\n  )\n\n  const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves')\n\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const { result: reserves, loading } = result\n      const tokenA = tokens[i][0]\n      const tokenB = tokens[i][1]\n\n      if (loading) return [PairState.LOADING, null]\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null]\n      if (!reserves) return [PairState.NOT_EXISTS, null]\n      const { reserve0, reserve1 } = reserves\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n      return [\n        PairState.EXISTS,\n        new Pair(\n          CurrencyAmount.fromRawAmount(token0, reserve0.toString()),\n          CurrencyAmount.fromRawAmount(token1, reserve1.toString())\n        ),\n      ]\n    })\n  }, [results, tokens])\n}\n\nexport function useV2Pair(tokenA?: Currency, tokenB?: Currency): [PairState, Pair | null] {\n  const inputs: [[Currency | undefined, Currency | undefined]] = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB])\n  return useV2Pairs(inputs)[0]\n}\n"]},"metadata":{},"sourceType":"module"}