{"ast":null,"code":"/**\n * Mnemonist TrieMap\n * ==================\n *\n * JavaScript TrieMap implementation based upon plain objects. As such this\n * structure is more a convenience building upon the trie's advantages than\n * a real performant alternative to already existing structures.\n *\n * Note that the Trie is based upon the TrieMap since the underlying machine\n * is the very same. The Trie just does not let you set values and only\n * considers the existence of the given prefixes.\n */\nvar forEach = require('obliterator/foreach'),\n    Iterator = require('obliterator/iterator');\n/**\n * Constants.\n */\n\n\nvar SENTINEL = String.fromCharCode(0);\n/**\n * TrieMap.\n *\n * @constructor\n */\n\nfunction TrieMap(Token) {\n  this.mode = Token === Array ? 'array' : 'string';\n  this.clear();\n}\n/**\n * Method used to clear the trie.\n *\n * @return {undefined}\n */\n\n\nTrieMap.prototype.clear = function () {\n  // Properties\n  this.root = {};\n  this.size = 0;\n};\n/**\n * Method used to set the value of the given prefix in the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @param  {any}          value  - Value for the prefix.\n * @return {TrieMap}\n */\n\n\nTrieMap.prototype.set = function (prefix, value) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token] || (node[token] = {});\n  } // Do we need to increase size?\n\n\n  if (!(SENTINEL in node)) this.size++;\n  node[SENTINEL] = value;\n  return this;\n};\n/**\n * Method used to update the value of the given prefix in the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @param  {(oldValue: any | undefined) => any} updateFunction - Update value visitor callback.\n * @return {TrieMap}\n */\n\n\nTrieMap.prototype.update = function (prefix, updateFunction) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token] || (node[token] = {});\n  } // Do we need to increase size?\n\n\n  if (!(SENTINEL in node)) this.size++;\n  node[SENTINEL] = updateFunction(node[SENTINEL]);\n  return this;\n};\n/**\n * Method used to return the value sitting at the end of the given prefix or\n * undefined if none exist.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @return {any|undefined}\n */\n\n\nTrieMap.prototype.get = function (prefix) {\n  var node = this.root,\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token]; // Prefix does not exist\n\n    if (typeof node === 'undefined') return;\n  }\n\n  if (!(SENTINEL in node)) return;\n  return node[SENTINEL];\n};\n/**\n * Method used to delete a prefix from the trie.\n *\n * @param  {string|array} prefix - Prefix to delete.\n * @return {boolean}\n */\n\n\nTrieMap.prototype.delete = function (prefix) {\n  var node = this.root,\n      toPrune = null,\n      tokenToPrune = null,\n      parent,\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    parent = node;\n    node = node[token]; // Prefix does not exist\n\n    if (typeof node === 'undefined') return false; // Keeping track of a potential branch to prune\n\n    if (toPrune !== null) {\n      if (Object.keys(node).length > 1) {\n        toPrune = null;\n        tokenToPrune = null;\n      }\n    } else {\n      if (Object.keys(node).length < 2) {\n        toPrune = parent;\n        tokenToPrune = token;\n      }\n    }\n  }\n\n  if (!(SENTINEL in node)) return false;\n  this.size--;\n  if (toPrune) delete toPrune[tokenToPrune];else delete node[SENTINEL];\n  return true;\n}; // TODO: add #.prune?\n\n/**\n * Method used to assert whether the given prefix exists in the TrieMap.\n *\n * @param  {string|array} prefix - Prefix to check.\n * @return {boolean}\n */\n\n\nTrieMap.prototype.has = function (prefix) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n    if (typeof node === 'undefined') return false;\n  }\n\n  return SENTINEL in node;\n};\n/**\n * Method used to retrieve every item in the trie with the given prefix.\n *\n * @param  {string|array} prefix - Prefix to query.\n * @return {array}\n */\n\n\nTrieMap.prototype.find = function (prefix) {\n  var isString = typeof prefix === 'string';\n  var node = this.root,\n      matches = [],\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n    if (typeof node === 'undefined') return matches;\n  } // Performing DFS from prefix\n\n\n  var nodeStack = [node],\n      prefixStack = [prefix],\n      k;\n\n  while (nodeStack.length) {\n    prefix = prefixStack.pop();\n    node = nodeStack.pop();\n\n    for (k in node) {\n      if (k === SENTINEL) {\n        matches.push([prefix, node[SENTINEL]]);\n        continue;\n      }\n\n      nodeStack.push(node[k]);\n      prefixStack.push(isString ? prefix + k : prefix.concat(k));\n    }\n  }\n\n  return matches;\n};\n/**\n * Method returning an iterator over the trie's values.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\n\n\nTrieMap.prototype.values = function (prefix) {\n  var node = this.root,\n      nodeStack = [],\n      token,\n      i,\n      l; // Resolving initial prefix\n\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token]; // If the prefix does not exist, we return an empty iterator\n\n      if (typeof node === 'undefined') return Iterator.empty();\n    }\n  }\n\n  nodeStack.push(node);\n  return new Iterator(function () {\n    var currentNode,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n      }\n\n      if (hasValue) return {\n        done: false,\n        value: currentNode[SENTINEL]\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n/**\n * Method returning an iterator over the trie's prefixes.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\n\n\nTrieMap.prototype.prefixes = function (prefix) {\n  var node = this.root,\n      nodeStack = [],\n      prefixStack = [],\n      token,\n      i,\n      l;\n  var isString = this.mode === 'string'; // Resolving initial prefix\n\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token]; // If the prefix does not exist, we return an empty iterator\n\n      if (typeof node === 'undefined') return Iterator.empty();\n    }\n  } else {\n    prefix = isString ? '' : [];\n  }\n\n  nodeStack.push(node);\n  prefixStack.push(prefix);\n  return new Iterator(function () {\n    var currentNode,\n        currentPrefix,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n      currentPrefix = prefixStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n        prefixStack.push(isString ? currentPrefix + k : currentPrefix.concat(k));\n      }\n\n      if (hasValue) return {\n        done: false,\n        value: currentPrefix\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\nTrieMap.prototype.keys = TrieMap.prototype.prefixes;\n/**\n * Method returning an iterator over the trie's entries.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\n\nTrieMap.prototype.entries = function (prefix) {\n  var node = this.root,\n      nodeStack = [],\n      prefixStack = [],\n      token,\n      i,\n      l;\n  var isString = this.mode === 'string'; // Resolving initial prefix\n\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token]; // If the prefix does not exist, we return an empty iterator\n\n      if (typeof node === 'undefined') return Iterator.empty();\n    }\n  } else {\n    prefix = isString ? '' : [];\n  }\n\n  nodeStack.push(node);\n  prefixStack.push(prefix);\n  return new Iterator(function () {\n    var currentNode,\n        currentPrefix,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n      currentPrefix = prefixStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n        prefixStack.push(isString ? currentPrefix + k : currentPrefix.concat(k));\n      }\n\n      if (hasValue) return {\n        done: false,\n        value: [currentPrefix, currentNode[SENTINEL]]\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') TrieMap.prototype[Symbol.iterator] = TrieMap.prototype.entries;\n/**\n * Convenience known methods.\n */\n\nTrieMap.prototype.inspect = function () {\n  var proxy = new Array(this.size);\n  var iterator = this.entries(),\n      step,\n      i = 0;\n\n  while (step = iterator.next(), !step.done) {\n    proxy[i++] = step.value;\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: TrieMap,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') TrieMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = TrieMap.prototype.inspect;\n\nTrieMap.prototype.toJSON = function () {\n  return this.root;\n};\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a trie.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {TrieMap}\n */\n\n\nTrieMap.from = function (iterable) {\n  var trie = new TrieMap();\n  forEach(iterable, function (value, key) {\n    trie.set(key, value);\n  });\n  return trie;\n};\n/**\n * Exporting.\n */\n\n\nTrieMap.SENTINEL = SENTINEL;\nmodule.exports = TrieMap;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/trie-map.js"],"names":["forEach","require","Iterator","SENTINEL","String","fromCharCode","TrieMap","Token","mode","Array","clear","prototype","root","size","set","prefix","value","node","token","i","l","length","update","updateFunction","get","delete","toPrune","tokenToPrune","parent","Object","keys","has","find","isString","matches","nodeStack","prefixStack","k","pop","push","concat","values","empty","currentNode","hasValue","done","prefixes","currentPrefix","entries","Symbol","iterator","inspect","proxy","step","next","defineProperty","enumerable","for","toJSON","from","iterable","trie","key","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,qBAAD,CAArB;AAAA,IACIC,QAAQ,GAAGD,OAAO,CAAC,sBAAD,CADtB;AAGA;AACA;AACA;;;AACA,IAAIE,QAAQ,GAAGC,MAAM,CAACC,YAAP,CAAoB,CAApB,CAAf;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,OAAKC,IAAL,GAAYD,KAAK,KAAKE,KAAV,GAAkB,OAAlB,GAA4B,QAAxC;AACA,OAAKC,KAAL;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAJ,OAAO,CAACK,SAAR,CAAkBD,KAAlB,GAA0B,YAAW;AAEnC;AACA,OAAKE,IAAL,GAAY,EAAZ;AACA,OAAKC,IAAL,GAAY,CAAZ;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAP,OAAO,CAACK,SAAR,CAAkBG,GAAlB,GAAwB,UAASC,MAAT,EAAiBC,KAAjB,EAAwB;AAC9C,MAAIC,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIM,KADJ;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7CD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AAEAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAJ,KAAgBD,IAAI,CAACC,KAAD,CAAJ,GAAc,EAA9B,CAAP;AACD,GAR6C,CAU9C;;;AACA,MAAI,EAAEf,QAAQ,IAAIc,IAAd,CAAJ,EACE,KAAKJ,IAAL;AAEFI,EAAAA,IAAI,CAACd,QAAD,CAAJ,GAAiBa,KAAjB;AAEA,SAAO,IAAP;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAV,OAAO,CAACK,SAAR,CAAkBW,MAAlB,GAA2B,UAASP,MAAT,EAAiBQ,cAAjB,EAAiC;AAC1D,MAAIN,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIM,KADJ;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7CD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AAEAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAJ,KAAgBD,IAAI,CAACC,KAAD,CAAJ,GAAc,EAA9B,CAAP;AACD,GARyD,CAU1D;;;AACA,MAAI,EAAEf,QAAQ,IAAIc,IAAd,CAAJ,EACE,KAAKJ,IAAL;AAEFI,EAAAA,IAAI,CAACd,QAAD,CAAJ,GAAiBoB,cAAc,CAACN,IAAI,CAACd,QAAD,CAAL,CAA/B;AAEA,SAAO,IAAP;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAG,OAAO,CAACK,SAAR,CAAkBa,GAAlB,GAAwB,UAAST,MAAT,EAAiB;AACvC,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIM,KADJ;AAAA,MAEIC,CAFJ;AAAA,MAGIC,CAHJ;;AAKA,OAAKD,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX,CAFyC,CAIzC;;AACA,QAAI,OAAOD,IAAP,KAAgB,WAApB,EACE;AACH;;AAED,MAAI,EAAEd,QAAQ,IAAIc,IAAd,CAAJ,EACE;AAEF,SAAOA,IAAI,CAACd,QAAD,CAAX;AACD,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;;;AACAG,OAAO,CAACK,SAAR,CAAkBc,MAAlB,GAA2B,UAASV,MAAT,EAAiB;AAC1C,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIc,OAAO,GAAG,IADd;AAAA,MAEIC,YAAY,GAAG,IAFnB;AAAA,MAGIC,MAHJ;AAAA,MAIIV,KAJJ;AAAA,MAKIC,CALJ;AAAA,MAMIC,CANJ;;AAQA,OAAKD,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAS,IAAAA,MAAM,GAAGX,IAAT;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX,CAHyC,CAKzC;;AACA,QAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAO,KAAP,CAPuC,CASzC;;AACA,QAAIS,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAIG,MAAM,CAACC,IAAP,CAAYb,IAAZ,EAAkBI,MAAlB,GAA2B,CAA/B,EAAkC;AAChCK,QAAAA,OAAO,GAAG,IAAV;AACAC,QAAAA,YAAY,GAAG,IAAf;AACD;AACF,KALD,MAMK;AACH,UAAIE,MAAM,CAACC,IAAP,CAAYb,IAAZ,EAAkBI,MAAlB,GAA2B,CAA/B,EAAkC;AAChCK,QAAAA,OAAO,GAAGE,MAAV;AACAD,QAAAA,YAAY,GAAGT,KAAf;AACD;AACF;AACF;;AAED,MAAI,EAAEf,QAAQ,IAAIc,IAAd,CAAJ,EACE,OAAO,KAAP;AAEF,OAAKJ,IAAL;AAEA,MAAIa,OAAJ,EACE,OAAOA,OAAO,CAACC,YAAD,CAAd,CADF,KAGE,OAAOV,IAAI,CAACd,QAAD,CAAX;AAEF,SAAO,IAAP;AACD,CA5CD,C,CA8CA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAG,OAAO,CAACK,SAAR,CAAkBoB,GAAlB,GAAwB,UAAShB,MAAT,EAAiB;AACvC,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIM,KADJ;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7CD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX;AAEA,QAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAO,KAAP;AACH;;AAED,SAAOd,QAAQ,IAAIc,IAAnB;AACD,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACAX,OAAO,CAACK,SAAR,CAAkBqB,IAAlB,GAAyB,UAASjB,MAAT,EAAiB;AACxC,MAAIkB,QAAQ,GAAG,OAAOlB,MAAP,KAAkB,QAAjC;AAEA,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIsB,OAAO,GAAG,EADd;AAAA,MAEIhB,KAFJ;AAAA,MAGIC,CAHJ;AAAA,MAIIC,CAJJ;;AAMA,OAAKD,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,IAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX;AAEA,QAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAOiB,OAAP;AACH,GAfuC,CAiBxC;;;AACA,MAAIC,SAAS,GAAG,CAAClB,IAAD,CAAhB;AAAA,MACImB,WAAW,GAAG,CAACrB,MAAD,CADlB;AAAA,MAEIsB,CAFJ;;AAIA,SAAOF,SAAS,CAACd,MAAjB,EAAyB;AACvBN,IAAAA,MAAM,GAAGqB,WAAW,CAACE,GAAZ,EAAT;AACArB,IAAAA,IAAI,GAAGkB,SAAS,CAACG,GAAV,EAAP;;AAEA,SAAKD,CAAL,IAAUpB,IAAV,EAAgB;AACd,UAAIoB,CAAC,KAAKlC,QAAV,EAAoB;AAClB+B,QAAAA,OAAO,CAACK,IAAR,CAAa,CAACxB,MAAD,EAASE,IAAI,CAACd,QAAD,CAAb,CAAb;AACA;AACD;;AAEDgC,MAAAA,SAAS,CAACI,IAAV,CAAetB,IAAI,CAACoB,CAAD,CAAnB;AACAD,MAAAA,WAAW,CAACG,IAAZ,CAAiBN,QAAQ,GAAGlB,MAAM,GAAGsB,CAAZ,GAAgBtB,MAAM,CAACyB,MAAP,CAAcH,CAAd,CAAzC;AACD;AACF;;AAED,SAAOH,OAAP;AACD,CAtCD;AAwCA;AACA;AACA;AACA;AACA;AACA;;;AACA5B,OAAO,CAACK,SAAR,CAAkB8B,MAAlB,GAA2B,UAAS1B,MAAT,EAAiB;AAC1C,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIuB,SAAS,GAAG,EADhB;AAAA,MAEIjB,KAFJ;AAAA,MAGIC,CAHJ;AAAA,MAIIC,CAJJ,CAD0C,CAO1C;;AACA,MAAIL,MAAJ,EAAY;AACV,SAAKI,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,MAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,MAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX,CAFyC,CAIzC;;AACA,UAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAOf,QAAQ,CAACwC,KAAT,EAAP;AACH;AACF;;AAEDP,EAAAA,SAAS,CAACI,IAAV,CAAetB,IAAf;AAEA,SAAO,IAAIf,QAAJ,CAAa,YAAW;AAC7B,QAAIyC,WAAJ;AAAA,QACIC,QAAQ,GAAG,KADf;AAAA,QAEIP,CAFJ;;AAIA,WAAOF,SAAS,CAACd,MAAjB,EAAyB;AACvBsB,MAAAA,WAAW,GAAGR,SAAS,CAACG,GAAV,EAAd;;AAEA,WAAKD,CAAL,IAAUM,WAAV,EAAuB;AACrB,YAAIN,CAAC,KAAKlC,QAAV,EAAoB;AAClByC,UAAAA,QAAQ,GAAG,IAAX;AACA;AACD;;AAEDT,QAAAA,SAAS,CAACI,IAAV,CAAeI,WAAW,CAACN,CAAD,CAA1B;AACD;;AAED,UAAIO,QAAJ,EACE,OAAO;AAACC,QAAAA,IAAI,EAAE,KAAP;AAAc7B,QAAAA,KAAK,EAAE2B,WAAW,CAACxC,QAAD;AAAhC,OAAP;AACH;;AAED,WAAO;AAAC0C,MAAAA,IAAI,EAAE;AAAP,KAAP;AACD,GAtBM,CAAP;AAuBD,CA5CD;AA8CA;AACA;AACA;AACA;AACA;AACA;;;AACAvC,OAAO,CAACK,SAAR,CAAkBmC,QAAlB,GAA6B,UAAS/B,MAAT,EAAiB;AAC5C,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIuB,SAAS,GAAG,EADhB;AAAA,MAEIC,WAAW,GAAG,EAFlB;AAAA,MAGIlB,KAHJ;AAAA,MAIIC,CAJJ;AAAA,MAKIC,CALJ;AAOA,MAAIa,QAAQ,GAAG,KAAKzB,IAAL,KAAc,QAA7B,CAR4C,CAU5C;;AACA,MAAIO,MAAJ,EAAY;AACV,SAAKI,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,MAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,MAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX,CAFyC,CAIzC;;AACA,UAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAOf,QAAQ,CAACwC,KAAT,EAAP;AACH;AACF,GATD,MAUK;AACH3B,IAAAA,MAAM,GAAGkB,QAAQ,GAAG,EAAH,GAAQ,EAAzB;AACD;;AAEDE,EAAAA,SAAS,CAACI,IAAV,CAAetB,IAAf;AACAmB,EAAAA,WAAW,CAACG,IAAZ,CAAiBxB,MAAjB;AAEA,SAAO,IAAIb,QAAJ,CAAa,YAAW;AAC7B,QAAIyC,WAAJ;AAAA,QACII,aADJ;AAAA,QAEIH,QAAQ,GAAG,KAFf;AAAA,QAGIP,CAHJ;;AAKA,WAAOF,SAAS,CAACd,MAAjB,EAAyB;AACvBsB,MAAAA,WAAW,GAAGR,SAAS,CAACG,GAAV,EAAd;AACAS,MAAAA,aAAa,GAAGX,WAAW,CAACE,GAAZ,EAAhB;;AAEA,WAAKD,CAAL,IAAUM,WAAV,EAAuB;AACrB,YAAIN,CAAC,KAAKlC,QAAV,EAAoB;AAClByC,UAAAA,QAAQ,GAAG,IAAX;AACA;AACD;;AAEDT,QAAAA,SAAS,CAACI,IAAV,CAAeI,WAAW,CAACN,CAAD,CAA1B;AACAD,QAAAA,WAAW,CAACG,IAAZ,CAAiBN,QAAQ,GAAGc,aAAa,GAAGV,CAAnB,GAAuBU,aAAa,CAACP,MAAd,CAAqBH,CAArB,CAAhD;AACD;;AAED,UAAIO,QAAJ,EACE,OAAO;AAACC,QAAAA,IAAI,EAAE,KAAP;AAAc7B,QAAAA,KAAK,EAAE+B;AAArB,OAAP;AACH;;AAED,WAAO;AAACF,MAAAA,IAAI,EAAE;AAAP,KAAP;AACD,GAzBM,CAAP;AA0BD,CAtDD;;AAuDAvC,OAAO,CAACK,SAAR,CAAkBmB,IAAlB,GAAyBxB,OAAO,CAACK,SAAR,CAAkBmC,QAA3C;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAxC,OAAO,CAACK,SAAR,CAAkBqC,OAAlB,GAA4B,UAASjC,MAAT,EAAiB;AAC3C,MAAIE,IAAI,GAAG,KAAKL,IAAhB;AAAA,MACIuB,SAAS,GAAG,EADhB;AAAA,MAEIC,WAAW,GAAG,EAFlB;AAAA,MAGIlB,KAHJ;AAAA,MAIIC,CAJJ;AAAA,MAKIC,CALJ;AAOA,MAAIa,QAAQ,GAAG,KAAKzB,IAAL,KAAc,QAA7B,CAR2C,CAU3C;;AACA,MAAIO,MAAJ,EAAY;AACV,SAAKI,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,MAAM,CAACM,MAAvB,EAA+BF,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,MAAAA,KAAK,GAAGH,MAAM,CAACI,CAAD,CAAd;AACAF,MAAAA,IAAI,GAAGA,IAAI,CAACC,KAAD,CAAX,CAFyC,CAIzC;;AACA,UAAI,OAAOD,IAAP,KAAgB,WAApB,EACE,OAAOf,QAAQ,CAACwC,KAAT,EAAP;AACH;AACF,GATD,MAUK;AACH3B,IAAAA,MAAM,GAAGkB,QAAQ,GAAG,EAAH,GAAQ,EAAzB;AACD;;AAEDE,EAAAA,SAAS,CAACI,IAAV,CAAetB,IAAf;AACAmB,EAAAA,WAAW,CAACG,IAAZ,CAAiBxB,MAAjB;AAEA,SAAO,IAAIb,QAAJ,CAAa,YAAW;AAC7B,QAAIyC,WAAJ;AAAA,QACII,aADJ;AAAA,QAEIH,QAAQ,GAAG,KAFf;AAAA,QAGIP,CAHJ;;AAKA,WAAOF,SAAS,CAACd,MAAjB,EAAyB;AACvBsB,MAAAA,WAAW,GAAGR,SAAS,CAACG,GAAV,EAAd;AACAS,MAAAA,aAAa,GAAGX,WAAW,CAACE,GAAZ,EAAhB;;AAEA,WAAKD,CAAL,IAAUM,WAAV,EAAuB;AACrB,YAAIN,CAAC,KAAKlC,QAAV,EAAoB;AAClByC,UAAAA,QAAQ,GAAG,IAAX;AACA;AACD;;AAEDT,QAAAA,SAAS,CAACI,IAAV,CAAeI,WAAW,CAACN,CAAD,CAA1B;AACAD,QAAAA,WAAW,CAACG,IAAZ,CAAiBN,QAAQ,GAAGc,aAAa,GAAGV,CAAnB,GAAuBU,aAAa,CAACP,MAAd,CAAqBH,CAArB,CAAhD;AACD;;AAED,UAAIO,QAAJ,EACE,OAAO;AAACC,QAAAA,IAAI,EAAE,KAAP;AAAc7B,QAAAA,KAAK,EAAE,CAAC+B,aAAD,EAAgBJ,WAAW,CAACxC,QAAD,CAA3B;AAArB,OAAP;AACH;;AAED,WAAO;AAAC0C,MAAAA,IAAI,EAAE;AAAP,KAAP;AACD,GAzBM,CAAP;AA0BD,CAtDD;AAwDA;AACA;AACA;;;AACA,IAAI,OAAOI,MAAP,KAAkB,WAAtB,EACE3C,OAAO,CAACK,SAAR,CAAkBsC,MAAM,CAACC,QAAzB,IAAqC5C,OAAO,CAACK,SAAR,CAAkBqC,OAAvD;AAEF;AACA;AACA;;AACA1C,OAAO,CAACK,SAAR,CAAkBwC,OAAlB,GAA4B,YAAW;AACrC,MAAIC,KAAK,GAAG,IAAI3C,KAAJ,CAAU,KAAKI,IAAf,CAAZ;AAEA,MAAIqC,QAAQ,GAAG,KAAKF,OAAL,EAAf;AAAA,MACIK,IADJ;AAAA,MAEIlC,CAAC,GAAG,CAFR;;AAIA,SAAQkC,IAAI,GAAGH,QAAQ,CAACI,IAAT,EAAP,EAAwB,CAACD,IAAI,CAACR,IAAtC;AACEO,IAAAA,KAAK,CAACjC,CAAC,EAAF,CAAL,GAAakC,IAAI,CAACrC,KAAlB;AADF,GAPqC,CAUrC;;;AACAa,EAAAA,MAAM,CAAC0B,cAAP,CAAsBH,KAAtB,EAA6B,aAA7B,EAA4C;AAC1CpC,IAAAA,KAAK,EAAEV,OADmC;AAE1CkD,IAAAA,UAAU,EAAE;AAF8B,GAA5C;AAKA,SAAOJ,KAAP;AACD,CAjBD;;AAmBA,IAAI,OAAOH,MAAP,KAAkB,WAAtB,EACE3C,OAAO,CAACK,SAAR,CAAkBsC,MAAM,CAACQ,GAAP,CAAW,4BAAX,CAAlB,IAA8DnD,OAAO,CAACK,SAAR,CAAkBwC,OAAhF;;AAEF7C,OAAO,CAACK,SAAR,CAAkB+C,MAAlB,GAA2B,YAAW;AACpC,SAAO,KAAK9C,IAAZ;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAACqD,IAAR,GAAe,UAASC,QAAT,EAAmB;AAChC,MAAIC,IAAI,GAAG,IAAIvD,OAAJ,EAAX;AAEAN,EAAAA,OAAO,CAAC4D,QAAD,EAAW,UAAS5C,KAAT,EAAgB8C,GAAhB,EAAqB;AACrCD,IAAAA,IAAI,CAAC/C,GAAL,CAASgD,GAAT,EAAc9C,KAAd;AACD,GAFM,CAAP;AAIA,SAAO6C,IAAP;AACD,CARD;AAUA;AACA;AACA;;;AACAvD,OAAO,CAACH,QAAR,GAAmBA,QAAnB;AACA4D,MAAM,CAACC,OAAP,GAAiB1D,OAAjB","sourcesContent":["/**\n * Mnemonist TrieMap\n * ==================\n *\n * JavaScript TrieMap implementation based upon plain objects. As such this\n * structure is more a convenience building upon the trie's advantages than\n * a real performant alternative to already existing structures.\n *\n * Note that the Trie is based upon the TrieMap since the underlying machine\n * is the very same. The Trie just does not let you set values and only\n * considers the existence of the given prefixes.\n */\nvar forEach = require('obliterator/foreach'),\n    Iterator = require('obliterator/iterator');\n\n/**\n * Constants.\n */\nvar SENTINEL = String.fromCharCode(0);\n\n/**\n * TrieMap.\n *\n * @constructor\n */\nfunction TrieMap(Token) {\n  this.mode = Token === Array ? 'array' : 'string';\n  this.clear();\n}\n\n/**\n * Method used to clear the trie.\n *\n * @return {undefined}\n */\nTrieMap.prototype.clear = function() {\n\n  // Properties\n  this.root = {};\n  this.size = 0;\n};\n\n/**\n * Method used to set the value of the given prefix in the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @param  {any}          value  - Value for the prefix.\n * @return {TrieMap}\n */\nTrieMap.prototype.set = function(prefix, value) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n\n    node = node[token] || (node[token] = {});\n  }\n\n  // Do we need to increase size?\n  if (!(SENTINEL in node))\n    this.size++;\n\n  node[SENTINEL] = value;\n\n  return this;\n};\n\n/**\n * Method used to update the value of the given prefix in the trie.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @param  {(oldValue: any | undefined) => any} updateFunction - Update value visitor callback.\n * @return {TrieMap}\n */\nTrieMap.prototype.update = function(prefix, updateFunction) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n\n    node = node[token] || (node[token] = {});\n  }\n\n  // Do we need to increase size?\n  if (!(SENTINEL in node))\n    this.size++;\n\n  node[SENTINEL] = updateFunction(node[SENTINEL]);\n\n  return this;\n};\n\n/**\n * Method used to return the value sitting at the end of the given prefix or\n * undefined if none exist.\n *\n * @param  {string|array} prefix - Prefix to follow.\n * @return {any|undefined}\n */\nTrieMap.prototype.get = function(prefix) {\n  var node = this.root,\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n\n    // Prefix does not exist\n    if (typeof node === 'undefined')\n      return;\n  }\n\n  if (!(SENTINEL in node))\n    return;\n\n  return node[SENTINEL];\n};\n\n/**\n * Method used to delete a prefix from the trie.\n *\n * @param  {string|array} prefix - Prefix to delete.\n * @return {boolean}\n */\nTrieMap.prototype.delete = function(prefix) {\n  var node = this.root,\n      toPrune = null,\n      tokenToPrune = null,\n      parent,\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    parent = node;\n    node = node[token];\n\n    // Prefix does not exist\n    if (typeof node === 'undefined')\n      return false;\n\n    // Keeping track of a potential branch to prune\n    if (toPrune !== null) {\n      if (Object.keys(node).length > 1) {\n        toPrune = null;\n        tokenToPrune = null;\n      }\n    }\n    else {\n      if (Object.keys(node).length < 2) {\n        toPrune = parent;\n        tokenToPrune = token;\n      }\n    }\n  }\n\n  if (!(SENTINEL in node))\n    return false;\n\n  this.size--;\n\n  if (toPrune)\n    delete toPrune[tokenToPrune];\n  else\n    delete node[SENTINEL];\n\n  return true;\n};\n\n// TODO: add #.prune?\n\n/**\n * Method used to assert whether the given prefix exists in the TrieMap.\n *\n * @param  {string|array} prefix - Prefix to check.\n * @return {boolean}\n */\nTrieMap.prototype.has = function(prefix) {\n  var node = this.root,\n      token;\n\n  for (var i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n\n    if (typeof node === 'undefined')\n      return false;\n  }\n\n  return SENTINEL in node;\n};\n\n/**\n * Method used to retrieve every item in the trie with the given prefix.\n *\n * @param  {string|array} prefix - Prefix to query.\n * @return {array}\n */\nTrieMap.prototype.find = function(prefix) {\n  var isString = typeof prefix === 'string';\n\n  var node = this.root,\n      matches = [],\n      token,\n      i,\n      l;\n\n  for (i = 0, l = prefix.length; i < l; i++) {\n    token = prefix[i];\n    node = node[token];\n\n    if (typeof node === 'undefined')\n      return matches;\n  }\n\n  // Performing DFS from prefix\n  var nodeStack = [node],\n      prefixStack = [prefix],\n      k;\n\n  while (nodeStack.length) {\n    prefix = prefixStack.pop();\n    node = nodeStack.pop();\n\n    for (k in node) {\n      if (k === SENTINEL) {\n        matches.push([prefix, node[SENTINEL]]);\n        continue;\n      }\n\n      nodeStack.push(node[k]);\n      prefixStack.push(isString ? prefix + k : prefix.concat(k));\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Method returning an iterator over the trie's values.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\nTrieMap.prototype.values = function(prefix) {\n  var node = this.root,\n      nodeStack = [],\n      token,\n      i,\n      l;\n\n  // Resolving initial prefix\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token];\n\n      // If the prefix does not exist, we return an empty iterator\n      if (typeof node === 'undefined')\n        return Iterator.empty();\n    }\n  }\n\n  nodeStack.push(node);\n\n  return new Iterator(function() {\n    var currentNode,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n      }\n\n      if (hasValue)\n        return {done: false, value: currentNode[SENTINEL]};\n    }\n\n    return {done: true};\n  });\n};\n\n/**\n * Method returning an iterator over the trie's prefixes.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\nTrieMap.prototype.prefixes = function(prefix) {\n  var node = this.root,\n      nodeStack = [],\n      prefixStack = [],\n      token,\n      i,\n      l;\n\n  var isString = this.mode === 'string';\n\n  // Resolving initial prefix\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token];\n\n      // If the prefix does not exist, we return an empty iterator\n      if (typeof node === 'undefined')\n        return Iterator.empty();\n    }\n  }\n  else {\n    prefix = isString ? '' : [];\n  }\n\n  nodeStack.push(node);\n  prefixStack.push(prefix);\n\n  return new Iterator(function() {\n    var currentNode,\n        currentPrefix,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n      currentPrefix = prefixStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n        prefixStack.push(isString ? currentPrefix + k : currentPrefix.concat(k));\n      }\n\n      if (hasValue)\n        return {done: false, value: currentPrefix};\n    }\n\n    return {done: true};\n  });\n};\nTrieMap.prototype.keys = TrieMap.prototype.prefixes;\n\n/**\n * Method returning an iterator over the trie's entries.\n *\n * @param  {string|array} [prefix] - Optional starting prefix.\n * @return {Iterator}\n */\nTrieMap.prototype.entries = function(prefix) {\n  var node = this.root,\n      nodeStack = [],\n      prefixStack = [],\n      token,\n      i,\n      l;\n\n  var isString = this.mode === 'string';\n\n  // Resolving initial prefix\n  if (prefix) {\n    for (i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i];\n      node = node[token];\n\n      // If the prefix does not exist, we return an empty iterator\n      if (typeof node === 'undefined')\n        return Iterator.empty();\n    }\n  }\n  else {\n    prefix = isString ? '' : [];\n  }\n\n  nodeStack.push(node);\n  prefixStack.push(prefix);\n\n  return new Iterator(function() {\n    var currentNode,\n        currentPrefix,\n        hasValue = false,\n        k;\n\n    while (nodeStack.length) {\n      currentNode = nodeStack.pop();\n      currentPrefix = prefixStack.pop();\n\n      for (k in currentNode) {\n        if (k === SENTINEL) {\n          hasValue = true;\n          continue;\n        }\n\n        nodeStack.push(currentNode[k]);\n        prefixStack.push(isString ? currentPrefix + k : currentPrefix.concat(k));\n      }\n\n      if (hasValue)\n        return {done: false, value: [currentPrefix, currentNode[SENTINEL]]};\n    }\n\n    return {done: true};\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  TrieMap.prototype[Symbol.iterator] = TrieMap.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nTrieMap.prototype.inspect = function() {\n  var proxy = new Array(this.size);\n\n  var iterator = this.entries(),\n      step,\n      i = 0;\n\n  while ((step = iterator.next(), !step.done))\n    proxy[i++] = step.value;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: TrieMap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  TrieMap.prototype[Symbol.for('nodejs.util.inspect.custom')] = TrieMap.prototype.inspect;\n\nTrieMap.prototype.toJSON = function() {\n  return this.root;\n};\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a trie.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @return {TrieMap}\n */\nTrieMap.from = function(iterable) {\n  var trie = new TrieMap();\n\n  forEach(iterable, function(value, key) {\n    trie.set(key, value);\n  });\n\n  return trie;\n};\n\n/**\n * Exporting.\n */\nTrieMap.SENTINEL = SENTINEL;\nmodule.exports = TrieMap;\n"]},"metadata":{},"sourceType":"script"}