{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { useWeb3React } from '@web3-react/core';\nimport { useEffect, useState } from 'react';\nimport { gnosisSafe, injected } from '../connectors';\nimport { IS_IN_IFRAME, NetworkContextName } from '../constants/misc';\nimport { isMobile } from '../utils/userAgent';\nexport function useActiveWeb3React() {\n  _s();\n\n  const context = useWeb3React();\n  const contextNetwork = useWeb3React(NetworkContextName);\n  return context.active ? context : contextNetwork;\n}\n\n_s(useActiveWeb3React, \"tXu+0ZvK8Ypx1BiJyWHm2i1O0yA=\", false, function () {\n  return [useWeb3React, useWeb3React];\n});\n\nexport function useEagerConnect() {\n  _s2();\n\n  const {\n    activate,\n    active\n  } = useWeb3React();\n  const [tried, setTried] = useState(false); // gnosisSafe.isSafeApp() races a timeout against postMessage, so it delays pageload if we are not in a safe app;\n  // if we are not embedded in an iframe, it is not worth checking\n\n  const [triedSafe, setTriedSafe] = useState(!IS_IN_IFRAME); // first, try connecting to a gnosis safe\n\n  useEffect(() => {\n    if (!triedSafe) {\n      gnosisSafe.isSafeApp().then(loadedInSafe => {\n        if (loadedInSafe) {\n          activate(gnosisSafe, undefined, true).catch(() => {\n            setTriedSafe(true);\n          });\n        } else {\n          setTriedSafe(true);\n        }\n      });\n    }\n  }, [activate, setTriedSafe, triedSafe]); // then, if that fails, try connecting to an injected connector\n\n  useEffect(() => {\n    if (!active && triedSafe) {\n      injected.isAuthorized().then(isAuthorized => {\n        if (isAuthorized) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true);\n          });\n        } else {\n          if (isMobile && window.ethereum) {\n            activate(injected, undefined, true).catch(() => {\n              setTried(true);\n            });\n          } else {\n            setTried(true);\n          }\n        }\n      });\n    }\n  }, [activate, active, triedSafe]); // wait until we get confirmation of a connection to flip the flag\n\n  useEffect(() => {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n  return tried;\n}\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\n\n_s2(useEagerConnect, \"oAmdY5fcSAWmWEu5XJfwsO61OwI=\", false, function () {\n  return [useWeb3React];\n});\n\nexport function useInactiveListener(suppress = false) {\n  _s3();\n\n  const {\n    active,\n    error,\n    activate\n  } = useWeb3React();\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error);\n        });\n      };\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error);\n          });\n        }\n      };\n\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n\n    return undefined;\n  }, [active, error, suppress, activate]);\n}\n\n_s3(useInactiveListener, \"tg+LUTCYzAVRTYzC32Q8yta1BMA=\", false, function () {\n  return [useWeb3React];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/web3.ts"],"names":["useWeb3React","useEffect","useState","gnosisSafe","injected","IS_IN_IFRAME","NetworkContextName","isMobile","useActiveWeb3React","context","contextNetwork","active","useEagerConnect","activate","tried","setTried","triedSafe","setTriedSafe","isSafeApp","then","loadedInSafe","undefined","catch","isAuthorized","window","ethereum","useInactiveListener","suppress","error","on","handleChainChanged","console","handleAccountsChanged","accounts","length","removeListener"],"mappings":"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","sourcesContent":["import { Web3Provider } from '@ethersproject/providers'\nimport { useWeb3React } from '@web3-react/core'\nimport { useEffect, useState } from 'react'\n\nimport { gnosisSafe, injected } from '../connectors'\nimport { IS_IN_IFRAME, NetworkContextName } from '../constants/misc'\nimport { isMobile } from '../utils/userAgent'\n\nexport function useActiveWeb3React() {\n  const context = useWeb3React<Web3Provider>()\n  const contextNetwork = useWeb3React<Web3Provider>(NetworkContextName)\n  return context.active ? context : contextNetwork\n}\n\nexport function useEagerConnect() {\n  const { activate, active } = useWeb3React()\n  const [tried, setTried] = useState(false)\n\n  // gnosisSafe.isSafeApp() races a timeout against postMessage, so it delays pageload if we are not in a safe app;\n  // if we are not embedded in an iframe, it is not worth checking\n  const [triedSafe, setTriedSafe] = useState(!IS_IN_IFRAME)\n\n  // first, try connecting to a gnosis safe\n  useEffect(() => {\n    if (!triedSafe) {\n      gnosisSafe.isSafeApp().then((loadedInSafe) => {\n        if (loadedInSafe) {\n          activate(gnosisSafe, undefined, true).catch(() => {\n            setTriedSafe(true)\n          })\n        } else {\n          setTriedSafe(true)\n        }\n      })\n    }\n  }, [activate, setTriedSafe, triedSafe])\n\n  // then, if that fails, try connecting to an injected connector\n  useEffect(() => {\n    if (!active && triedSafe) {\n      injected.isAuthorized().then((isAuthorized) => {\n        if (isAuthorized) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true)\n          })\n        } else {\n          if (isMobile && window.ethereum) {\n            activate(injected, undefined, true).catch(() => {\n              setTried(true)\n            })\n          } else {\n            setTried(true)\n          }\n        }\n      })\n    }\n  }, [activate, active, triedSafe])\n\n  // wait until we get confirmation of a connection to flip the flag\n  useEffect(() => {\n    if (active) {\n      setTried(true)\n    }\n  }, [active])\n\n  return tried\n}\n\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\nexport function useInactiveListener(suppress = false) {\n  const { active, error, activate } = useWeb3React()\n\n  useEffect(() => {\n    const { ethereum } = window\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch((error) => {\n          console.error('Failed to activate after chain changed', error)\n        })\n      }\n\n      const handleAccountsChanged = (accounts: string[]) => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch((error) => {\n            console.error('Failed to activate after accounts changed', error)\n          })\n        }\n      }\n\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n        }\n      }\n    }\n    return undefined\n  }, [active, error, suppress, activate])\n}\n"]},"metadata":{},"sourceType":"module"}