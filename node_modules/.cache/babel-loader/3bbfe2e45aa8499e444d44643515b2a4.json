{"ast":null,"code":"import _regeneratorRuntime from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3';\nimport { V3_CORE_FACTORY_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport var V3PoolProvider = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of V3PoolProvider.\n   * @param chainId The chain id to use.\n   * @param multicall2Provider The multicall provider to use to get the pools.\n   * @param retryOptions The retry options for each call to the multicall.\n   */\n  function V3PoolProvider(chainId, multicall2Provider) {\n    var retryOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      retries: 2,\n      minTimeout: 50,\n      maxTimeout: 500\n    };\n\n    _classCallCheck(this, V3PoolProvider);\n\n    this.chainId = chainId;\n    this.multicall2Provider = multicall2Provider;\n    this.retryOptions = retryOptions; // Computing pool addresses is slow as it requires hashing, encoding etc.\n    // Addresses never change so can always be cached.\n\n    this.POOL_ADDRESS_CACHE = {};\n  }\n\n  _createClass(V3PoolProvider, [{\n    key: \"getPools\",\n    value: function () {\n      var _getPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenPairs, providerConfig) {\n        var _this = this;\n\n        var poolAddressSet, sortedTokenPairs, sortedPoolAddresses, _iterator, _step, tokenPair, _tokenPair, tokenA, tokenB, feeAmount, _this$getPoolAddress2, _poolAddress, _token3, _token4, _yield$Promise$all, _yield$Promise$all2, slot0Results, liquidityResults, poolAddressToPool, invalidPools, i, slot0Result, liquidityResult, _sortedTokenPairs$i, _token, _token2, _fee, _sortedTokenPairs$i2, token0, token1, fee, slot0, liquidity, pool, poolAddress, poolStrs;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                poolAddressSet = new Set();\n                sortedTokenPairs = [];\n                sortedPoolAddresses = [];\n                _iterator = _createForOfIteratorHelper(tokenPairs);\n                _context.prev = 4;\n\n                _iterator.s();\n\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 17;\n                  break;\n                }\n\n                tokenPair = _step.value;\n                _tokenPair = _slicedToArray(tokenPair, 3), tokenA = _tokenPair[0], tokenB = _tokenPair[1], feeAmount = _tokenPair[2];\n                _this$getPoolAddress2 = this.getPoolAddress(tokenA, tokenB, feeAmount), _poolAddress = _this$getPoolAddress2.poolAddress, _token3 = _this$getPoolAddress2.token0, _token4 = _this$getPoolAddress2.token1;\n\n                if (!poolAddressSet.has(_poolAddress)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 15);\n\n              case 12:\n                poolAddressSet.add(_poolAddress);\n                sortedTokenPairs.push([_token3, _token4, feeAmount]);\n                sortedPoolAddresses.push(_poolAddress);\n\n              case 15:\n                _context.next = 6;\n                break;\n\n              case 17:\n                _context.next = 22;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](4);\n\n                _iterator.e(_context.t0);\n\n              case 22:\n                _context.prev = 22;\n\n                _iterator.f();\n\n                return _context.finish(22);\n\n              case 25:\n                log.debug(\"getPools called with \".concat(tokenPairs.length, \" token pairs. Deduped down to \").concat(poolAddressSet.size));\n                _context.next = 28;\n                return Promise.all([this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig), this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig)]);\n\n              case 28:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                slot0Results = _yield$Promise$all2[0];\n                liquidityResults = _yield$Promise$all2[1];\n                log.info(\"Got liquidity and slot0s for \".concat(poolAddressSet.size, \" pools \").concat((providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) ? \"as of block: \".concat(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber, \".\") : \"\"));\n                poolAddressToPool = {};\n                invalidPools = [];\n                i = 0;\n\n              case 36:\n                if (!(i < sortedPoolAddresses.length)) {\n                  _context.next = 52;\n                  break;\n                }\n\n                slot0Result = slot0Results[i];\n                liquidityResult = liquidityResults[i]; // These properties tell us if a pool is valid and initialized or not.\n\n                if (!(!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) || !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) || slot0Result.result.sqrtPriceX96.eq(0))) {\n                  _context.next = 43;\n                  break;\n                }\n\n                _sortedTokenPairs$i = _slicedToArray(sortedTokenPairs[i], 3), _token = _sortedTokenPairs$i[0], _token2 = _sortedTokenPairs$i[1], _fee = _sortedTokenPairs$i[2];\n                invalidPools.push([_token, _token2, _fee]);\n                return _context.abrupt(\"continue\", 49);\n\n              case 43:\n                _sortedTokenPairs$i2 = _slicedToArray(sortedTokenPairs[i], 3), token0 = _sortedTokenPairs$i2[0], token1 = _sortedTokenPairs$i2[1], fee = _sortedTokenPairs$i2[2];\n                slot0 = slot0Result.result;\n                liquidity = liquidityResult.result[0];\n                pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n                poolAddress = sortedPoolAddresses[i];\n                poolAddressToPool[poolAddress] = pool;\n\n              case 49:\n                i++;\n                _context.next = 36;\n                break;\n\n              case 52:\n                if (invalidPools.length > 0) {\n                  log.info({\n                    invalidPools: _.map(invalidPools, function (_ref) {\n                      var _ref2 = _slicedToArray(_ref, 3),\n                          token0 = _ref2[0],\n                          token1 = _ref2[1],\n                          fee = _ref2[2];\n\n                      return \"\".concat(token0.symbol, \"/\").concat(token1.symbol, \"/\").concat(fee / 10000, \"%\");\n                    })\n                  }, \"\".concat(invalidPools.length, \" pools invalid after checking their slot0 and liquidity results. Dropping.\"));\n                }\n\n                poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n                log.debug({\n                  poolStrs: poolStrs\n                }, \"Found \".concat(poolStrs.length, \" valid pools\"));\n                return _context.abrupt(\"return\", {\n                  getPool: function getPool(tokenA, tokenB, feeAmount) {\n                    var _this$getPoolAddress = _this.getPoolAddress(tokenA, tokenB, feeAmount),\n                        poolAddress = _this$getPoolAddress.poolAddress;\n\n                    return poolAddressToPool[poolAddress];\n                  },\n                  getPoolByAddress: function getPoolByAddress(address) {\n                    return poolAddressToPool[address];\n                  },\n                  getAllPools: function getAllPools() {\n                    return Object.values(poolAddressToPool);\n                  }\n                });\n\n              case 56:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 19, 22, 25]]);\n      }));\n\n      function getPools(_x, _x2) {\n        return _getPools.apply(this, arguments);\n      }\n\n      return getPools;\n    }()\n  }, {\n    key: \"getPoolAddress\",\n    value: function getPoolAddress(tokenA, tokenB, feeAmount) {\n      var _ref3 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],\n          _ref4 = _slicedToArray(_ref3, 2),\n          token0 = _ref4[0],\n          token1 = _ref4[1];\n\n      var cacheKey = \"\".concat(this.chainId, \"/\").concat(token0.address, \"/\").concat(token1.address, \"/\").concat(feeAmount);\n      var cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n\n      if (cachedAddress) {\n        return {\n          poolAddress: cachedAddress,\n          token0: token0,\n          token1: token1\n        };\n      }\n\n      var poolAddress = computePoolAddress({\n        factoryAddress: V3_CORE_FACTORY_ADDRESS,\n        tokenA: token0,\n        tokenB: token1,\n        fee: feeAmount\n      });\n      this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n      return {\n        poolAddress: poolAddress,\n        token0: token0,\n        token1: token1\n      };\n    }\n  }, {\n    key: \"getPoolsData\",\n    value: function () {\n      var _getPoolsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(poolAddresses, functionName, providerConfig) {\n        var _this2 = this;\n\n        var _yield$retry, results, blockNumber;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return retry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          return _context2.abrupt(\"return\", _this2.multicall2Provider.callSameFunctionOnMultipleContracts({\n                            addresses: poolAddresses,\n                            contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                            functionName: functionName,\n                            providerConfig: providerConfig\n                          }));\n\n                        case 1:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })), this.retryOptions);\n\n              case 2:\n                _yield$retry = _context3.sent;\n                results = _yield$retry.results;\n                blockNumber = _yield$retry.blockNumber;\n                log.debug(\"Pool data fetched as of block \".concat(blockNumber));\n                return _context3.abrupt(\"return\", results);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getPoolsData(_x3, _x4, _x5) {\n        return _getPoolsData.apply(this, arguments);\n      }\n\n      return getPoolsData;\n    }()\n  }]);\n\n  return V3PoolProvider;\n}();","map":{"version":3,"sources":["../../../../../src/providers/v3/pool-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computePoolAddress, Pool } from '@uniswap/v3-sdk';\nimport { default as retry } from 'async-retry';\nimport _ from 'lodash';\nimport { IUniswapV3PoolState__factory } from '../../types/v3';\nimport { V3_CORE_FACTORY_ADDRESS } from '../../util/addresses';\nimport { log } from '../../util/log';\nimport { poolToString } from '../../util/routes';\nexport class V3PoolProvider {\n    /**\n     * Creates an instance of V3PoolProvider.\n     * @param chainId The chain id to use.\n     * @param multicall2Provider The multicall provider to use to get the pools.\n     * @param retryOptions The retry options for each call to the multicall.\n     */\n    constructor(chainId, multicall2Provider, retryOptions = {\n        retries: 2,\n        minTimeout: 50,\n        maxTimeout: 500,\n    }) {\n        this.chainId = chainId;\n        this.multicall2Provider = multicall2Provider;\n        this.retryOptions = retryOptions;\n        // Computing pool addresses is slow as it requires hashing, encoding etc.\n        // Addresses never change so can always be cached.\n        this.POOL_ADDRESS_CACHE = {};\n    }\n    async getPools(tokenPairs, providerConfig) {\n        const poolAddressSet = new Set();\n        const sortedTokenPairs = [];\n        const sortedPoolAddresses = [];\n        for (let tokenPair of tokenPairs) {\n            const [tokenA, tokenB, feeAmount] = tokenPair;\n            const { poolAddress, token0, token1 } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n            if (poolAddressSet.has(poolAddress)) {\n                continue;\n            }\n            poolAddressSet.add(poolAddress);\n            sortedTokenPairs.push([token0, token1, feeAmount]);\n            sortedPoolAddresses.push(poolAddress);\n        }\n        log.debug(`getPools called with ${tokenPairs.length} token pairs. Deduped down to ${poolAddressSet.size}`);\n        const [slot0Results, liquidityResults] = await Promise.all([\n            this.getPoolsData(sortedPoolAddresses, 'slot0', providerConfig),\n            this.getPoolsData(sortedPoolAddresses, 'liquidity', providerConfig),\n        ]);\n        log.info(`Got liquidity and slot0s for ${poolAddressSet.size} pools ${(providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber)\n            ? `as of block: ${providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber}.`\n            : ``}`);\n        const poolAddressToPool = {};\n        const invalidPools = [];\n        for (let i = 0; i < sortedPoolAddresses.length; i++) {\n            const slot0Result = slot0Results[i];\n            const liquidityResult = liquidityResults[i];\n            // These properties tell us if a pool is valid and initialized or not.\n            if (!(slot0Result === null || slot0Result === void 0 ? void 0 : slot0Result.success) ||\n                !(liquidityResult === null || liquidityResult === void 0 ? void 0 : liquidityResult.success) ||\n                slot0Result.result.sqrtPriceX96.eq(0)) {\n                const [token0, token1, fee] = sortedTokenPairs[i];\n                invalidPools.push([token0, token1, fee]);\n                continue;\n            }\n            const [token0, token1, fee] = sortedTokenPairs[i];\n            const slot0 = slot0Result.result;\n            const liquidity = liquidityResult.result[0];\n            const pool = new Pool(token0, token1, fee, slot0.sqrtPriceX96.toString(), liquidity.toString(), slot0.tick);\n            const poolAddress = sortedPoolAddresses[i];\n            poolAddressToPool[poolAddress] = pool;\n        }\n        if (invalidPools.length > 0) {\n            log.info({\n                invalidPools: _.map(invalidPools, ([token0, token1, fee]) => `${token0.symbol}/${token1.symbol}/${fee / 10000}%`),\n            }, `${invalidPools.length} pools invalid after checking their slot0 and liquidity results. Dropping.`);\n        }\n        const poolStrs = _.map(Object.values(poolAddressToPool), poolToString);\n        log.debug({ poolStrs }, `Found ${poolStrs.length} valid pools`);\n        return {\n            getPool: (tokenA, tokenB, feeAmount) => {\n                const { poolAddress } = this.getPoolAddress(tokenA, tokenB, feeAmount);\n                return poolAddressToPool[poolAddress];\n            },\n            getPoolByAddress: (address) => poolAddressToPool[address],\n            getAllPools: () => Object.values(poolAddressToPool),\n        };\n    }\n    getPoolAddress(tokenA, tokenB, feeAmount) {\n        const [token0, token1] = tokenA.sortsBefore(tokenB)\n            ? [tokenA, tokenB]\n            : [tokenB, tokenA];\n        const cacheKey = `${this.chainId}/${token0.address}/${token1.address}/${feeAmount}`;\n        const cachedAddress = this.POOL_ADDRESS_CACHE[cacheKey];\n        if (cachedAddress) {\n            return { poolAddress: cachedAddress, token0, token1 };\n        }\n        const poolAddress = computePoolAddress({\n            factoryAddress: V3_CORE_FACTORY_ADDRESS,\n            tokenA: token0,\n            tokenB: token1,\n            fee: feeAmount,\n        });\n        this.POOL_ADDRESS_CACHE[cacheKey] = poolAddress;\n        return { poolAddress, token0, token1 };\n    }\n    async getPoolsData(poolAddresses, functionName, providerConfig) {\n        const { results, blockNumber } = await retry(async () => {\n            return this.multicall2Provider.callSameFunctionOnMultipleContracts({\n                addresses: poolAddresses,\n                contractInterface: IUniswapV3PoolState__factory.createInterface(),\n                functionName: functionName,\n                providerConfig,\n            });\n        }, this.retryOptions);\n        log.debug(`Pool data fetched as of block ${blockNumber}`);\n        return results;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9wcm92aWRlcnMvdjMvcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsa0JBQWtCLEVBQWEsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdEUsT0FBTyxFQUF5QixPQUFPLElBQUksS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXRFLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBOERqRCxNQUFNLE9BQU8sY0FBYztJQUt6Qjs7Ozs7T0FLRztJQUNILFlBQ1ksT0FBZ0IsRUFDaEIsa0JBQXNDLEVBQ3RDLGVBQW1DO1FBQzNDLE9BQU8sRUFBRSxDQUFDO1FBQ1YsVUFBVSxFQUFFLEVBQUU7UUFDZCxVQUFVLEVBQUUsR0FBRztLQUNoQjtRQU5TLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxpQkFBWSxHQUFaLFlBQVksQ0FJckI7UUFqQkgseUVBQXlFO1FBQ3pFLGtEQUFrRDtRQUMxQyx1QkFBa0IsR0FBOEIsRUFBRSxDQUFDO0lBZ0J4RCxDQUFDO0lBRUcsS0FBSyxDQUFDLFFBQVEsQ0FDbkIsVUFBdUMsRUFDdkMsY0FBK0I7UUFFL0IsTUFBTSxjQUFjLEdBQWdCLElBQUksR0FBRyxFQUFVLENBQUM7UUFDdEQsTUFBTSxnQkFBZ0IsR0FBcUMsRUFBRSxDQUFDO1FBQzlELE1BQU0sbUJBQW1CLEdBQWEsRUFBRSxD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"]},"metadata":{},"sourceType":"module"}