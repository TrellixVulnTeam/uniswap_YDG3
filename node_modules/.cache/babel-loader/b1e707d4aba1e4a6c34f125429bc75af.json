{"ast":null,"code":"/**\n * Mnemonist Fixed Reverse Heap\n * =============================\n *\n * Static heap implementation with fixed capacity. It's a \"reverse\" heap\n * because it stores the elements in reverse so we can replace the worst\n * item in logarithmic time. As such, one cannot pop this heap but can only\n * consume it at the end. This structure is very efficient when trying to\n * find the n smallest/largest items from a larger query (k nearest neigbors\n * for instance).\n */\nvar comparators = require('./utils/comparators.js'),\n    Heap = require('./heap.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n/**\n * Helper functions.\n */\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   size    - Heap's true size.\n * @param {number}   i       - Index.\n */\n\nfunction siftUp(compare, heap, size, i) {\n  var endIndex = size,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (rightIndex < endIndex && compare(heap[childIndex], heap[rightIndex]) >= 0) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  Heap.siftDown(compare, heap, startIndex, i);\n}\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} ArrayClass - Array class to use.\n * @param  {function} compare    - Comparison function.\n * @param  {array}    heap       - Array storing the heap's data.\n * @param  {number}   size       - True size of the heap.\n * @return {array}\n */\n\n\nfunction consume(ArrayClass, compare, heap, size) {\n  var l = size,\n      i = l;\n  var array = new ArrayClass(size),\n      lastItem,\n      item;\n\n  while (i > 0) {\n    lastItem = heap[--i];\n\n    if (i !== 0) {\n      item = heap[0];\n      heap[0] = lastItem;\n      siftUp(compare, heap, --size, 0);\n      lastItem = item;\n    }\n\n    array[i] = lastItem;\n  }\n\n  return array;\n}\n/**\n * Binary Minimum FixedReverseHeap.\n *\n * @constructor\n * @param {function} ArrayClass - The class of array to use.\n * @param {function} comparator - Comparator function.\n * @param {number}   capacity   - Maximum number of items to keep.\n */\n\n\nfunction FixedReverseHeap(ArrayClass, comparator, capacity) {\n  // Comparator can be omitted\n  if (arguments.length === 2) {\n    capacity = comparator;\n    comparator = null;\n  }\n\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(capacity);\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof capacity !== 'number' && capacity <= 0) throw new Error('mnemonist/FixedReverseHeap.constructor: capacity should be a number > 0.');\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/FixedReverseHeap.constructor: given comparator should be a function.');\n  this.comparator = reverseComparator(this.comparator);\n}\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\n\n\nFixedReverseHeap.prototype.clear = function () {\n  // Properties\n  this.size = 0;\n};\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\n\n\nFixedReverseHeap.prototype.push = function (item) {\n  // Still some place\n  if (this.size < this.capacity) {\n    this.items[this.size] = item;\n    Heap.siftDown(this.comparator, this.items, 0, this.size);\n    this.size++;\n  } // Heap is full, we need to replace worst item\n  else {\n    if (this.comparator(item, this.items[0]) > 0) Heap.replace(this.comparator, this.items, item);\n  }\n\n  return this.size;\n};\n/**\n * Method used to peek the worst item in the heap.\n *\n * @return {any}\n */\n\n\nFixedReverseHeap.prototype.peek = function () {\n  return this.items[0];\n};\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\n\n\nFixedReverseHeap.prototype.consume = function () {\n  var items = consume(this.ArrayClass, this.comparator, this.items, this.size);\n  this.size = 0;\n  return items;\n};\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\n\n\nFixedReverseHeap.prototype.toArray = function () {\n  return consume(this.ArrayClass, this.comparator, this.items.slice(0, this.size), this.size);\n};\n/**\n * Convenience known methods.\n */\n\n\nFixedReverseHeap.prototype.inspect = function () {\n  var proxy = this.toArray(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: FixedReverseHeap,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') FixedReverseHeap.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedReverseHeap.prototype.inspect;\n/**\n * Exporting.\n */\n\nmodule.exports = FixedReverseHeap;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/fixed-reverse-heap.js"],"names":["comparators","require","Heap","DEFAULT_COMPARATOR","reverseComparator","siftUp","compare","heap","size","i","endIndex","startIndex","item","childIndex","rightIndex","siftDown","consume","ArrayClass","l","array","lastItem","FixedReverseHeap","comparator","capacity","arguments","length","items","clear","Error","prototype","push","replace","peek","toArray","slice","inspect","proxy","Object","defineProperty","value","enumerable","Symbol","for","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Fixed Reverse Heap\n * =============================\n *\n * Static heap implementation with fixed capacity. It's a \"reverse\" heap\n * because it stores the elements in reverse so we can replace the worst\n * item in logarithmic time. As such, one cannot pop this heap but can only\n * consume it at the end. This structure is very efficient when trying to\n * find the n smallest/largest items from a larger query (k nearest neigbors\n * for instance).\n */\nvar comparators = require('./utils/comparators.js'),\n    Heap = require('./heap.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Helper functions.\n */\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   size    - Heap's true size.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, size, i) {\n  var endIndex = size,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  Heap.siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} ArrayClass - Array class to use.\n * @param  {function} compare    - Comparison function.\n * @param  {array}    heap       - Array storing the heap's data.\n * @param  {number}   size       - True size of the heap.\n * @return {array}\n */\nfunction consume(ArrayClass, compare, heap, size) {\n  var l = size,\n      i = l;\n\n  var array = new ArrayClass(size),\n      lastItem,\n      item;\n\n  while (i > 0) {\n    lastItem = heap[--i];\n\n    if (i !== 0) {\n      item = heap[0];\n      heap[0] = lastItem;\n      siftUp(compare, heap, --size, 0);\n      lastItem = item;\n    }\n\n    array[i] = lastItem;\n  }\n\n  return array;\n}\n\n/**\n * Binary Minimum FixedReverseHeap.\n *\n * @constructor\n * @param {function} ArrayClass - The class of array to use.\n * @param {function} comparator - Comparator function.\n * @param {number}   capacity   - Maximum number of items to keep.\n */\nfunction FixedReverseHeap(ArrayClass, comparator, capacity) {\n\n  // Comparator can be omitted\n  if (arguments.length === 2) {\n    capacity = comparator;\n    comparator = null;\n  }\n\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n\n  this.items = new ArrayClass(capacity);\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof capacity !== 'number' && capacity <= 0)\n    throw new Error('mnemonist/FixedReverseHeap.constructor: capacity should be a number > 0.');\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/FixedReverseHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nFixedReverseHeap.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nFixedReverseHeap.prototype.push = function(item) {\n\n  // Still some place\n  if (this.size < this.capacity) {\n    this.items[this.size] = item;\n    Heap.siftDown(this.comparator, this.items, 0, this.size);\n    this.size++;\n  }\n\n  // Heap is full, we need to replace worst item\n  else {\n\n    if (this.comparator(item, this.items[0]) > 0)\n      Heap.replace(this.comparator, this.items, item);\n  }\n\n  return this.size;\n};\n\n/**\n * Method used to peek the worst item in the heap.\n *\n * @return {any}\n */\nFixedReverseHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nFixedReverseHeap.prototype.consume = function() {\n  var items = consume(this.ArrayClass, this.comparator, this.items, this.size);\n  this.size = 0;\n\n  return items;\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nFixedReverseHeap.prototype.toArray = function() {\n  return consume(this.ArrayClass, this.comparator, this.items.slice(0, this.size), this.size);\n};\n\n/**\n * Convenience known methods.\n */\nFixedReverseHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: FixedReverseHeap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  FixedReverseHeap.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedReverseHeap.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = FixedReverseHeap;\n"]},"metadata":{},"sourceType":"script"}