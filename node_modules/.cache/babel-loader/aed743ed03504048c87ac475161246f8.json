{"ast":null,"code":"import { tickToPrice } from '@uniswap/v3-sdk';\nimport JSBI from 'jsbi';\nconst PRICE_FIXED_DIGITS = 8; // Computes the numSurroundingTicks above or below the active tick.\n\nexport default function computeSurroundingTicks(token0, token1, activeTickProcessed, sortedTickData, pivot, ascending) {\n  let previousTickProcessed = { ...activeTickProcessed\n  }; // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n\n  let processedTicks = [];\n\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tickIdx = Number(sortedTickData[i].tickIdx);\n    const currentTickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tickIdx,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tickIdx).toFixed(PRICE_FIXED_DIGITS)\n    }; // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(previousTickProcessed.liquidityActive, JSBI.BigInt(sortedTickData[i].liquidityNet));\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(previousTickProcessed.liquidityActive, previousTickProcessed.liquidityNet);\n    }\n\n    processedTicks.push(currentTickProcessed);\n    previousTickProcessed = currentTickProcessed;\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse();\n  }\n\n  return processedTicks;\n}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/utils/computeSurroundingTicks.ts"],"names":["tickToPrice","JSBI","PRICE_FIXED_DIGITS","computeSurroundingTicks","token0","token1","activeTickProcessed","sortedTickData","pivot","ascending","previousTickProcessed","processedTicks","i","length","tickIdx","Number","currentTickProcessed","liquidityActive","liquidityNet","BigInt","price0","toFixed","add","notEqual","subtract","push","reverse"],"mappings":"AACA,SAASA,WAAT,QAA4B,iBAA5B;AAEA,OAAOC,IAAP,MAAiB,MAAjB;AAGA,MAAMC,kBAAkB,GAAG,CAA3B,C,CAEA;;AACA,eAAe,SAASC,uBAAT,CACbC,MADa,EAEbC,MAFa,EAGbC,mBAHa,EAIbC,cAJa,EAKbC,KALa,EAMbC,SANa,EAOI;AACjB,MAAIC,qBAAoC,GAAG,EACzC,GAAGJ;AADsC,GAA3C,CADiB,CAIjB;AACA;;AACA,MAAIK,cAA+B,GAAG,EAAtC;;AACA,OAAK,IAAIC,CAAC,GAAGJ,KAAK,IAAIC,SAAS,GAAG,CAAH,GAAO,CAAC,CAArB,CAAlB,EAA2CA,SAAS,GAAGG,CAAC,GAAGL,cAAc,CAACM,MAAtB,GAA+BD,CAAC,IAAI,CAAxF,EAA2FH,SAAS,GAAGG,CAAC,EAAJ,GAASA,CAAC,EAA9G,EAAkH;AAChH,UAAME,OAAO,GAAGC,MAAM,CAACR,cAAc,CAACK,CAAD,CAAd,CAAkBE,OAAnB,CAAtB;AACA,UAAME,oBAAmC,GAAG;AAC1CC,MAAAA,eAAe,EAAEP,qBAAqB,CAACO,eADG;AAE1CH,MAAAA,OAF0C;AAG1CI,MAAAA,YAAY,EAAEjB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAH4B;AAI1CE,MAAAA,MAAM,EAAEpB,WAAW,CAACI,MAAD,EAASC,MAAT,EAAiBS,OAAjB,CAAX,CAAqCO,OAArC,CAA6CnB,kBAA7C;AAJkC,KAA5C,CAFgH,CAShH;AACA;AACA;AACA;;AACA,QAAIO,SAAJ,EAAe;AACbO,MAAAA,oBAAoB,CAACC,eAArB,GAAuChB,IAAI,CAACqB,GAAL,CACrCZ,qBAAqB,CAACO,eADe,EAErChB,IAAI,CAACkB,MAAL,CAAYZ,cAAc,CAACK,CAAD,CAAd,CAAkBM,YAA9B,CAFqC,CAAvC;AAID,KALD,MAKO,IAAI,CAACT,SAAD,IAAcR,IAAI,CAACsB,QAAL,CAAcb,qBAAqB,CAACQ,YAApC,EAAkDjB,IAAI,CAACkB,MAAL,CAAY,CAAZ,CAAlD,CAAlB,EAAqF;AAC1F;AACAH,MAAAA,oBAAoB,CAACC,eAArB,GAAuChB,IAAI,CAACuB,QAAL,CACrCd,qBAAqB,CAACO,eADe,EAErCP,qBAAqB,CAACQ,YAFe,CAAvC;AAID;;AAEDP,IAAAA,cAAc,CAACc,IAAf,CAAoBT,oBAApB;AACAN,IAAAA,qBAAqB,GAAGM,oBAAxB;AACD;;AAED,MAAI,CAACP,SAAL,EAAgB;AACdE,IAAAA,cAAc,GAAGA,cAAc,CAACe,OAAf,EAAjB;AACD;;AAED,SAAOf,cAAP;AACD","sourcesContent":["import { Token } from '@uniswap/sdk-core'\nimport { tickToPrice } from '@uniswap/v3-sdk'\nimport { TickProcessed } from 'hooks/usePoolTickData'\nimport JSBI from 'jsbi'\nimport { AllV3TicksQuery } from 'state/data/generated'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Computes the numSurroundingTicks above or below the active tick.\nexport default function computeSurroundingTicks(\n  token0: Token,\n  token1: Token,\n  activeTickProcessed: TickProcessed,\n  sortedTickData: AllV3TicksQuery['ticks'],\n  pivot: number,\n  ascending: boolean\n): TickProcessed[] {\n  let previousTickProcessed: TickProcessed = {\n    ...activeTickProcessed,\n  }\n  // Iterate outwards (either up or down depending on direction) from the active tick,\n  // building active liquidity for every tick.\n  let processedTicks: TickProcessed[] = []\n  for (let i = pivot + (ascending ? 1 : -1); ascending ? i < sortedTickData.length : i >= 0; ascending ? i++ : i--) {\n    const tickIdx = Number(sortedTickData[i].tickIdx)\n    const currentTickProcessed: TickProcessed = {\n      liquidityActive: previousTickProcessed.liquidityActive,\n      tickIdx,\n      liquidityNet: JSBI.BigInt(sortedTickData[i].liquidityNet),\n      price0: tickToPrice(token0, token1, tickIdx).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    // Update the active liquidity.\n    // If we are iterating ascending and we found an initialized tick we immediately apply\n    // it to the current processed tick we are building.\n    // If we are iterating descending, we don't want to apply the net liquidity until the following tick.\n    if (ascending) {\n      currentTickProcessed.liquidityActive = JSBI.add(\n        previousTickProcessed.liquidityActive,\n        JSBI.BigInt(sortedTickData[i].liquidityNet)\n      )\n    } else if (!ascending && JSBI.notEqual(previousTickProcessed.liquidityNet, JSBI.BigInt(0))) {\n      // We are iterating descending, so look at the previous tick and apply any net liquidity.\n      currentTickProcessed.liquidityActive = JSBI.subtract(\n        previousTickProcessed.liquidityActive,\n        previousTickProcessed.liquidityNet\n      )\n    }\n\n    processedTicks.push(currentTickProcessed)\n    previousTickProcessed = currentTickProcessed\n  }\n\n  if (!ascending) {\n    processedTicks = processedTicks.reverse()\n  }\n\n  return processedTicks\n}\n"]},"metadata":{},"sourceType":"module"}