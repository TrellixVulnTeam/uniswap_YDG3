{"ast":null,"code":"/**\n * Mnemonist LRUCache\n * ===================\n *\n * JavaScript implementation of the LRU Cache data structure. To save up\n * memory and allocations this implementation represents its underlying\n * doubly-linked list as static arrays and pointers. Thus, memory is allocated\n * only once at instantiation and JS objects are never created to serve as\n * pointers. This also means this implementation does not trigger too many\n * garbage collections.\n *\n * Note that to save up memory, a LRU Cache can be implemented using a singly\n * linked list by storing predecessors' pointers as hashmap values.\n * However, this means more hashmap lookups and would probably slow the whole\n * thing down. What's more, pointers are not the things taking most space in\n * memory.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n/**\n * LRUCache.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\n\n\nfunction LRUCache(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n  if (typeof this.capacity !== 'number' || this.capacity <= 0) throw new Error('mnemonist/lru-cache: capacity should be positive number.');\n  var PointerArray = typed.getPointerArray(capacity);\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity); // Properties\n\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n}\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\n\n\nLRUCache.prototype.clear = function () {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n};\n/**\n * Method used to splay a value on top.\n *\n * @param  {number}   pointer - Pointer of the value to splay on top.\n * @return {LRUCache}\n */\n\n\nLRUCache.prototype.splayOnTop = function (pointer) {\n  var oldHead = this.head;\n  if (this.head === pointer) return this;\n  var previous = this.backward[pointer],\n      next = this.forward[pointer];\n\n  if (this.tail === pointer) {\n    this.tail = previous;\n  } else {\n    this.backward[next] = previous;\n  }\n\n  this.forward[previous] = next;\n  this.backward[oldHead] = pointer;\n  this.head = pointer;\n  this.forward[pointer] = oldHead;\n  return this;\n};\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\n\n\nLRUCache.prototype.set = function (key, value) {\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items[key];\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n    return;\n  } // The cache is not yet full\n\n\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  } // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    delete this.items[this.K[pointer]];\n  } // Storing key & value\n\n\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value; // Moving the item at the front of the list\n\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n/**\n * Method used to set the value for the given key in the cache\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\n\n\nLRUCache.prototype.setpop = function (key, value) {\n  var oldValue = null;\n  var oldKey = null; // The key already exists, we just need to update the value and splay on top\n\n  var pointer = this.items[key];\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {\n      evicted: false,\n      key: key,\n      value: oldValue\n    };\n  } // The cache is not yet full\n\n\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  } // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    delete this.items[this.K[pointer]];\n  } // Storing key & value\n\n\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value; // Moving the item at the front of the list\n\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer; // Return object if eviction took place, otherwise return null\n\n  if (oldKey) {\n    return {\n      evicted: true,\n      key: oldKey,\n      value: oldValue\n    };\n  } else {\n    return null;\n  }\n};\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\n\n\nLRUCache.prototype.has = function (key) {\n  return key in this.items;\n};\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\n\n\nLRUCache.prototype.get = function (key) {\n  var pointer = this.items[key];\n  if (typeof pointer === 'undefined') return;\n  this.splayOnTop(pointer);\n  return this.V[pointer];\n};\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\n\n\nLRUCache.prototype.peek = function (key) {\n  var pointer = this.items[key];\n  if (typeof pointer === 'undefined') return;\n  return this.V[pointer];\n};\n/**\n * Method used to iterate over the cache's entries using a callback.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\n\n\nLRUCache.prototype.forEach = function (callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n  var i = 0,\n      l = this.size;\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  while (i < l) {\n    callback.call(scope, values[pointer], keys[pointer], this);\n    pointer = forward[pointer];\n    i++;\n  }\n};\n/**\n * Method used to create an iterator over the cache's keys from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\n\n\nLRUCache.prototype.keys = function () {\n  var i = 0,\n      l = this.size;\n  var pointer = this.head,\n      keys = this.K,\n      forward = this.forward;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var key = keys[pointer];\n    i++;\n    if (i < l) pointer = forward[pointer];\n    return {\n      done: false,\n      value: key\n    };\n  });\n};\n/**\n * Method used to create an iterator over the cache's values from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\n\n\nLRUCache.prototype.values = function () {\n  var i = 0,\n      l = this.size;\n  var pointer = this.head,\n      values = this.V,\n      forward = this.forward;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var value = values[pointer];\n    i++;\n    if (i < l) pointer = forward[pointer];\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n/**\n * Method used to create an iterator over the cache's entries from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\n\n\nLRUCache.prototype.entries = function () {\n  var i = 0,\n      l = this.size;\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n  return new Iterator(function () {\n    if (i >= l) return {\n      done: true\n    };\n    var key = keys[pointer],\n        value = values[pointer];\n    i++;\n    if (i < l) pointer = forward[pointer];\n    return {\n      done: false,\n      value: [key, value]\n    };\n  });\n};\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\n\n\nif (typeof Symbol !== 'undefined') LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n/**\n * Convenience known methods.\n */\n\nLRUCache.prototype.inspect = function () {\n  var proxy = new Map();\n  var iterator = this.entries(),\n      step;\n\n  while (step = iterator.next(), !step.done) {\n    proxy.set(step.value[0], step.value[1]);\n  } // Trick so that node displays the name of the constructor\n\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: LRUCache,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUCache}\n */\n\nLRUCache.from = function (iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n    if (typeof capacity !== 'number') throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  } else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUCache(Keys, Values, capacity);\n  forEach(iterable, function (value, key) {\n    cache.set(key, value);\n  });\n  return cache;\n};\n/**\n * Exporting.\n */\n\n\nmodule.exports = LRUCache;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/lru-cache.js"],"names":["Iterator","require","forEach","typed","iterables","LRUCache","Keys","Values","capacity","arguments","length","Error","PointerArray","getPointerArray","forward","backward","K","Array","V","size","head","tail","items","prototype","clear","splayOnTop","pointer","oldHead","previous","next","set","key","value","setpop","oldValue","oldKey","evicted","has","get","peek","callback","scope","i","l","keys","values","call","done","entries","Symbol","iterator","inspect","proxy","Map","step","Object","defineProperty","enumerable","for","from","iterable","guessLength","cache","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist LRUCache\n * ===================\n *\n * JavaScript implementation of the LRU Cache data structure. To save up\n * memory and allocations this implementation represents its underlying\n * doubly-linked list as static arrays and pointers. Thus, memory is allocated\n * only once at instantiation and JS objects are never created to serve as\n * pointers. This also means this implementation does not trigger too many\n * garbage collections.\n *\n * Note that to save up memory, a LRU Cache can be implemented using a singly\n * linked list by storing predecessors' pointers as hashmap values.\n * However, this means more hashmap lookups and would probably slow the whole\n * thing down. What's more, pointers are not the things taking most space in\n * memory.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n\n/**\n * LRUCache.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\nfunction LRUCache(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n\n  if (typeof this.capacity !== 'number' || this.capacity <= 0)\n    throw new Error('mnemonist/lru-cache: capacity should be positive number.');\n\n  var PointerArray = typed.getPointerArray(capacity);\n\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);\n\n  // Properties\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nLRUCache.prototype.clear = function() {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n};\n\n/**\n * Method used to splay a value on top.\n *\n * @param  {number}   pointer - Pointer of the value to splay on top.\n * @return {LRUCache}\n */\nLRUCache.prototype.splayOnTop = function(pointer) {\n  var oldHead = this.head;\n\n  if (this.head === pointer)\n    return this;\n\n  var previous = this.backward[pointer],\n      next = this.forward[pointer];\n\n  if (this.tail === pointer) {\n    this.tail = previous;\n  }\n  else {\n    this.backward[next] = previous;\n  }\n\n  this.forward[previous] = next;\n\n  this.backward[oldHead] = pointer;\n  this.head = pointer;\n  this.forward[pointer] = oldHead;\n\n  return this;\n};\n\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\nLRUCache.prototype.set = function(key, value) {\n\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items[key];\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n\n    return;\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    delete this.items[this.K[pointer]];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n\n/**\n * Method used to set the value for the given key in the cache\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\nLRUCache.prototype.setpop = function(key, value) {\n  var oldValue = null;\n  var oldKey = null;\n  // The key already exists, we just need to update the value and splay on top\n  var pointer = this.items[key];\n\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {evicted: false, key: key, value: oldValue};\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    delete this.items[this.K[pointer]];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n\n  // Return object if eviction took place, otherwise return null\n  if (oldKey) {\n    return {evicted: true, key: oldKey, value: oldValue};\n  }\n  else {\n    return null;\n  }\n};\n\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\nLRUCache.prototype.has = function(key) {\n  return key in this.items;\n};\n\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.get = function(key) {\n  var pointer = this.items[key];\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  this.splayOnTop(pointer);\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.peek = function(key) {\n    var pointer = this.items[key];\n\n    if (typeof pointer === 'undefined')\n        return;\n\n    return this.V[pointer];\n};\n\n/**\n * Method used to iterate over the cache's entries using a callback.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nLRUCache.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  while (i < l) {\n\n    callback.call(scope, values[pointer], keys[pointer], this);\n    pointer = forward[pointer];\n\n    i++;\n  }\n};\n\n/**\n * Method used to create an iterator over the cache's keys from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.keys = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: key\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's values from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.values = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's entries from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.entries = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer],\n        value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: [key, value]\n    };\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nLRUCache.prototype.inspect = function() {\n  var proxy = new Map();\n\n  var iterator = this.entries(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    proxy.set(step.value[0], step.value[1]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: LRUCache,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUCache}\n */\nLRUCache.from = function(iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n  else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUCache(Keys, Values, capacity);\n\n  forEach(iterable, function(value, key) {\n    cache.set(key, value);\n  });\n\n  return cache;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = LRUCache;\n"]},"metadata":{},"sourceType":"script"}