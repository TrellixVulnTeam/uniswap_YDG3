{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { skipToken } from '@reduxjs/toolkit/query/react';\nimport { Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk';\nimport JSBI from 'jsbi';\nimport { useMemo } from 'react';\nimport { useAllV3TicksQuery } from 'state/data/enhanced';\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks';\nimport { PoolState, usePool } from './usePools';\nconst PRICE_FIXED_DIGITS = 8; // Tick with fields parsed to JSBIs, and active liquidity computed.\n\nconst getActiveTick = (tickCurrent, feeAmount) => tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined; // Fetches all ticks for a given pool\n\n\nexport function useAllV3Ticks(currencyA, currencyB, feeAmount) {\n  _s();\n\n  const poolAddress = currencyA && currencyB && feeAmount ? Pool.getAddress(currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped, currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped, feeAmount) : undefined;\n  const {\n    isLoading,\n    isError,\n    error,\n    isUninitialized,\n    data\n  } = useAllV3TicksQuery(poolAddress ? {\n    poolAddress: poolAddress === null || poolAddress === void 0 ? void 0 : poolAddress.toLowerCase(),\n    skip: 0\n  } : skipToken, {\n    pollingInterval: 30000\n  });\n  return {\n    isLoading,\n    isUninitialized,\n    isError,\n    error,\n    ticks: data === null || data === void 0 ? void 0 : data.ticks\n  };\n}\n\n_s(useAllV3Ticks, \"wqhCCjIR3EBuCVygcvLKAOt9R84=\", false, function () {\n  return [useAllV3TicksQuery];\n});\n\nexport function usePoolActiveLiquidity(currencyA, currencyB, feeAmount) {\n  _s2();\n\n  const pool = usePool(currencyA, currencyB, feeAmount); // Find nearest valid tick for pool in case tick is not initialized.\n\n  const activeTick = useMemo(() => {\n    var _pool$;\n\n    return getActiveTick((_pool$ = pool[1]) === null || _pool$ === void 0 ? void 0 : _pool$.tickCurrent, feeAmount);\n  }, [pool, feeAmount]);\n  const {\n    isLoading,\n    isUninitialized,\n    isError,\n    error,\n    ticks\n  } = useAllV3Ticks(currencyA, currencyB, feeAmount);\n  return useMemo(() => {\n    var _pool$1$liquidity, _pool$2;\n\n    if (!currencyA || !currencyB || activeTick === undefined || pool[0] !== PoolState.EXISTS || !ticks || ticks.length === 0 || isLoading || isUninitialized) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n\n    const token0 = currencyA === null || currencyA === void 0 ? void 0 : currencyA.wrapped;\n    const token1 = currencyB === null || currencyB === void 0 ? void 0 : currencyB.wrapped; // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n\n    const pivot = ticks.findIndex(({\n      tickIdx\n    }) => tickIdx > activeTick) - 1;\n\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found');\n      return {\n        isLoading,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined\n      };\n    }\n\n    const activeTickProcessed = {\n      liquidityActive: JSBI.BigInt((_pool$1$liquidity = (_pool$2 = pool[1]) === null || _pool$2 === void 0 ? void 0 : _pool$2.liquidity) !== null && _pool$1$liquidity !== void 0 ? _pool$1$liquidity : 0),\n      tickIdx: activeTick,\n      liquidityNet: Number(ticks[pivot].tickIdx) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS)\n    };\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true);\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false);\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks);\n    return {\n      isLoading,\n      isUninitialized,\n      isError,\n      error,\n      activeTick,\n      data: ticksProcessed\n    };\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, isUninitialized, isError, error]);\n}\n\n_s2(usePoolActiveLiquidity, \"+7Zt83lQFSwENJUzf0/oLeKJZok=\", false, function () {\n  return [usePool, useAllV3Ticks];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/usePoolTickData.ts"],"names":["skipToken","Pool","TICK_SPACINGS","tickToPrice","JSBI","useMemo","useAllV3TicksQuery","computeSurroundingTicks","PoolState","usePool","PRICE_FIXED_DIGITS","getActiveTick","tickCurrent","feeAmount","Math","floor","undefined","useAllV3Ticks","currencyA","currencyB","poolAddress","getAddress","wrapped","isLoading","isError","error","isUninitialized","data","toLowerCase","skip","pollingInterval","ticks","usePoolActiveLiquidity","pool","activeTick","EXISTS","length","LOADING","token0","token1","pivot","findIndex","tickIdx","console","activeTickProcessed","liquidityActive","BigInt","liquidity","liquidityNet","Number","price0","toFixed","subsequentTicks","previousTicks","ticksProcessed","concat"],"mappings":"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","sourcesContent":["import { skipToken } from '@reduxjs/toolkit/query/react'\nimport { Currency } from '@uniswap/sdk-core'\nimport { FeeAmount, Pool, TICK_SPACINGS, tickToPrice } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\nimport ms from 'ms.macro'\nimport { useMemo } from 'react'\nimport { useAllV3TicksQuery } from 'state/data/enhanced'\nimport { AllV3TicksQuery } from 'state/data/generated'\nimport computeSurroundingTicks from 'utils/computeSurroundingTicks'\n\nimport { PoolState, usePool } from './usePools'\n\nconst PRICE_FIXED_DIGITS = 8\n\n// Tick with fields parsed to JSBIs, and active liquidity computed.\nexport interface TickProcessed {\n  tickIdx: number\n  liquidityActive: JSBI\n  liquidityNet: JSBI\n  price0: string\n}\n\nconst getActiveTick = (tickCurrent: number | undefined, feeAmount: FeeAmount | undefined) =>\n  tickCurrent && feeAmount ? Math.floor(tickCurrent / TICK_SPACINGS[feeAmount]) * TICK_SPACINGS[feeAmount] : undefined\n\n// Fetches all ticks for a given pool\nexport function useAllV3Ticks(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n) {\n  const poolAddress =\n    currencyA && currencyB && feeAmount ? Pool.getAddress(currencyA?.wrapped, currencyB?.wrapped, feeAmount) : undefined\n\n  const { isLoading, isError, error, isUninitialized, data } = useAllV3TicksQuery(\n    poolAddress ? { poolAddress: poolAddress?.toLowerCase(), skip: 0 } : skipToken,\n    {\n      pollingInterval: ms`30s`,\n    }\n  )\n\n  return {\n    isLoading,\n    isUninitialized,\n    isError,\n    error,\n    ticks: data?.ticks as AllV3TicksQuery['ticks'],\n  }\n}\n\nexport function usePoolActiveLiquidity(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined,\n  feeAmount: FeeAmount | undefined\n): {\n  isLoading: boolean\n  isUninitialized: boolean\n  isError: boolean\n  error: any\n  activeTick: number | undefined\n  data: TickProcessed[] | undefined\n} {\n  const pool = usePool(currencyA, currencyB, feeAmount)\n\n  // Find nearest valid tick for pool in case tick is not initialized.\n  const activeTick = useMemo(() => getActiveTick(pool[1]?.tickCurrent, feeAmount), [pool, feeAmount])\n\n  const { isLoading, isUninitialized, isError, error, ticks } = useAllV3Ticks(currencyA, currencyB, feeAmount)\n\n  return useMemo(() => {\n    if (\n      !currencyA ||\n      !currencyB ||\n      activeTick === undefined ||\n      pool[0] !== PoolState.EXISTS ||\n      !ticks ||\n      ticks.length === 0 ||\n      isLoading ||\n      isUninitialized\n    ) {\n      return {\n        isLoading: isLoading || pool[0] === PoolState.LOADING,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const token0 = currencyA?.wrapped\n    const token1 = currencyB?.wrapped\n\n    // find where the active tick would be to partition the array\n    // if the active tick is initialized, the pivot will be an element\n    // if not, take the previous tick as pivot\n    const pivot = ticks.findIndex(({ tickIdx }) => tickIdx > activeTick) - 1\n\n    if (pivot < 0) {\n      // consider setting a local error\n      console.error('TickData pivot not found')\n      return {\n        isLoading,\n        isUninitialized,\n        isError,\n        error,\n        activeTick,\n        data: undefined,\n      }\n    }\n\n    const activeTickProcessed: TickProcessed = {\n      liquidityActive: JSBI.BigInt(pool[1]?.liquidity ?? 0),\n      tickIdx: activeTick,\n      liquidityNet:\n        Number(ticks[pivot].tickIdx) === activeTick ? JSBI.BigInt(ticks[pivot].liquidityNet) : JSBI.BigInt(0),\n      price0: tickToPrice(token0, token1, activeTick).toFixed(PRICE_FIXED_DIGITS),\n    }\n\n    const subsequentTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, true)\n\n    const previousTicks = computeSurroundingTicks(token0, token1, activeTickProcessed, ticks, pivot, false)\n\n    const ticksProcessed = previousTicks.concat(activeTickProcessed).concat(subsequentTicks)\n\n    return {\n      isLoading,\n      isUninitialized,\n      isError,\n      error,\n      activeTick,\n      data: ticksProcessed,\n    }\n  }, [currencyA, currencyB, activeTick, pool, ticks, isLoading, isUninitialized, isError, error])\n}\n"]},"metadata":{},"sourceType":"module"}