{"ast":null,"code":"/* eslint no-constant-condition: 0 */\n\n/**\n * Mnemonist Merge Helpers\n * ========================\n *\n * Various merge algorithms used to handle sorted lists. Note that the given\n * functions are optimized and won't accept mixed arguments.\n *\n * Note: maybe this piece of code belong to sortilege, along with binary-search.\n */\nvar typed = require('./typed-arrays.js'),\n    isArrayLike = require('./iterables.js').isArrayLike,\n    binarySearch = require('./binary-search.js'),\n    FibonacciHeap = require('../fibonacci-heap.js'); // TODO: update to use exponential search\n// TODO: when not knowing final length => should use plain arrays rather than\n// same type as input\n\n/**\n * Merge two sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\n\n\nfunction mergeArrays(a, b) {\n  // One of the arrays is empty\n  if (a.length === 0) return b.slice();\n  if (b.length === 0) return a.slice(); // Finding min array\n\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  } // If array have non overlapping ranges, we can just concatenate them\n\n\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n\n  if (aEnd <= bStart) {\n    if (typed.isTypedArray(a)) return typed.concat(a, b);\n    return a.concat(b);\n  } // Initializing target\n\n\n  var array = new a.constructor(a.length + b.length); // Iterating until we overlap\n\n  var i, l, v;\n\n  for (i = 0, l = a.length; i < l; i++) {\n    v = a[i];\n    if (v <= bStart) array[i] = v;else break;\n  } // Handling overlap\n\n\n  var aPointer = i,\n      aLength = a.length,\n      bPointer = 0,\n      bLength = b.length,\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead <= bHead) {\n      array[i++] = aHead;\n      aPointer++;\n    } else {\n      array[i++] = bHead;\n      bPointer++;\n    }\n  } // Filling\n\n\n  while (aPointer < aLength) array[i++] = a[aPointer++];\n\n  while (bPointer < bLength) array[i++] = b[bPointer++];\n\n  return array;\n}\n/**\n * Perform the union of two already unique sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\n\n\nfunction unionUniqueArrays(a, b) {\n  // One of the arrays is empty\n  if (a.length === 0) return b.slice();\n  if (b.length === 0) return a.slice(); // Finding min array\n\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  } // If array have non overlapping ranges, we can just concatenate them\n\n\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n\n  if (aEnd < bStart) {\n    if (typed.isTypedArray(a)) return typed.concat(a, b);\n    return a.concat(b);\n  } // Initializing target\n\n\n  var array = new a.constructor(); // Iterating until we overlap\n\n  var i, l, v;\n\n  for (i = 0, l = a.length; i < l; i++) {\n    v = a[i];\n    if (v < bStart) array.push(v);else break;\n  } // Handling overlap\n\n\n  var aPointer = i,\n      aLength = a.length,\n      bPointer = 0,\n      bLength = b.length,\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead <= bHead) {\n      if (array.length === 0 || array[array.length - 1] !== aHead) array.push(aHead);\n      aPointer++;\n    } else {\n      if (array.length === 0 || array[array.length - 1] !== bHead) array.push(bHead);\n      bPointer++;\n    }\n  } // Filling\n  // TODO: it's possible to optimize a bit here, since the condition is only\n  // relevant the first time\n\n\n  while (aPointer < aLength) {\n    aHead = a[aPointer++];\n    if (array.length === 0 || array[array.length - 1] !== aHead) array.push(aHead);\n  }\n\n  while (bPointer < bLength) {\n    bHead = b[bPointer++];\n    if (array.length === 0 || array[array.length - 1] !== bHead) array.push(bHead);\n  }\n\n  return array;\n}\n/**\n * Perform the intersection of two already unique sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\n\n\nexports.intersectionUniqueArrays = function (a, b) {\n  // One of the arrays is empty\n  if (a.length === 0 || b.length === 0) return new a.constructor(0); // Finding min array\n\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  } // If array have non overlapping ranges, there is no intersection\n\n\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n  if (aEnd < bStart) return new a.constructor(0); // Initializing target\n\n  var array = new a.constructor(); // Handling overlap\n\n  var aPointer = binarySearch.lowerBound(a, bStart),\n      aLength = a.length,\n      bPointer = 0,\n      bLength = binarySearch.upperBound(b, aEnd),\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead < bHead) {\n      aPointer = binarySearch.lowerBound(a, bHead, aPointer + 1);\n    } else if (aHead > bHead) {\n      bPointer = binarySearch.lowerBound(b, aHead, bPointer + 1);\n    } else {\n      array.push(aHead);\n      aPointer++;\n      bPointer++;\n    }\n  }\n\n  return array;\n};\n/**\n * Merge k sorted array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\n\n\nfunction kWayMergeArrays(arrays) {\n  var length = 0,\n      max = -Infinity,\n      al,\n      i,\n      l;\n  var filtered = [];\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length;\n    if (al === 0) continue;\n    filtered.push(arrays[i]);\n    length += al;\n    if (al > max) max = al;\n  }\n\n  if (filtered.length === 0) return new arrays[0].constructor(0);\n  if (filtered.length === 1) return filtered[0].slice();\n  if (filtered.length === 2) return mergeArrays(filtered[0], filtered[1]);\n  arrays = filtered;\n  var array = new arrays[0].constructor(length);\n  var PointerArray = typed.getPointerArray(max);\n  var pointers = new PointerArray(arrays.length); // TODO: benchmark vs. a binomial heap\n\n  var heap = new FibonacciHeap(function (a, b) {\n    a = arrays[a][pointers[a]];\n    b = arrays[b][pointers[b]];\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n\n  for (i = 0; i < l; i++) heap.push(i);\n\n  i = 0;\n  var p, v;\n\n  while (heap.size) {\n    p = heap.pop();\n    v = arrays[p][pointers[p]++];\n    array[i++] = v;\n    if (pointers[p] < arrays[p].length) heap.push(p);\n  }\n\n  return array;\n}\n/**\n * Perform the union of k sorted unique array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\n\n\nfunction kWayUnionUniqueArrays(arrays) {\n  var max = -Infinity,\n      al,\n      i,\n      l;\n  var filtered = [];\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length;\n    if (al === 0) continue;\n    filtered.push(arrays[i]);\n    if (al > max) max = al;\n  }\n\n  if (filtered.length === 0) return new arrays[0].constructor(0);\n  if (filtered.length === 1) return filtered[0].slice();\n  if (filtered.length === 2) return unionUniqueArrays(filtered[0], filtered[1]);\n  arrays = filtered;\n  var array = new arrays[0].constructor();\n  var PointerArray = typed.getPointerArray(max);\n  var pointers = new PointerArray(arrays.length); // TODO: benchmark vs. a binomial heap\n\n  var heap = new FibonacciHeap(function (a, b) {\n    a = arrays[a][pointers[a]];\n    b = arrays[b][pointers[b]];\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n\n  for (i = 0; i < l; i++) heap.push(i);\n\n  var p, v;\n\n  while (heap.size) {\n    p = heap.pop();\n    v = arrays[p][pointers[p]++];\n    if (array.length === 0 || array[array.length - 1] !== v) array.push(v);\n    if (pointers[p] < arrays[p].length) heap.push(p);\n  }\n\n  return array;\n}\n/**\n * Perform the intersection of k sorted array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\n\n\nexports.kWayIntersectionUniqueArrays = function (arrays) {\n  var max = -Infinity,\n      maxStart = -Infinity,\n      minEnd = Infinity,\n      first,\n      last,\n      al,\n      i,\n      l;\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length; // If one of the arrays is empty, so is the intersection\n\n    if (al === 0) return [];\n    if (al > max) max = al;\n    first = arrays[i][0];\n    last = arrays[i][al - 1];\n    if (first > maxStart) maxStart = first;\n    if (last < minEnd) minEnd = last;\n  } // Full overlap is impossible\n\n\n  if (maxStart > minEnd) return []; // Only one value\n\n  if (maxStart === minEnd) return [maxStart]; // NOTE: trying to outsmart I(D,I(C,I(A,B))) is pointless unfortunately...\n  // NOTE: I tried to be very clever about bounds but it does not seem\n  // to improve the performance of the algorithm.\n\n  var a,\n      b,\n      array = arrays[0],\n      aPointer,\n      bPointer,\n      aLimit,\n      bLimit,\n      aHead,\n      bHead,\n      start = maxStart;\n\n  for (i = 1; i < l; i++) {\n    a = array;\n    b = arrays[i]; // Change that to `[]` and observe some perf drops on V8...\n\n    array = new Array();\n    aPointer = 0;\n    bPointer = binarySearch.lowerBound(b, start);\n    aLimit = a.length;\n    bLimit = b.length;\n\n    while (aPointer < aLimit && bPointer < bLimit) {\n      aHead = a[aPointer];\n      bHead = b[bPointer];\n\n      if (aHead < bHead) {\n        aPointer = binarySearch.lowerBound(a, bHead, aPointer + 1);\n      } else if (aHead > bHead) {\n        bPointer = binarySearch.lowerBound(b, aHead, bPointer + 1);\n      } else {\n        array.push(aHead);\n        aPointer++;\n        bPointer++;\n      }\n    }\n\n    if (array.length === 0) return array;\n    start = array[0];\n  }\n\n  return array;\n};\n/**\n * Variadic merging all of the given arrays.\n *\n * @param  {...array}\n * @return {array}\n */\n\n\nexports.merge = function () {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0])) return mergeArrays(arguments[0], arguments[1]);\n  } else {\n    if (isArrayLike(arguments[0])) return kWayMergeArrays(arguments);\n  }\n\n  return null;\n};\n/**\n * Variadic function performing the union of all the given unique arrays.\n *\n * @param  {...array}\n * @return {array}\n */\n\n\nexports.unionUnique = function () {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0])) return unionUniqueArrays(arguments[0], arguments[1]);\n  } else {\n    if (isArrayLike(arguments[0])) return kWayUnionUniqueArrays(arguments);\n  }\n\n  return null;\n};\n/**\n * Variadic function performing the intersection of all the given unique arrays.\n *\n * @param  {...array}\n * @return {array}\n */\n\n\nexports.intersectionUnique = function () {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0])) return exports.intersectionUniqueArrays(arguments[0], arguments[1]);\n  } else {\n    if (isArrayLike(arguments[0])) return exports.kWayIntersectionUniqueArrays(arguments);\n  }\n\n  return null;\n};","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/utils/merge.js"],"names":["typed","require","isArrayLike","binarySearch","FibonacciHeap","mergeArrays","a","b","length","slice","tmp","aEnd","bStart","isTypedArray","concat","array","constructor","i","l","v","aPointer","aLength","bPointer","bLength","aHead","bHead","unionUniqueArrays","push","exports","intersectionUniqueArrays","lowerBound","upperBound","kWayMergeArrays","arrays","max","Infinity","al","filtered","PointerArray","getPointerArray","pointers","heap","p","size","pop","kWayUnionUniqueArrays","kWayIntersectionUniqueArrays","maxStart","minEnd","first","last","aLimit","bLimit","start","Array","merge","arguments","unionUnique","intersectionUnique"],"mappings":"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","sourcesContent":["/* eslint no-constant-condition: 0 */\n/**\n * Mnemonist Merge Helpers\n * ========================\n *\n * Various merge algorithms used to handle sorted lists. Note that the given\n * functions are optimized and won't accept mixed arguments.\n *\n * Note: maybe this piece of code belong to sortilege, along with binary-search.\n */\nvar typed = require('./typed-arrays.js'),\n    isArrayLike = require('./iterables.js').isArrayLike,\n    binarySearch = require('./binary-search.js'),\n    FibonacciHeap = require('../fibonacci-heap.js');\n\n// TODO: update to use exponential search\n// TODO: when not knowing final length => should use plain arrays rather than\n// same type as input\n\n/**\n * Merge two sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\nfunction mergeArrays(a, b) {\n\n  // One of the arrays is empty\n  if (a.length === 0)\n    return b.slice();\n  if (b.length === 0)\n    return a.slice();\n\n  // Finding min array\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  }\n\n  // If array have non overlapping ranges, we can just concatenate them\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n\n  if (aEnd <= bStart) {\n    if (typed.isTypedArray(a))\n      return typed.concat(a, b);\n    return a.concat(b);\n  }\n\n  // Initializing target\n  var array = new a.constructor(a.length + b.length);\n\n  // Iterating until we overlap\n  var i, l, v;\n\n  for (i = 0, l = a.length; i < l; i++) {\n    v = a[i];\n\n    if (v <= bStart)\n      array[i] = v;\n    else\n      break;\n  }\n\n  // Handling overlap\n  var aPointer = i,\n      aLength = a.length,\n      bPointer = 0,\n      bLength = b.length,\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead <= bHead) {\n      array[i++] = aHead;\n      aPointer++;\n    }\n    else {\n      array[i++] = bHead;\n      bPointer++;\n    }\n  }\n\n  // Filling\n  while (aPointer < aLength)\n    array[i++] = a[aPointer++];\n  while (bPointer < bLength)\n    array[i++] = b[bPointer++];\n\n  return array;\n}\n\n/**\n * Perform the union of two already unique sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\nfunction unionUniqueArrays(a, b) {\n\n  // One of the arrays is empty\n  if (a.length === 0)\n    return b.slice();\n  if (b.length === 0)\n    return a.slice();\n\n  // Finding min array\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  }\n\n  // If array have non overlapping ranges, we can just concatenate them\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n\n  if (aEnd < bStart) {\n    if (typed.isTypedArray(a))\n      return typed.concat(a, b);\n    return a.concat(b);\n  }\n\n  // Initializing target\n  var array = new a.constructor();\n\n  // Iterating until we overlap\n  var i, l, v;\n\n  for (i = 0, l = a.length; i < l; i++) {\n    v = a[i];\n\n    if (v < bStart)\n      array.push(v);\n    else\n      break;\n  }\n\n  // Handling overlap\n  var aPointer = i,\n      aLength = a.length,\n      bPointer = 0,\n      bLength = b.length,\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead <= bHead) {\n\n      if (array.length === 0 || array[array.length - 1] !== aHead)\n        array.push(aHead);\n\n      aPointer++;\n    }\n    else {\n      if (array.length === 0 || array[array.length - 1] !== bHead)\n        array.push(bHead);\n\n      bPointer++;\n    }\n  }\n\n  // Filling\n  // TODO: it's possible to optimize a bit here, since the condition is only\n  // relevant the first time\n  while (aPointer < aLength) {\n    aHead = a[aPointer++];\n\n    if (array.length === 0 || array[array.length - 1] !== aHead)\n      array.push(aHead);\n  }\n  while (bPointer < bLength) {\n    bHead = b[bPointer++];\n\n    if (array.length === 0 || array[array.length - 1] !== bHead)\n      array.push(bHead);\n  }\n\n  return array;\n}\n\n/**\n * Perform the intersection of two already unique sorted array-like structures into one.\n *\n * @param  {array} a - First array.\n * @param  {array} b - Second array.\n * @return {array}\n */\nexports.intersectionUniqueArrays = function(a, b) {\n\n  // One of the arrays is empty\n  if (a.length === 0 || b.length === 0)\n    return new a.constructor(0);\n\n  // Finding min array\n  var tmp;\n\n  if (a[0] > b[0]) {\n    tmp = a;\n    a = b;\n    b = tmp;\n  }\n\n  // If array have non overlapping ranges, there is no intersection\n  var aEnd = a[a.length - 1],\n      bStart = b[0];\n\n  if (aEnd < bStart)\n    return new a.constructor(0);\n\n  // Initializing target\n  var array = new a.constructor();\n\n  // Handling overlap\n  var aPointer = binarySearch.lowerBound(a, bStart),\n      aLength = a.length,\n      bPointer = 0,\n      bLength = binarySearch.upperBound(b, aEnd),\n      aHead,\n      bHead;\n\n  while (aPointer < aLength && bPointer < bLength) {\n    aHead = a[aPointer];\n    bHead = b[bPointer];\n\n    if (aHead < bHead) {\n      aPointer = binarySearch.lowerBound(a, bHead, aPointer + 1);\n    }\n    else if (aHead > bHead) {\n      bPointer = binarySearch.lowerBound(b, aHead, bPointer + 1);\n    }\n    else {\n      array.push(aHead);\n      aPointer++;\n      bPointer++;\n    }\n  }\n\n  return array;\n};\n\n/**\n * Merge k sorted array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\nfunction kWayMergeArrays(arrays) {\n  var length = 0,\n      max = -Infinity,\n      al,\n      i,\n      l;\n\n  var filtered = [];\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length;\n\n    if (al === 0)\n      continue;\n\n    filtered.push(arrays[i]);\n\n    length += al;\n\n    if (al > max)\n      max = al;\n  }\n\n  if (filtered.length === 0)\n    return new arrays[0].constructor(0);\n\n  if (filtered.length === 1)\n    return filtered[0].slice();\n\n  if (filtered.length === 2)\n    return mergeArrays(filtered[0], filtered[1]);\n\n  arrays = filtered;\n\n  var array = new arrays[0].constructor(length);\n\n  var PointerArray = typed.getPointerArray(max);\n\n  var pointers = new PointerArray(arrays.length);\n\n  // TODO: benchmark vs. a binomial heap\n  var heap = new FibonacciHeap(function(a, b) {\n    a = arrays[a][pointers[a]];\n    b = arrays[b][pointers[b]];\n\n    if (a < b)\n      return -1;\n\n    if (a > b)\n      return 1;\n\n    return 0;\n  });\n\n  for (i = 0; i < l; i++)\n    heap.push(i);\n\n  i = 0;\n\n  var p,\n      v;\n\n  while (heap.size) {\n    p = heap.pop();\n    v = arrays[p][pointers[p]++];\n    array[i++] = v;\n\n    if (pointers[p] < arrays[p].length)\n      heap.push(p);\n  }\n\n  return array;\n}\n\n/**\n * Perform the union of k sorted unique array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\nfunction kWayUnionUniqueArrays(arrays) {\n  var max = -Infinity,\n      al,\n      i,\n      l;\n\n  var filtered = [];\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length;\n\n    if (al === 0)\n      continue;\n\n    filtered.push(arrays[i]);\n\n    if (al > max)\n      max = al;\n  }\n\n  if (filtered.length === 0)\n    return new arrays[0].constructor(0);\n\n  if (filtered.length === 1)\n    return filtered[0].slice();\n\n  if (filtered.length === 2)\n    return unionUniqueArrays(filtered[0], filtered[1]);\n\n  arrays = filtered;\n\n  var array = new arrays[0].constructor();\n\n  var PointerArray = typed.getPointerArray(max);\n\n  var pointers = new PointerArray(arrays.length);\n\n  // TODO: benchmark vs. a binomial heap\n  var heap = new FibonacciHeap(function(a, b) {\n    a = arrays[a][pointers[a]];\n    b = arrays[b][pointers[b]];\n\n    if (a < b)\n      return -1;\n\n    if (a > b)\n      return 1;\n\n    return 0;\n  });\n\n  for (i = 0; i < l; i++)\n    heap.push(i);\n\n  var p,\n      v;\n\n  while (heap.size) {\n    p = heap.pop();\n    v = arrays[p][pointers[p]++];\n\n    if (array.length === 0 || array[array.length - 1] !== v)\n      array.push(v);\n\n    if (pointers[p] < arrays[p].length)\n      heap.push(p);\n  }\n\n  return array;\n}\n\n/**\n * Perform the intersection of k sorted array-like structures into one.\n *\n * @param  {array<array>} arrays - Arrays to merge.\n * @return {array}\n */\nexports.kWayIntersectionUniqueArrays = function(arrays) {\n  var max = -Infinity,\n      maxStart = -Infinity,\n      minEnd = Infinity,\n      first,\n      last,\n      al,\n      i,\n      l;\n\n  for (i = 0, l = arrays.length; i < l; i++) {\n    al = arrays[i].length;\n\n    // If one of the arrays is empty, so is the intersection\n    if (al === 0)\n      return [];\n\n    if (al > max)\n      max = al;\n\n    first = arrays[i][0];\n    last = arrays[i][al - 1];\n\n    if (first > maxStart)\n      maxStart = first;\n\n    if (last < minEnd)\n      minEnd = last;\n  }\n\n  // Full overlap is impossible\n  if (maxStart > minEnd)\n    return [];\n\n  // Only one value\n  if (maxStart === minEnd)\n    return [maxStart];\n\n  // NOTE: trying to outsmart I(D,I(C,I(A,B))) is pointless unfortunately...\n  // NOTE: I tried to be very clever about bounds but it does not seem\n  // to improve the performance of the algorithm.\n  var a, b,\n      array = arrays[0],\n      aPointer,\n      bPointer,\n      aLimit,\n      bLimit,\n      aHead,\n      bHead,\n      start = maxStart;\n\n  for (i = 1; i < l; i++) {\n    a = array;\n    b = arrays[i];\n\n    // Change that to `[]` and observe some perf drops on V8...\n    array = new Array();\n\n    aPointer = 0;\n    bPointer = binarySearch.lowerBound(b, start);\n\n    aLimit = a.length;\n    bLimit = b.length;\n\n    while (aPointer < aLimit && bPointer < bLimit) {\n      aHead = a[aPointer];\n      bHead = b[bPointer];\n\n      if (aHead < bHead) {\n        aPointer = binarySearch.lowerBound(a, bHead, aPointer + 1);\n      }\n      else if (aHead > bHead) {\n        bPointer = binarySearch.lowerBound(b, aHead, bPointer + 1);\n      }\n      else {\n        array.push(aHead);\n        aPointer++;\n        bPointer++;\n      }\n    }\n\n    if (array.length === 0)\n      return array;\n\n    start = array[0];\n  }\n\n  return array;\n};\n\n/**\n * Variadic merging all of the given arrays.\n *\n * @param  {...array}\n * @return {array}\n */\nexports.merge = function() {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0]))\n      return mergeArrays(arguments[0], arguments[1]);\n  }\n  else {\n    if (isArrayLike(arguments[0]))\n      return kWayMergeArrays(arguments);\n  }\n\n  return null;\n};\n\n/**\n * Variadic function performing the union of all the given unique arrays.\n *\n * @param  {...array}\n * @return {array}\n */\nexports.unionUnique = function() {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0]))\n      return unionUniqueArrays(arguments[0], arguments[1]);\n  }\n  else {\n    if (isArrayLike(arguments[0]))\n      return kWayUnionUniqueArrays(arguments);\n  }\n\n  return null;\n};\n\n/**\n * Variadic function performing the intersection of all the given unique arrays.\n *\n * @param  {...array}\n * @return {array}\n */\nexports.intersectionUnique = function() {\n  if (arguments.length === 2) {\n    if (isArrayLike(arguments[0]))\n      return exports.intersectionUniqueArrays(arguments[0], arguments[1]);\n  }\n  else {\n    if (isArrayLike(arguments[0]))\n      return exports.kWayIntersectionUniqueArrays(arguments);\n  }\n\n  return null;\n};\n"]},"metadata":{},"sourceType":"script"}