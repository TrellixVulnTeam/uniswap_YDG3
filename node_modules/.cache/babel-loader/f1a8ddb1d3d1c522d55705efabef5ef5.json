{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { CurrencyAmount } from '@uniswap/sdk-core';\nimport JSBI from 'jsbi';\nimport { useEffect, useState } from 'react';\nimport { UNI } from '../../constants/tokens';\nimport { useMerkleDistributorContract } from '../../hooks/useContract';\nimport { useActiveWeb3React } from '../../hooks/web3';\nimport { isAddress } from '../../utils';\nimport { calculateGasMargin } from '../../utils/calculateGasMargin';\nimport { useSingleCallResult } from '../multicall/hooks';\nimport { TransactionType } from '../transactions/actions';\nimport { useTransactionAdder } from '../transactions/hooks';\nlet FETCH_CLAIM_MAPPING_PROMISE = null;\n\nfunction fetchClaimMapping() {\n  var _FETCH_CLAIM_MAPPING_;\n\n  return (_FETCH_CLAIM_MAPPING_ = FETCH_CLAIM_MAPPING_PROMISE) !== null && _FETCH_CLAIM_MAPPING_ !== void 0 ? _FETCH_CLAIM_MAPPING_ : FETCH_CLAIM_MAPPING_PROMISE = fetch(`https://raw.githubusercontent.com/Uniswap/mrkl-drop-data-chunks/final/chunks/mapping.json`).then(res => res.json()).catch(error => {\n    console.error('Failed to get claims mapping', error);\n    FETCH_CLAIM_MAPPING_PROMISE = null;\n  });\n}\n\nconst FETCH_CLAIM_FILE_PROMISES = {};\n\nfunction fetchClaimFile(key) {\n  var _FETCH_CLAIM_FILE_PRO;\n\n  return (_FETCH_CLAIM_FILE_PRO = FETCH_CLAIM_FILE_PROMISES[key]) !== null && _FETCH_CLAIM_FILE_PRO !== void 0 ? _FETCH_CLAIM_FILE_PRO : FETCH_CLAIM_FILE_PROMISES[key] = fetch(`https://raw.githubusercontent.com/Uniswap/mrkl-drop-data-chunks/final/chunks/${key}.json`).then(res => res.json()).catch(error => {\n    console.error(`Failed to get claim file mapping for starting address ${key}`, error);\n    delete FETCH_CLAIM_FILE_PROMISES[key];\n  });\n}\n\nconst FETCH_CLAIM_PROMISES = {}; // returns the claim for the given address, or null if not valid\n\nfunction fetchClaim(account) {\n  var _FETCH_CLAIM_PROMISES;\n\n  const formatted = isAddress(account);\n  if (!formatted) return Promise.reject(new Error('Invalid address'));\n  return (_FETCH_CLAIM_PROMISES = FETCH_CLAIM_PROMISES[account]) !== null && _FETCH_CLAIM_PROMISES !== void 0 ? _FETCH_CLAIM_PROMISES : FETCH_CLAIM_PROMISES[account] = fetchClaimMapping().then(mapping => {\n    const sorted = Object.keys(mapping).sort((a, b) => a.toLowerCase() < b.toLowerCase() ? -1 : 1);\n\n    for (const startingAddress of sorted) {\n      const lastAddress = mapping[startingAddress];\n\n      if (startingAddress.toLowerCase() <= formatted.toLowerCase()) {\n        if (formatted.toLowerCase() <= lastAddress.toLowerCase()) {\n          return startingAddress;\n        }\n      } else {\n        throw new Error(`Claim for ${formatted} was not found in partial search`);\n      }\n    }\n\n    throw new Error(`Claim for ${formatted} was not found after searching all mappings`);\n  }).then(fetchClaimFile).then(result => {\n    if (result[formatted]) return result[formatted];\n    throw new Error(`Claim for ${formatted} was not found in claim file!`);\n  }).catch(error => {\n    console.debug('Claim fetch failed', error);\n    throw error;\n  });\n} // parse distributorContract blob and detect if user has claim data\n// null means we know it does not\n\n\nexport function useUserClaimData(account) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const [claimInfo, setClaimInfo] = useState({});\n  useEffect(() => {\n    if (!account || chainId !== 1) return;\n    fetchClaim(account).then(accountClaimInfo => setClaimInfo(claimInfo => {\n      return { ...claimInfo,\n        [account]: accountClaimInfo\n      };\n    })).catch(() => {\n      setClaimInfo(claimInfo => {\n        return { ...claimInfo,\n          [account]: null\n        };\n      });\n    });\n  }, [account, chainId]);\n  return account && chainId === 1 ? claimInfo[account] : null;\n} // check if user is in blob and has not yet claimed UNI\n\n_s(useUserClaimData, \"ZX4eTAhUHUi04tqS27JWqTvc7R4=\", false, function () {\n  return [useActiveWeb3React];\n});\n\nexport function useUserHasAvailableClaim(account) {\n  _s2();\n\n  var _isClaimedResult$resu;\n\n  const userClaimData = useUserClaimData(account);\n  const distributorContract = useMerkleDistributorContract();\n  const isClaimedResult = useSingleCallResult(distributorContract, 'isClaimed', [userClaimData === null || userClaimData === void 0 ? void 0 : userClaimData.index]); // user is in blob and contract marks as unclaimed\n\n  return Boolean(userClaimData && !isClaimedResult.loading && ((_isClaimedResult$resu = isClaimedResult.result) === null || _isClaimedResult$resu === void 0 ? void 0 : _isClaimedResult$resu[0]) === false);\n}\n\n_s2(useUserHasAvailableClaim, \"S6ll+G1SAwuSUg0umNHnklxJjYY=\", false, function () {\n  return [useUserClaimData, useMerkleDistributorContract, useSingleCallResult];\n});\n\nexport function useUserUnclaimedAmount(account) {\n  _s3();\n\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userClaimData = useUserClaimData(account);\n  const canClaim = useUserHasAvailableClaim(account);\n  const uni = chainId ? UNI[chainId] : undefined;\n  if (!uni) return undefined;\n\n  if (!canClaim || !userClaimData) {\n    return CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(0));\n  }\n\n  return CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(userClaimData.amount));\n}\n\n_s3(useUserUnclaimedAmount, \"8sqZlBntnabsh5dclQgWJpMmIBY=\", false, function () {\n  return [useActiveWeb3React, useUserClaimData, useUserHasAvailableClaim];\n});\n\nexport function useClaimCallback(account) {\n  _s4();\n\n  // get claim data for this account\n  const {\n    library,\n    chainId\n  } = useActiveWeb3React();\n  const claimData = useUserClaimData(account); // used for popup summary\n\n  const unclaimedAmount = useUserUnclaimedAmount(account);\n  const addTransaction = useTransactionAdder();\n  const distributorContract = useMerkleDistributorContract();\n\n  const claimCallback = async function () {\n    if (!claimData || !account || !library || !chainId || !distributorContract) return;\n    const args = [claimData.index, account, claimData.amount, claimData.proof];\n    return distributorContract.estimateGas['claim'](...args, {}).then(estimatedGasLimit => {\n      return distributorContract.claim(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          type: TransactionType.CLAIM,\n          recipient: account,\n          uniAmountRaw: unclaimedAmount === null || unclaimedAmount === void 0 ? void 0 : unclaimedAmount.quotient.toString()\n        });\n        return response.hash;\n      });\n    });\n  };\n\n  return {\n    claimCallback\n  };\n}\n\n_s4(useClaimCallback, \"Fdtt/iHnePP+EWZK9zklniwVqJ8=\", false, function () {\n  return [useActiveWeb3React, useUserClaimData, useUserUnclaimedAmount, useTransactionAdder, useMerkleDistributorContract];\n});","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/claim/hooks.ts"],"names":["CurrencyAmount","JSBI","useEffect","useState","UNI","useMerkleDistributorContract","useActiveWeb3React","isAddress","calculateGasMargin","useSingleCallResult","TransactionType","useTransactionAdder","FETCH_CLAIM_MAPPING_PROMISE","fetchClaimMapping","fetch","then","res","json","catch","error","console","FETCH_CLAIM_FILE_PROMISES","fetchClaimFile","key","FETCH_CLAIM_PROMISES","fetchClaim","account","formatted","Promise","reject","Error","mapping","sorted","Object","keys","sort","a","b","toLowerCase","startingAddress","lastAddress","result","debug","useUserClaimData","chainId","claimInfo","setClaimInfo","accountClaimInfo","useUserHasAvailableClaim","userClaimData","distributorContract","isClaimedResult","index","Boolean","loading","useUserUnclaimedAmount","canClaim","uni","undefined","fromRawAmount","BigInt","amount","useClaimCallback","library","claimData","unclaimedAmount","addTransaction","claimCallback","args","proof","estimateGas","estimatedGasLimit","claim","value","gasLimit","response","type","CLAIM","recipient","uniAmountRaw","quotient","toString","hash"],"mappings":"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","sourcesContent":["import { TransactionResponse } from '@ethersproject/providers'\nimport { CurrencyAmount, Token } from '@uniswap/sdk-core'\nimport JSBI from 'jsbi'\nimport { useEffect, useState } from 'react'\n\nimport { UNI } from '../../constants/tokens'\nimport { useMerkleDistributorContract } from '../../hooks/useContract'\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { isAddress } from '../../utils'\nimport { calculateGasMargin } from '../../utils/calculateGasMargin'\nimport { useSingleCallResult } from '../multicall/hooks'\nimport { TransactionType } from '../transactions/actions'\nimport { useTransactionAdder } from '../transactions/hooks'\n\ninterface UserClaimData {\n  index: number\n  amount: string\n  proof: string[]\n  flags?: {\n    isSOCKS: boolean\n    isLP: boolean\n    isUser: boolean\n  }\n}\n\ntype LastAddress = string\ntype ClaimAddressMapping = { [firstAddress: string]: LastAddress }\nlet FETCH_CLAIM_MAPPING_PROMISE: Promise<ClaimAddressMapping> | null = null\nfunction fetchClaimMapping(): Promise<ClaimAddressMapping> {\n  return (\n    FETCH_CLAIM_MAPPING_PROMISE ??\n    (FETCH_CLAIM_MAPPING_PROMISE = fetch(\n      `https://raw.githubusercontent.com/Uniswap/mrkl-drop-data-chunks/final/chunks/mapping.json`\n    )\n      .then((res) => res.json())\n      .catch((error) => {\n        console.error('Failed to get claims mapping', error)\n        FETCH_CLAIM_MAPPING_PROMISE = null\n      }))\n  )\n}\n\nconst FETCH_CLAIM_FILE_PROMISES: { [startingAddress: string]: Promise<{ [address: string]: UserClaimData }> } = {}\nfunction fetchClaimFile(key: string): Promise<{ [address: string]: UserClaimData }> {\n  return (\n    FETCH_CLAIM_FILE_PROMISES[key] ??\n    (FETCH_CLAIM_FILE_PROMISES[key] = fetch(\n      `https://raw.githubusercontent.com/Uniswap/mrkl-drop-data-chunks/final/chunks/${key}.json`\n    )\n      .then((res) => res.json())\n      .catch((error) => {\n        console.error(`Failed to get claim file mapping for starting address ${key}`, error)\n        delete FETCH_CLAIM_FILE_PROMISES[key]\n      }))\n  )\n}\n\nconst FETCH_CLAIM_PROMISES: { [key: string]: Promise<UserClaimData> } = {}\n// returns the claim for the given address, or null if not valid\nfunction fetchClaim(account: string): Promise<UserClaimData> {\n  const formatted = isAddress(account)\n  if (!formatted) return Promise.reject(new Error('Invalid address'))\n\n  return (\n    FETCH_CLAIM_PROMISES[account] ??\n    (FETCH_CLAIM_PROMISES[account] = fetchClaimMapping()\n      .then((mapping) => {\n        const sorted = Object.keys(mapping).sort((a, b) => (a.toLowerCase() < b.toLowerCase() ? -1 : 1))\n\n        for (const startingAddress of sorted) {\n          const lastAddress = mapping[startingAddress]\n          if (startingAddress.toLowerCase() <= formatted.toLowerCase()) {\n            if (formatted.toLowerCase() <= lastAddress.toLowerCase()) {\n              return startingAddress\n            }\n          } else {\n            throw new Error(`Claim for ${formatted} was not found in partial search`)\n          }\n        }\n        throw new Error(`Claim for ${formatted} was not found after searching all mappings`)\n      })\n      .then(fetchClaimFile)\n      .then((result) => {\n        if (result[formatted]) return result[formatted]\n        throw new Error(`Claim for ${formatted} was not found in claim file!`)\n      })\n      .catch((error) => {\n        console.debug('Claim fetch failed', error)\n        throw error\n      }))\n  )\n}\n\n// parse distributorContract blob and detect if user has claim data\n// null means we know it does not\nexport function useUserClaimData(account: string | null | undefined): UserClaimData | null {\n  const { chainId } = useActiveWeb3React()\n\n  const [claimInfo, setClaimInfo] = useState<{ [account: string]: UserClaimData | null }>({})\n\n  useEffect(() => {\n    if (!account || chainId !== 1) return\n\n    fetchClaim(account)\n      .then((accountClaimInfo) =>\n        setClaimInfo((claimInfo) => {\n          return {\n            ...claimInfo,\n            [account]: accountClaimInfo,\n          }\n        })\n      )\n      .catch(() => {\n        setClaimInfo((claimInfo) => {\n          return {\n            ...claimInfo,\n            [account]: null,\n          }\n        })\n      })\n  }, [account, chainId])\n\n  return account && chainId === 1 ? claimInfo[account] : null\n}\n\n// check if user is in blob and has not yet claimed UNI\nexport function useUserHasAvailableClaim(account: string | null | undefined): boolean {\n  const userClaimData = useUserClaimData(account)\n  const distributorContract = useMerkleDistributorContract()\n  const isClaimedResult = useSingleCallResult(distributorContract, 'isClaimed', [userClaimData?.index])\n  // user is in blob and contract marks as unclaimed\n  return Boolean(userClaimData && !isClaimedResult.loading && isClaimedResult.result?.[0] === false)\n}\n\nexport function useUserUnclaimedAmount(account: string | null | undefined): CurrencyAmount<Token> | undefined {\n  const { chainId } = useActiveWeb3React()\n  const userClaimData = useUserClaimData(account)\n  const canClaim = useUserHasAvailableClaim(account)\n\n  const uni = chainId ? UNI[chainId] : undefined\n  if (!uni) return undefined\n  if (!canClaim || !userClaimData) {\n    return CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(0))\n  }\n  return CurrencyAmount.fromRawAmount(uni, JSBI.BigInt(userClaimData.amount))\n}\n\nexport function useClaimCallback(account: string | null | undefined): {\n  claimCallback: () => Promise<string>\n} {\n  // get claim data for this account\n  const { library, chainId } = useActiveWeb3React()\n  const claimData = useUserClaimData(account)\n\n  // used for popup summary\n  const unclaimedAmount: CurrencyAmount<Token> | undefined = useUserUnclaimedAmount(account)\n  const addTransaction = useTransactionAdder()\n  const distributorContract = useMerkleDistributorContract()\n\n  const claimCallback = async function () {\n    if (!claimData || !account || !library || !chainId || !distributorContract) return\n\n    const args = [claimData.index, account, claimData.amount, claimData.proof]\n\n    return distributorContract.estimateGas['claim'](...args, {}).then((estimatedGasLimit) => {\n      return distributorContract\n        .claim(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n        .then((response: TransactionResponse) => {\n          addTransaction(response, {\n            type: TransactionType.CLAIM,\n            recipient: account,\n            uniAmountRaw: unclaimedAmount?.quotient.toString(),\n          })\n          return response.hash\n        })\n    })\n  }\n\n  return { claimCallback }\n}\n"]},"metadata":{},"sourceType":"module"}