{"ast":null,"code":"/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n    comparators = require('./utils/comparators.js'),\n    iterables = require('./utils/iterables.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\n\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = i - 1 >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\n\n\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (rightIndex < endIndex && compare(heap[childIndex], heap[rightIndex]) >= 0) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\n\n\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\n\n\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n    return item;\n  }\n\n  return lastItem;\n}\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\n\n\nfunction replace(compare, heap, item) {\n  if (heap.length === 0) throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n  return popped;\n}\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\n\n\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\n\n\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0) siftUp(compare, array, i);\n}\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\n\n\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n  var array = new Array(l);\n\n  while (i < l) array[i++] = pop(compare, heap);\n\n  return array;\n}\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\n\n\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n  var i, l, v;\n  var min = Infinity;\n  var result; // If n is equal to 1, it's just a matter of finding the minimum\n\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n        if (min === Infinity || compare(v, min) < 0) min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n      return result;\n    }\n\n    forEach(iterable, function (value) {\n      if (min === Infinity || compare(value, min) < 0) min = value;\n    });\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length) return iterable.slice().sort(compare);\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++) if (reverseCompare(iterable[i], result[0]) > 0) replace(reverseCompare, result, iterable[i]); // NOTE: if n is over some number, it becomes faster to consume the heap\n\n\n    return result.sort(compare);\n  } // Correct for size\n\n\n  var size = iterables.guessLength(iterable);\n  if (size !== null && size < n) n = size;\n  result = new Array(n);\n  i = 0;\n  forEach(iterable, function (value) {\n    if (i < n) {\n      result[i] = value;\n    } else {\n      if (i === n) heapify(reverseCompare, result);\n      if (reverseCompare(value, result[0]) > 0) replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n  if (result.length > i) result.length = i; // NOTE: if n is over some number, it becomes faster to consume the heap\n\n  return result.sort(compare);\n}\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\n\n\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n  var i, l, v;\n  var max = -Infinity;\n  var result; // If n is equal to 1, it's just a matter of finding the maximum\n\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n        if (max === -Infinity || compare(v, max) > 0) max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n      return result;\n    }\n\n    forEach(iterable, function (value) {\n      if (max === -Infinity || compare(value, max) > 0) max = value;\n    });\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length) return iterable.slice().sort(reverseCompare);\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++) if (compare(iterable[i], result[0]) > 0) replace(compare, result, iterable[i]); // NOTE: if n is over some number, it becomes faster to consume the heap\n\n\n    return result.sort(reverseCompare);\n  } // Correct for size\n\n\n  var size = iterables.guessLength(iterable);\n  if (size !== null && size < n) n = size;\n  result = new Array(n);\n  i = 0;\n  forEach(iterable, function (value) {\n    if (i < n) {\n      result[i] = value;\n    } else {\n      if (i === n) heapify(compare, result);\n      if (compare(value, result[0]) > 0) replace(compare, result, value);\n    }\n\n    i++;\n  });\n  if (result.length > i) result.length = i; // NOTE: if n is over some number, it becomes faster to consume the heap\n\n  return result.sort(reverseCompare);\n}\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\n\n\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\n\n\nHeap.prototype.clear = function () {\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\n\n\nHeap.prototype.push = function (item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\n\n\nHeap.prototype.peek = function () {\n  return this.items[0];\n};\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\n\n\nHeap.prototype.pop = function () {\n  if (this.size !== 0) this.size--;\n  return pop(this.comparator, this.items);\n};\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\n\n\nHeap.prototype.replace = function (item) {\n  return replace(this.comparator, this.items, item);\n};\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\n\n\nHeap.prototype.pushpop = function (item) {\n  return pushpop(this.comparator, this.items, item);\n};\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\n\n\nHeap.prototype.consume = function () {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\n\n\nHeap.prototype.toArray = function () {\n  return consume(this.comparator, this.items.slice());\n};\n/**\n * Convenience known methods.\n */\n\n\nHeap.prototype.inspect = function () {\n  var proxy = this.toArray(); // Trick so that node displays the name of the constructor\n\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined') Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\n\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n  if (typeof this.comparator !== 'function') throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\n\nHeap.from = function (iterable, comparator) {\n  var heap = new Heap(comparator);\n  var items; // If iterable is an array, we can be clever about it\n\n  if (iterables.isArrayLike(iterable)) items = iterable.slice();else items = iterables.toArray(iterable);\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n  return heap;\n};\n\nMaxHeap.from = function (iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n  var items; // If iterable is an array, we can be clever about it\n\n  if (iterables.isArrayLike(iterable)) items = iterable.slice();else items = iterables.toArray(iterable);\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n  return heap;\n};\n/**\n * Exporting.\n */\n\n\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\nmodule.exports = Heap;","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/node_modules/mnemonist/heap.js"],"names":["forEach","require","comparators","iterables","DEFAULT_COMPARATOR","reverseComparator","siftDown","compare","heap","startIndex","i","item","parentIndex","parent","siftUp","endIndex","length","childIndex","rightIndex","push","pop","lastItem","replace","Error","popped","pushpop","tmp","heapify","array","n","l","consume","Array","nsmallest","iterable","arguments","reverseCompare","v","min","Infinity","result","isArrayLike","constructor","value","slice","sort","size","guessLength","nlargest","max","Heap","comparator","clear","prototype","items","peek","toArray","inspect","proxy","Object","defineProperty","enumerable","Symbol","for","MaxHeap","from","MinHeap","module","exports"],"mappings":"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","sourcesContent":["/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n    comparators = require('./utils/comparators.js'),\n    iterables = require('./utils/iterables.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = (i - 1) >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n\n    return item;\n  }\n\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0)\n    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0)\n    siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n\n  var array = new Array(l);\n\n  while (i < l)\n    array[i++] = pop(compare, heap);\n\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var min = Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (min === Infinity || compare(v, min) < 0)\n          min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (min === Infinity || compare(value, min) < 0)\n        min = value;\n    });\n\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(compare);\n\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (reverseCompare(iterable[i], result[0]) > 0)\n        replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(reverseCompare, result);\n\n      if (reverseCompare(value, result[0]) > 0)\n        replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var max = -Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (max === -Infinity || compare(v, max) > 0)\n          max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (max === -Infinity || compare(value, max) > 0)\n        max = value;\n    });\n\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(reverseCompare);\n\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (compare(iterable[i], result[0]) > 0)\n        replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(compare, result);\n\n      if (compare(value, result[0]) > 0)\n        replace(compare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function(item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function() {\n  if (this.size !== 0)\n    this.size--;\n\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function(item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function(item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function() {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function() {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function(iterable, comparator) {\n  var heap = new Heap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\nMaxHeap.from = function(iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\n\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\n\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\n\nmodule.exports = Heap;\n"]},"metadata":{},"sourceType":"script"}